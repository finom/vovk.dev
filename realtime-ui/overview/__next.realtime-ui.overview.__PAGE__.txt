1:"$Sreact.fragment"
2:I[55169,["/_next/static/chunks/1bf573480194e5f8.js","/_next/static/chunks/ed1eda27d3650aa0.js","/_next/static/chunks/adc22404913f0494.js","/_next/static/chunks/ac2b20c89661f7e5.js","/_next/static/chunks/d77082edaea16d8c.js","/_next/static/chunks/f2ba3063c10f2d64.js","/_next/static/chunks/e7d5eab6c95cc547.js","/_next/static/chunks/5665966a00c311b8.js"],"TOCProvider"]
3:I[769,["/_next/static/chunks/1bf573480194e5f8.js","/_next/static/chunks/ed1eda27d3650aa0.js","/_next/static/chunks/adc22404913f0494.js","/_next/static/chunks/ac2b20c89661f7e5.js","/_next/static/chunks/d77082edaea16d8c.js","/_next/static/chunks/f2ba3063c10f2d64.js","/_next/static/chunks/e7d5eab6c95cc547.js","/_next/static/chunks/5665966a00c311b8.js"],"Sidebar"]
4:I[47486,["/_next/static/chunks/1bf573480194e5f8.js","/_next/static/chunks/ed1eda27d3650aa0.js","/_next/static/chunks/adc22404913f0494.js","/_next/static/chunks/ac2b20c89661f7e5.js","/_next/static/chunks/d77082edaea16d8c.js","/_next/static/chunks/f2ba3063c10f2d64.js","/_next/static/chunks/e7d5eab6c95cc547.js","/_next/static/chunks/5665966a00c311b8.js"],"ClientWrapper"]
9:I[22016,["/_next/static/chunks/1bf573480194e5f8.js","/_next/static/chunks/ed1eda27d3650aa0.js","/_next/static/chunks/adc22404913f0494.js","/_next/static/chunks/ac2b20c89661f7e5.js","/_next/static/chunks/d77082edaea16d8c.js","/_next/static/chunks/f2ba3063c10f2d64.js","/_next/static/chunks/e7d5eab6c95cc547.js","/_next/static/chunks/5665966a00c311b8.js"],""]
10:I[97367,["/_next/static/chunks/ff1a16fafef87110.js","/_next/static/chunks/2b1529e4da954b62.js"],"OutletBoundary"]
11:"$Sreact.suspense"
5:Tc5c,import { Tabs } from 'nextra/components';
import AppAlike from '../AppAlike';
import Image from 'next/image';
import RealtimeNavigation from '../RealtimeNavigation';

# Realtime UI Overview

This series of articles describes a full-stack application called **Realtime Kanban**, demonstrating a **Realtime UI** approach built from established web development techniques. Applications built with this approach behave like regular web apps but can also be fully operated by AI agents via text or voice interfaces, as well as MCP clients—enabling new levels of interactivity (including navigation) and automation, keeping the code both on front-end and back-end short and self-explanatory.

The building blocks of this approach are:

- **Entity-driven state normalization** on the front end using [Zustand](https://github.com/pmndrs/zustand), keeping UI state efficiently synchronized with back-end data and reducing development overhead. Data received from the back end is processed through an entity registry parser that automatically updates the normalized state, allowing components to retrieve entities by ID and re-render as needed.
- **Database schema as the source of truth**, which not only defines the database structure via Postgres and Prisma but also drives Zod schema generation via [prisma-zod-generator](https://www.npmjs.com/package/prisma-zod-generator). These schemas are reused on the back end to validate procedure inputs and keep the codebase as DRY as possible.
- **Database polling events**, powered by Redis and exposed as [JSON Lines](/jsonlines) streaming endpoints, enabling real-time updates without manual refreshes. Changes made by other users, MCP clients, or bots are reflected in the UI automatically.
- **Text-based AI chat interface** implemented with the Vercel [AI SDK](https://ai-sdk.dev/docs/introduction) and [AI Elements](https://ai-sdk.dev/elements), reusing existing controller implementations to derive AI tools. As users interact via chat, the AI agent invokes predefined back-end procedures and sends data updates to the front end, where they are processed through the entity registry.
- **Voice AI interface** powered by the [OpenAI Realtime API](https://platform.openai.com/docs/guides/realtime) and WebRTC, enabling hands-free, JARVIS-like interaction. The AI agent performs authorized HTTP requests to the back end using generated RPC modules, with resulting data updates flowing through the same entity registry pipeline. The provided example also demonstrates client-side tools, that implement navigation across the pages of the app.
- **MCP server** that enables interaction via Model Context Protocol clients. The server executes procedures locally on the back end, triggering polling events that update front-end state through the entity registry.
- **Updating from other sources**, implemented as **Telegram bot integration** allowing users to manage tasks through a text or voice interface within Telegram, and demonstrating that the app can be controlled from various platforms.

The app can be [run locally](./run) via Docker Compose or deployed to any Node.js hosting platform, such as [Vercel](./deploy).0:{"buildId":"EikntA9B2n23ryyVG4EYi","rsc":["$","$1","c",{"children":[["$","div",null,{"className":"x:mx-auto x:flex x:max-w-(--nextra-content-width)","children":["$","$L2",null,{"value":[],"children":[["$","$L3",null,{}],["$","$L4",null,{"metadata":{"title":"Realtime UI Overview","filePath":"src/app/realtime-ui/overview/page.mdx","timestamp":1767456623000},"sourceCode":"$5","children":["$L6","$L7"]}]]}]}],null,"$L8"]}],"loading":null,"isPartial":false}
6:["$","div",null,{"id":"nextra-skip-nav"}]
7:["$","main",null,{"data-pagefind-body":true,"children":[["$","h1",null,{"className":"x:tracking-tight x:text-slate-900 x:dark:text-slate-100 x:font-bold x:mt-2 x:text-4xl","children":["Realtime UI Overview","$undefined"]}],"\n",["$","p",null,{"className":"x:not-first:mt-[1.25em] x:leading-7","children":["This series of articles describes a full-stack application called ",["$","strong",null,{"children":"Realtime Kanban"}],", demonstrating a ",["$","strong",null,{"children":"Realtime UI"}]," approach built from established web development techniques. Applications built with this approach behave like regular web apps but can also be fully operated by AI agents via text or voice interfaces, as well as MCP clients—enabling new levels of interactivity (including navigation) and automation, keeping the code both on front-end and back-end short and self-explanatory."]}],"\n",["$","p",null,{"className":"x:not-first:mt-[1.25em] x:leading-7","children":"The building blocks of this approach are:"}],"\n",["$","ul",null,{"className":"x:[:is(ol,ul)_&]:my-[.75em] x:not-first:mt-[1.25em] x:list-disc x:ms-[1.5em]","children":["\n",["$","li",null,{"className":"x:my-[.5em]","children":[["$","strong",null,{"children":"Entity-driven state normalization"}]," on the front end using ",["$","a",null,{"href":"https://github.com/pmndrs/zustand","target":"_blank","rel":"noreferrer","className":"x:focus-visible:nextra-focus x:text-primary-600 x:underline x:hover:no-underline x:decoration-from-font x:[text-underline-position:from-font]","children":["Zustand",[" ",["$","svg",null,{"fill":"none","stroke":"currentColor","strokeLinecap":"round","strokeLinejoin":"round","strokeWidth":1.7,"viewBox":"0 0 24 24","height":"1em","className":"x:inline x:align-baseline x:shrink-0","children":[["$","path",null,{"d":"M7 17L17 7"}],["$","path",null,{"d":"M7 7h10v10"}]]}]]]}],", keeping UI state efficiently synchronized with back-end data and reducing development overhead. Data received from the back end is processed through an entity registry parser that automatically updates the normalized state, allowing components to retrieve entities by ID and re-render as needed."]}],"\n",["$","li",null,{"className":"x:my-[.5em]","children":[["$","strong",null,{"children":"Database schema as the source of truth"}],", which not only defines the database structure via Postgres and Prisma but also drives Zod schema generation via ",["$","a",null,{"href":"https://www.npmjs.com/package/prisma-zod-generator","target":"_blank","rel":"noreferrer","className":"x:focus-visible:nextra-focus x:text-primary-600 x:underline x:hover:no-underline x:decoration-from-font x:[text-underline-position:from-font]","children":["prisma-zod-generator",[" ",["$","svg",null,{"fill":"none","stroke":"currentColor","strokeLinecap":"round","strokeLinejoin":"round","strokeWidth":1.7,"viewBox":"0 0 24 24","height":"1em","className":"x:inline x:align-baseline x:shrink-0","children":[["$","path",null,{"d":"M7 17L17 7"}],["$","path",null,{"d":"M7 7h10v10"}]]}]]]}],". These schemas are reused on the back end to validate procedure inputs and keep the codebase as DRY as possible."]}],"\n",["$","li",null,{"className":"x:my-[.5em]","children":[["$","strong",null,{"children":"Database polling events"}],", powered by Redis and exposed as ",["$","$L9",null,{"href":"/jsonlines","className":"x:focus-visible:nextra-focus x:text-primary-600 x:underline x:hover:no-underline x:decoration-from-font x:[text-underline-position:from-font]","children":"JSON Lines"}]," streaming endpoints, enabling real-time updates without manual refreshes. Changes made by other users, MCP clients, or bots are reflected in the UI automatically."]}],"\n",["$","li",null,{"className":"x:my-[.5em]","children":[["$","strong",null,{"children":"Text-based AI chat interface"}]," implemented with the Vercel ",["$","a",null,{"href":"https://ai-sdk.dev/docs/introduction","target":"_blank","rel":"noreferrer","className":"x:focus-visible:nextra-focus x:text-primary-600 x:underline x:hover:no-underline x:decoration-from-font x:[text-underline-position:from-font]","children":["AI SDK","$La"]}]," and ","$Lb",", reusing existing controller implementations to derive AI tools. As users interact via chat, the AI agent invokes predefined back-end procedures and sends data updates to the front end, where they are processed through the entity registry."]}],"\n","$Lc","\n","$Ld","\n","$Le","\n"]}],"\n","$Lf"]}]
8:["$","$L10",null,{"children":["$","$11",null,{"name":"Next.MetadataOutlet","children":"$@12"}]}]
a:[" ",["$","svg",null,{"fill":"none","stroke":"currentColor","strokeLinecap":"round","strokeLinejoin":"round","strokeWidth":1.7,"viewBox":"0 0 24 24","height":"1em","className":"x:inline x:align-baseline x:shrink-0","children":[["$","path",null,{"d":"M7 17L17 7"}],["$","path",null,{"d":"M7 7h10v10"}]]}]]
b:["$","a",null,{"href":"https://ai-sdk.dev/elements","target":"_blank","rel":"noreferrer","className":"x:focus-visible:nextra-focus x:text-primary-600 x:underline x:hover:no-underline x:decoration-from-font x:[text-underline-position:from-font]","children":["AI Elements",[" ",["$","svg",null,{"fill":"none","stroke":"currentColor","strokeLinecap":"round","strokeLinejoin":"round","strokeWidth":1.7,"viewBox":"0 0 24 24","height":"1em","className":"x:inline x:align-baseline x:shrink-0","children":[["$","path",null,{"d":"M7 17L17 7"}],["$","path",null,{"d":"M7 7h10v10"}]]}]]]}]
c:["$","li",null,{"className":"x:my-[.5em]","children":[["$","strong",null,{"children":"Voice AI interface"}]," powered by the ",["$","a",null,{"href":"https://platform.openai.com/docs/guides/realtime","target":"_blank","rel":"noreferrer","className":"x:focus-visible:nextra-focus x:text-primary-600 x:underline x:hover:no-underline x:decoration-from-font x:[text-underline-position:from-font]","children":["OpenAI Realtime API",[" ",["$","svg",null,{"fill":"none","stroke":"currentColor","strokeLinecap":"round","strokeLinejoin":"round","strokeWidth":1.7,"viewBox":"0 0 24 24","height":"1em","className":"x:inline x:align-baseline x:shrink-0","children":[["$","path",null,{"d":"M7 17L17 7"}],["$","path",null,{"d":"M7 7h10v10"}]]}]]]}]," and WebRTC, enabling hands-free, JARVIS-like interaction. The AI agent performs authorized HTTP requests to the back end using generated RPC modules, with resulting data updates flowing through the same entity registry pipeline. The provided example also demonstrates client-side tools, that implement navigation across the pages of the app."]}]
d:["$","li",null,{"className":"x:my-[.5em]","children":[["$","strong",null,{"children":"MCP server"}]," that enables interaction via Model Context Protocol clients. The server executes procedures locally on the back end, triggering polling events that update front-end state through the entity registry."]}]
e:["$","li",null,{"className":"x:my-[.5em]","children":[["$","strong",null,{"children":"Updating from other sources"}],", implemented as ",["$","strong",null,{"children":"Telegram bot integration"}]," allowing users to manage tasks through a text or voice interface within Telegram, and demonstrating that the app can be controlled from various platforms."]}]
f:["$","p",null,{"className":"x:not-first:mt-[1.25em] x:leading-7","children":["The app can be ",["$","$L9",null,{"href":"./run","className":"x:focus-visible:nextra-focus x:text-primary-600 x:underline x:hover:no-underline x:decoration-from-font x:[text-underline-position:from-font]","children":"run locally"}]," via Docker Compose or deployed to any Node.js hosting platform, such as ",["$","$L9",null,{"href":"./deploy","className":"x:focus-visible:nextra-focus x:text-primary-600 x:underline x:hover:no-underline x:decoration-from-font x:[text-underline-position:from-font]","children":"Vercel"}],"."]}]
12:null
