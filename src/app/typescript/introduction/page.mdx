import { Callout } from 'nextra/components';

# TypeScript client

```sh filename="Generate client with CLI"
npx vovk generate
```

[`vovk generate` documentation](/cli/generate)

Vovk.ts generates a type-safe TypeScript client library compiled to **node_modules/.vovk-client** folder (can be configured at [config](/config)). It's compiled from the [schema](/schema) and generated by `vovk generate` (only generates) and `vovk dev` (starts dev server, emits schema and then generates the RPC client). The files are then re-exported at the **vovk-client** package.

TypeScript client is built with the following templates using [EJS](https://www.npmjs.com/package/ejs):

- **main** - a "compiled" CJS module with typescript definitions represented as **main.cjs** and **main.d.cts** files.
- **module** - a "compiled" ESM module with typescript definitions represented as **module.mjs** and **module.d.mts** files.
- **ts** - an "uncompiled" TypeScript module represented as **index.ts** file
- **fullSchema** - a "compiled" CJS module of full schema (compiling **.vovk-schema/**/\*.json** files into one object) with typescript definitions that is imported by the files generated from the templates above. It's used implicitly and compiled by default when one of these 3 templates were used. It represented as **fullSchema.cjs** and **fullSchema.d.cts\*\* files.

By default **main** and **module** templates are used (plus **fullSchema**). You can configure that in the [config](/config) file with `generateFrom` option or using `--template` CLI option for `vovk generate` command. See [documentation](/cli/generate) for more details.

These built-in templates are located in the **client-templates** folder of [vovk-cli](/cli) package.

> [!TIP]
>
> You can prettify the generated client by setting `prettifyClient` option to `true` at [config](/config).

{/* TODO: Add tabs with generated examples */}

The generated client library uses `fetch` function to make requests to the server.

```ts
import { UserRPC } from 'vovk-client';

// ...

const updatedUser = await UserRPC.updateUser({
  body: { firstName, lastName },
  query: { notify: 'push' },
  params: { id },
});

// same as
const resp = fetch(`/api/users/${id}?notify=push`, {
  method: 'PUT',
  body: JSON.stringify({ firstName, lastName }),
});

const updatedUser = (await resp.json()) as User;
```

If you don't like the naming convention of the generated client library, you can change it in the [segment](/segment).

```ts filename="/src/app/api/[[...vovk]]/route.ts"
// ...
const controllers = {
  users: UserController,
};
// ...
```

The client import may look like this:

```ts
import * as api from 'vovk-client';

await api.users.updateUser({
  // ...
});
```

## Customization

The client library's fetching function, as well as its types can be customised in order to follow logic required by the application. See [customization docs](/client/customization) for more details.

```ts
await UserRPC.updateUser({
  // ...
  successMessage: 'Successfully updated the user',
  someOtherCustomFlag: true,
});
```

## Type override

In case if your code makes it impossible to recognise the return type, you can override it manually with no need to convert it to `unknown` first.

```ts
import { UserRPC } from 'vovk-client';
import type { SomeType } from '../types';

// ...

// Override the return type
const updatedUser = await UserRPC.updateUser<SomeType>(/* ... * /);
```

## Async iterable

```ts filename="/src/modules/user/UserController.ts"
import { get } from 'vovk';
export default class UserController {
  @get()
  static async *doSomething(/* ... */) {
    yield* iterable;
  }
}
```

If iterable is returned, the client library is going to cast the method as a disposable async generator to implement response streaming. It's explained in more details on the [JSON streaming documentation](/streaming).

## Access to schema

Every RPC method has access to the emitted JSON schema. They are available in the following properties:

- `schema` - the schema for this method of type `VovkHandlerSchema`;
- `controllerSchema` - the schema object of the method's controller of type `VovkControllerSchema`;
- `segmentSchema` - the schema object of the segment of type `VovkSegmentSchema`;
- `fullSchema` - the full schema object of type `VovkFullSchema` that includes all segments but also emitted config (by default `"libs"` option only, see [config documentation](/config)).

```ts
console.log(UserRPC.updateUser.schema.validation.body); // get body validation JSON schema
console.log(UserRPC.updateUser.schema.openapi); // get openapi spec for this method
console.log(UserRPC.updateUser.fullSchema.config.libs.ajv); // get config option
```

You can access the properties to add primary validation for forms:

```ts
import { UserRPC } from 'vovk-client';
import type { VovkBody } from 'vovk';
import { useForm } from 'react-hook-form';
import { ajvResolver } from '@hookform/resolvers/ajv';
import { fastFormats } from 'ajv-formats/dist/formats';

export default function ZodHookFormExample() {
  const { getValues } = useForm<VovkBody<typeof UserRPC.updateUser>>({
    resolver: ajvResolver(UserRPC.updateUser.schema.validation.body, {
      formats: fastFormats,
    }),
  });

  // ...
}
```

See example TODO
