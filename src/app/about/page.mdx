import { FileTree, Tabs } from 'nextra/components';
import Image from 'next/image';

# About (WIP)

This conceptual back-end framework is designed, developed, documented and tested by [Andrey Gubanov](https://github.com/finom). Bult for effeciency and unprecedented DX.

**Features:**

- RESTful APIs + RPC.
- Client-side validation and TypeScript inference.
- First-class OpenAPI support.
- Single point deployment for frontend and backend, as it's a normal Next.js app.
- Function calling framework that turns your back-end into an AI agent.
- Built on standards and conventions.

## Node.js/Next.js back-end framework

The project was heavily inspired by [NestJS](https://nestjs.com/) that's built on top of [Express](https://expressjs.com/) a lower-level Node.js framework, extending it with modular architecture for large back-end apps. Vovk.ts achieves similar goal using [Next.js Route Handlers](https://nextjs.org/docs/app/getting-started/route-handlers-and-middleware) as a lower-level HTTP framework, but installed on top of a new or existing Next.js project as a set of secondary dependencies.

## "Segment"

Vovk.ts introduces another hierarchical level to back-end called [segments](/segment/introduction) that allows to split the back-end into smaller parts configured differently, that emit RPC schema separately for each segment. Traditional hierarchy that looks like `back-end -> controller -> handler` gets extended to `back-end -> segment -> controller -> handler`. Each segment is a separate Next.js route that can be configured independently and compiled into a separate serverless function on build, creating multiple smaller "back-ends".


<Image src="/draw/segment-concept.svg" alt="Segment" width={1874.4446105957031} height={745.1328125} className="mt-4 dark:invert" />

A segment can be turned into a [static segment](/segment/static) that makes its endpoints to be compiled into static JSON files during the build time, allowing to use them for historical data, OpenAPI documentation, or any other data that is generated on build time.

## RESTful JSON API + RPC

Vovk.ts is a RESTful API back-end framework that implements well-known and widely used patterns. It can be used as a regular back-end framework to build endpoints that follow the market-wide RESTful API conventions, such as:

- Naming conventions for URLs and endpoints: `/users`, `/products/{id}`
- Query parameters for filtering and pagination: `?page=1&limit=10`
- HTTP methods explicitly defined by a developer: `GET`, `POST`, `PUT`, `DELETE` etc.
- Status codes returned by the server: `200 OK`, `404 Not Found`, etc.
  and so on.

On the client side, the back-end endpoints can be invoked using the `fetch` API or any other HTTP client:

```ts
// Update user with ID 12345
const resp = await fetch('/api/users/12345?notify=push', {
  method: 'PUT',
  body: JSON.stringify({ name: 'John Doe' }),
  headers: {
    'Content-Type': 'application/json',
  },
});

const result = (await resp.json()) as UserType; // some user type
```

For the RESTful API requests, Vovk.ts also implements [RPC](https://e2n.wikipedia.org/wiki/Remote_procedure_call) (Remote Procedure Call) paradigm that allows to call back-end functions as if they were local, making a normal `fetch` request under the hood.

```ts
import { UserRPC } from 'vovk-client';

const result = await UserRPC.updateUser({
  params: { id: '12345' },
  body: { name: 'John Doe' },
  query: { notify: 'push' },
});

result satisfies UserType;
```

These two concepts are usually oppose each other, but in Vovk.ts they are combined, making RESTful API client thinner and moving away from the idea of hidden implementation of RPC calls.

This idea is achieved by combining code generation with TypeScript inference, mapping each RPC call onto a specially constructed URL.

TODO image!

<Image
  src="/draw/restful-rpc.svg"
  alt="RESTful API RPC"
  width={2154.921875}
  height={631.6171874999999}
  className="mt-4 dark:invert"
/>

**How it Works?**

1. **Request Encoding**. The client encodes the target method name and its arguments into a URL.  
   `/api/users/12345?notify=push` translates to a call to the `updateUser` method of the `UserRPC` module with `id` parameter set to `12345` and `notify` query parameter set to `push`.
2. **URL Dispatching**. When the server receives this URL, its routing logic parses the path to identify the correct controller and method handler.
3. **Invocation**. The handler is invoked with the parsed parameters, executes the business logic, and returns the result.

## Controller and Service

HTTP handlers are implemented as decorated static class methods, that expect two arguments: `req: NextRequest` (enhanced with typed `req.json`, `req.nextUrl` etc using `VovkRequest<TBody, TQuery, TParams>` type) and `params: TParams`. The class (often called "static class" at this documentation) is initailized (but not instantiated with `new{:js}`) at `route.ts` file, declaring a new RPC module, described below.

A controller can be decomposed into the controller itself and one or more services that contain busines logic (DB/API calls). Service methods can safely infer controller method types, even if the controller method returns the reults of the service method, without triggering "explicit any" error on self-references, thanks to a fix [#58616](https://github.com/microsoft/TypeScript/issues/58616) to TypeScript, made by [Anders Hejlsberg](https://github.com/ahejlsberg).

<Tabs items={['Controller', 'Service', 'Segment route']}>
<Tabs.Tab>
```ts filename="src/modules/user/UserController.ts"
import { put, prefix } from 'vovk';
import UserService from './UserService';

@prefix('users')
export default class UserController {
  @put('{id}')
  static async updateUser(req: VovkRequest<{ name: string }, { notify: string }>, { id }: { id: string }) {
    return UserService.updateUser(await req.json(), req.nextUrl.searchParams.get('notify'), id);
  }
}
```
</Tabs.Tab>
<Tabs.Tab>
```ts filename="src/modules/user/UserService.ts"
import type { VovkBody, VovkQuery, VovkParams } from 'vovk';
import type UserController from './UserController';

export default class UserService {
  static async updateUser(
    body: VovkBody<typeof UserController.updateUser>,
    notify: VovkQuery<typeof UserController.updateUser>['notify'],
    id: VovkParams<typeof UserController.updateUser>['id'],
  ) {
    // handle the request
    console.log({ body, notify, id }); // { body: { name: 'John Doe' }, notify: 'push', id: '12345' }
    return { body, notify, id, success: true };
  }
}
```
</Tabs.Tab>
<Tabs.Tab>
```ts filename="src/app/api/[[...vovk]]/route.ts"
import { initSegment } from 'vovk';
import UserController from '@/modules/user/UserController';

const controllers = {
  UserRPC: UserController,
};

export type Controllers = typeof controllers; // used for type safety at RPC client

export const { GET, POST, PUT, DELETE } = initSegment({
  controllers,
});
```
</Tabs.Tab>
</Tabs>

## "RPC Module"

A controller is initalized at `route.ts`, will be rendered as an RPC module that has the same list of methods with mapped signatures. The controller method accepts a request, and the RPC method accepts input + some other stuff.

Server-side controllers are implemented as classes with static methods only (called "static classes" in this documentation) that are initialized at the segment `route.ts` file with `initSegment` function. The `controllers` option of the `initSegment` defines names of the resulting **RPC modules**, that have similar shape with different arguments signatures.

Turned into an RPC module:

```ts
import { UserRPC } from 'vovk-client';

const result = await UserRPC.updateUser({
  params: { id: '12345' },
  body: { name: 'John Doe' },
  query: { notify: 'push' },
});

result satisfies { success: boolean };
```

Unlike traditional RPC frameworks, **Vovk.ts RPC modules have 3 inputs instead of 1**, allowing to pass URL parameters, query parameters, and request body separately.

When a controller method is implemented with a [validation library](/validation), the incoming HTTP request input is validated automatically on the server side, and if it's invoked from an RPC module, the **data is validated on the client side** as well using the JSON schema generated from the validation library. This allows to catch errors early on the client side, before the request is sent to the server.

## Schema

Each segment emits back-end schema into an individual JSON file that is used to generate client-side RPC modules. If you have different areas of your application (e.g. root, admin, customer), each area will have its own JSON schema file located at a configurable dir `.vovk-schema/`. For a segment structure like this:

<FileTree>
  <FileTree.Folder name="src/app/api" defaultOpen>
    <FileTree.Folder name="[[...vovk]]" defaultOpen>
      <FileTree.File
        name={
          <span>
            route.ts{' '}
            <span className="text-gray-500">
              (root segment <code>/api/</code>)
            </span>
          </span>
        }
      />
    </FileTree.Folder>
    <FileTree.Folder name="admin/[[...vovk]]" defaultOpen>
      <FileTree.File
        name={
          <span>
            route.ts{' '}
            <span className="text-gray-500">
              (admin segment <code>/api/admin</code>)
            </span>
          </span>
        }
      />
    </FileTree.Folder>
    <FileTree.Folder name="customer/[[...vovk]]" defaultOpen>
      <FileTree.File
        name={
          <span>
            route.ts{' '}
            <span className="text-gray-500">
              (customer segment <code>/api/customer</code>)
            </span>
          </span>
        }
      />
      <FileTree.Folder name="static/[[...vovk]]" defaultOpen>
        <FileTree.File
          name={
            <span>
              route.ts{' '}
              <span className="text-gray-500">
                (static segment <code>/api/customer/static</code> for OpenAPI)
              </span>
            </span>
          }
        />
      </FileTree.Folder>
    </FileTree.Folder>
  </FileTree.Folder>
</FileTree>

the resulting schema files will be located in `.vovk-schema/` directory like this:

<FileTree>
  <FileTree.Folder name=".vovk-schema" defaultOpen>
    <FileTree.File name="root.json" />
    <FileTree.File name="admin.json" />
    <FileTree.File name="customer.json" />
    <FileTree.Folder name="customer" defaultOpen>
      <FileTree.File name="static.json" />
    </FileTree.Folder>
    <FileTree.File name="_meta.json" />
  </FileTree.Folder>
</FileTree>

Each individual schema file represents a segment and contains and contains all RPC modules defined in that segment. It follows the same recursive structure as the segments, where `root.json` is a special name for the root segment with name `""`. `_meta.json` file contains additional metadata, such as explicitly emitted fields of the [vovk.config](/config) file.

## "Composed" vs "segmented" RPC clients

By default Vovk.ts emits a single RPC client that contains all RPC modules from all segments. This approach is called **"composed RPC client"** and it's useful for single-page applications where you want to have a single entry point for all RPC modules.

However, in larger applications, exposing schema for all segments in a single RPC client isn't always desirable. In this case, with a simple configuration change, you can instruct Vovk.ts to generate separate RPC clients for each segment.

<FileTree>
  <FileTree.Folder name="app/client" defaultOpen>
    <FileTree.Folder name="root" defaultOpen>
      <FileTree.File
        name={
          <span>
            index.ts{' '}
            <span className="text-gray-500">
              (imports <code>./schema.ts</code>)
            </span>
          </span>
        }
      />
      <FileTree.File
        name={
          <span>
            schema.ts{' '}
            <span className="text-gray-500">
              (imports <code>.vovk-schema/root.json)</code>
            </span>
          </span>
        }
      />
    </FileTree.Folder>
    <FileTree.Folder name="admin" defaultOpen>
      <FileTree.File
        name={
          <span>
            index.ts{' '}
            <span className="text-gray-500">
              (imports <code>./schema.ts</code>)
            </span>
          </span>
        }
      />
      <FileTree.File
        name={
          <span>
            schema.ts{' '}
            <span className="text-gray-500">
              (imports <code>.vovk-schema/admin.json)</code>
            </span>
          </span>
        }
      />
    </FileTree.Folder>
    <FileTree.Folder name="customer" defaultOpen>
      <FileTree.File
        name={
          <span>
            index.ts{' '}
            <span className="text-gray-500">
              (imports <code>./schema.ts</code>)
            </span>
          </span>
        }
      />
      <FileTree.File
        name={
          <span>
            schema.ts{' '}
            <span className="text-gray-500">
              (imports <code>.vovk-schema/customer.json</code>)
            </span>
          </span>
        }
      />
      <FileTree.Folder name="static" defaultOpen>
        <FileTree.File
          name={
            <span>
              index.ts{' '}
              <span className="text-gray-500">
                (imports <code>./schema.ts</code>)
              </span>
            </span>
          }
        />
        <FileTree.File
          name={
            <span>
              schema.ts{' '}
              <span className="text-gray-500">
                (imports <code>.vovk-schema/customer/static.json</code>)
              </span>
            </span>
          }
        />
      </FileTree.Folder>
    </FileTree.Folder>
  </FileTree.Folder>
</FileTree>

This approach is called **"segmented RPC client"** and it allows to split the client into smaller TypeScript files that can be imported separately, hiding RPC modules and corresponding schema on specific pages. For example, pages responsible for "customer" functionality isn't going to import "admin" RPC modules, therefore "admin" implementation details are hidden from the customer pages.

## Validation

Vovk.ts supports any validation library that implements [Standard Schema](https://github.com/standard-schema/standard-schema/), including [Zod 4](https://github.com/colinhacks/zod), [Valibot](https://github.com/fabian-hiller/valibot), [Arktype](https://github.com/arktypeio/arktype), but also [Zod 3](https://github.com/colinhacks/zod), [class-validator](https://github.com/typestack/class-validator) and can be extended with any other TypeScript validation library. The only requirement is that the library should be able to generate JSON schema from the validation rules in order to validate the data on the client side, build typed client, generate OpenAPI documentation, etc. The primary validation library that is used in the documentation is Zod 4 but it's up to you to choose the one that fits your needs.

Methods that need to be validated are implemented with `with[LIBRARY]` function that accepts validation models and `handle` function that receives the request and the parameters. The types of the request and parameters are inferred from the validation models, allowing to use them in the `handle` function without any additional type annotations.

```ts
import { z } from 'zod';
import { prefix, post, operation, type VovkOutput } from 'vovk';
import { withZod } from 'vovk-zod';

@prefix('users')
export default class UserController {
  @operation({
    summary: 'Update user (Zod)',
    description: 'Update user by ID with Zod validation',
  })
  @post('{id}')
  static updateUser = withZod({
    body: z
      .object({
        name: z.string().describe('User full name'),
        age: z.number().min(0).max(120).describe('User age'),
        email: z.email().describe('User email'),
      })
      .describe('User object'),
    params: z.object({
      id: z.uuid().describe('User ID'),
    }),
    query: z.object({
      notify: z.enum(['email', 'push', 'none']).describe('Notification type'),
    }),
    output: z
      .object({
        success: z.boolean().describe('Success status'),
      })
      .describe('Response object'),
    async handle(req, { id }) {
      const { name, age } = await req.json();
      const notify = req.nextUrl.searchParams.get('notify');

      // do something with the data
      console.log(`Updating user ${id}:`, { name, age, notify });
      return {
        success: true,
      } satisfies VovkOutput<typeof UserZodController.updateUser>;
    },
  });
}
```

(TODO) As you will see during your exploration of this documentation, a controller method that uses validation is being a source of truth for many things:

- Type inference:
  - Server-side, to enhance built-in functionality fo `NextRequest` object and provide types for `req.json()` etc.
  - Client-side, to build typed RPC modules with expected inputs.
- Validation:
  - Server-side, to validate incoming requests with Zod, Arktype and other libraries and return an error if the data is invalid.
  - Client-side, to validate data with Ajv before sending the request and throw an error if the data is invalid in the client.
- Code generation for TypeScript, Rust, Python
- OpenAPI object, exported as `openapi` variable.
- Copy-pastable code snippets for READMEs and OpenAPI documentation...
- Function Calling
  - Server-side to execute the function at the current evaluation context.
  - Client-side to call the function using HTTP protocol.
- And more, as developer now has access to the back-end schema.

## JSON Lines

Vovk.ts includes first class support for [JSON Lines](https://jsonlines.org/) format, which is a convenient way to implement "one request - many responses". It's perfect for LLM completions, but also opens up a new field for experiments, such as [progressive responses](/controller/progressive) and [polling](/polling). JSONLines is another kind of output that uses `iteration` validation field and produces `application/jsonl` content-type if client-side includes `Accept: application/jsonl` header. If the `Accepts` header doesn't include `application/jsonl`, the output is returned as `text/plain` to be available when the endpoint URL is opened directly in the browser.

```ts
import { z } from 'zod';
import { prefix, post, type VovkIteration } from 'vovk';
import { withZod } from 'vovk-zod';

@prefix('stream')
export default class StreamController {
  @post('completions')
  static getJSONLines = withZod({
    // ...
    iteration: z.object({
      message: z.string(),
    }),
    async handle() {
      const tokens: VovkIteration<typeof StreamController.getJSONLines>[] = [
        { message: 'Hello,' },
        { message: ' World' },
        { message: ' from' },
        { message: ' Stream' },
        { message: '!' },
      ];

      for (const token of tokens) {
        await new Promise((resolve) => setTimeout(resolve, 300));
        yield token;
      }
    },
  });
}
```

On the client side, the JSONLines output can be consumed using disposable async iterators, allowing to process each line as it arrives:

```ts
import { StreamRPC } from 'vovk-client';

using stream = await StreamRPC.getJSONLines();

for await (const { message } of stream) {
  console.log('Received message:', message);
}
```

## Custom responses

Vovk.ts is a wrapper around Next.js API routes, so the handlers can return any instance of `Response` class, including `NextResponse` or `NextResponse.json()`, allowing to use all Next.js features, such as cookies, headers, and so on. Vovk.ts is designed to use existing Next.js features, and never reinvent the wheel.

```ts
import { NextResponse, headers } from 'next/server';
import { prefix, get } from 'vovk';

@prefix('users')
export default class UsersController {
  @get('{id}')
  static async getUser() {
    console.log('Headers:', await headers());
    return NextResponse.json({ name: 'John Doe' });
  }
}
```

## `FormData`

Vovk.ts distinguishes JSON and `FormData` bodies with `isForm` flag passed as validation option. This option does two things: it changes the resulting type signature of the input `body` to `FormData` instance, and also adds `x-formData` custom option to the resulting handler schema, to be able to distinguish it from regular JSON requests and validate it on the client side.

```ts
export default class UserController {
  @post('create')
  static createUser = withZod({
    body: z.object({
      name: z.string(),
      age: z.number(),
    }),
    isForm: true, // this will change the body type to FormData
    async handle(req) {
      const formData = await req.formData();
      // ...
    },
  });
}
```

On the client-side the `createUser` RPC method will accept `FormData` instance as a body:

```ts
import { UserRPC } from 'vovk-client';

const formData = new FormData();
formData.append('name', 'John Doe');
formData.append('age', '30');

const response = await UserRPC.createUser({
  body: formData,
});
```


## - AI utilities

## - OpenAPI OAS doc emission

## OpenAPI mixins & Codegen with component-agnostic type inference (TODO)

The client-side RPC modules can be mixed with OpenAPI schema files, creating a pseudo-segment called in this documentation **"OpenAPI Mixin"**. The provided OpenAPI schema is converted into Vovk.ts Schema under the hood and the generated client gets mixed with the existing RPC modules, allowing to call OpenAPI endpoints as if they were RPC modules. This is useful for integrating with existing services that provide OpenAPI schema.

```ts
// UserRPC is a local RPC module defined in the segment
// GithubIssuesRPC is generated from OpenAPI schema file
import { UserRPC, GithubIssuesRPC } from 'vovk-client';

const issues = await GithubIssuesRPC.list({
  query: { filter: 'created' },
  init: {
    headers: {
      Authorization: `Bearer ${process.env.GITHUB_TOKEN}`,
      'X-GitHub-Api-Version': '2022-11-28',
    },
  },
});
```

Unlike traditional codegen tools, Vovk.ts splits the resulting library into smaller RPC modules, allowing to import only the necessary parts of the library and split the code into smaller logical chunks, but also provides a unified interface with fixed list of input parameters, such as `params`, `query`, and `body`, making it easier to use and understand.

Vovk.ts also includes code generator templates for Python and Rust, allowing to easily generate client libraries for these languages, preserving similar interface and structure as in TypeScript.

**Python example:**

```sh npm2yarm
npx vovk generate --from py --out dist_py
```

```py
from my_module import UserRPC

body: UserRPC.UpdateUserBody = {
    'name': 'John Doe',
    'age': 30,
}

query: UserRPC.UpdateUserQuery = {
    'notify': 'push',
}

params: UserRPC.UpdateUserParams = {
    'id': '12345',
}

result = UserRPC.update_user(
  body,
  query,
  params,
)
```

**Rust example:**

```sh npm2yarm
npx vovk generate --from rs --out dist_rs
```

```rs
use my_module::user_rpc;

use user_rpc::update_user_::{ // _:: syntax accesses the types of a nested structure
  body as Body,
  query as Query,
  params as Params
};

let result = user_rpc::update_user(
    Body { name: String::from("John Doe"), age: 30 },
    Query { notify: String::from("push") },
    Params { id: String::from("12345") },
    None, // headers
    None, // custom API root
    false, // disable_client_validation
);

match result {
  Ok(response) => println!("user_rpc.update_user: {:?}", response),
  Err(e) => println!("update_user error: {:?}", e),
}
```

## AI utilities

Schema availability and code splitting into controllers and RPC modules makes it easy to implement LLM Function Calling and MCP server using existing AI ecosystem. `vovk` package exports `createLLMTools` that returns an array of tools with `name`, `description`, `parameters` and `execute` function that can be mapped to any LLM Function Calling format. It accepts a list of modules that are used to generate the tools, including RPC modules but also controllers, allowing to execute controller methods directly in the current context, without performing an HTTP request.

```ts
import { createLLMTools } from 'vovk';
import ProductController from '@/modules/product/ProductController';
import { UserRPC, GithubIssuesRPC } from 'vovk-client';
import { pick } from 'lodash';

const { tools } = createLLMTools({
  modules: {
    ProductController, // call ProductController methods at the current context
    UserRPC: pick(UserRPC, ['getUser', 'updateUser']), // only include specific methods
    GithubIssuesRPC: [
      GithubIssuesRPC,
      {
        // add OpenAPI mixin
        init: {
          headers: {
            Authorization: `Bearer ${process.env.GITHUB_TOKEN}`,
            'X-GitHub-Api-Version': '2022-11-28',
          },
        },
      },
    ],
  },
});

console.log(tools); // [{ name, description, parameters, execute }, ...]
```

## Build & shipment equipment

Vovk.ts CLI provides commands to build distributable packages. For example, to build a package for NPM, you can use `bundle` command that will bundle the client into a single package with [tsdown](https://tsdown.dev) behind the scenes.

```sh npm2yarm
npx vovk bundle --out dist
```

The command will bundle the RPC modules of all or specified segments into a single package in the `dist` directory, with `package.json` file and `README.md` that contains auto-generated documentation for the shipped RPC modules. Package name, description and version are taken either from the root `package.json` or can be configured at [vovk.config](/config). The only thing left is to publish the package to NPM or any other package registry.

```sh npm2yarm
npm publish dist
```

Similar approach can be used to build a package for Python or Rust, allowing to ship the back-end functionality to other languages and platforms.

```sh npm2yarm
npx vovk generate --from py --out dist_py
```

The command will generate a Python/mypy package in the `dist_py` directory with all RPC modules and OpenAPI schema files, ready to be published to PyPI.

For more information, take a look at ["Hello World" example](/hello-world).
