import { Steps, Tabs, Callout } from 'nextra/components';

# About

## Project mission

### Linking the conventional RESTful API with RPC-style calls

REST and RPC are commonly considered as two different approaches to building APIs. REST is based on the idea of resources and uses HTTP methods to perform CRUD operations on them, while RPC is based on the idea of remote procedure calls and uses a single endpoint to perform different actions. Frameworks like [tRPC](https://trpc.io/) solve the problem by adding a layer of abstraction on top of REST, allowing you to use RPC-style calls while still using RESTful principles. Unfortunately, this approach requires to use custom format for the requests and responses, which makes it hard to integrate with other HTTP clients and tools. Indeed, it makes sense: the traditional REST APIs can't be used with RPC-style calls. The client-side doesn't know what endpoint to call and what parameters to pass and the server-side needs to implement well-known endpoints such as `/api/trpc/user.updateUser` mutation endpoint instead of the format `/api/users/:id` with `PATCH` or `PUT` HTTP method that is used for decades becoming a standard way to use RESTful APIs de-facto. 

The only known way to link these two approaches is to make the back-end to emit a schema that describes the API and use it to generate a client-side library that can be used to make RPC-style calls. But there is the catch: while on the first glance it sounds like an attractive workaround, it forces the whole schema of the back-end to be exposed to the client-side code. In a classical case when there are multiple areas such as a customer's area and an admin's area, the customer's area should not be aware of the admin's area endpoints.

Vovk.ts solves this problem by adding an additional hierarchical level to the back-end called [segments](/segment) that splits back-end into smaller sections that emit back-end schema separately for each segment and introducing two ways to generate RPC code: **composed** where the RPC client library includes all segments and **segmented** where each segment has its own `.ts` file. See [here](/composed-and-segmented) for more details.

This approach also has a nice side effect: since each segment is a separate Next.js route, they compiled in separate serverless functions, making them to be separate "back-ends" that can have their own settings and features, such as OpenAPI specification, static export, etc. The static export in its turn also provides an RPC client library that does not differ from dynamic one, but requests static JSON files compiled in the build time.

The schema can be used to validate request data on the client-side before sending it to the server, validate forms, build structured outputs for LLMs, generate documentation (OpenAPI, README etc), build RPC libraries for other programming languages and more.

### Make client-side thinner

When the conventional RESTful API format is used, the developer needs to implement a client-side code that makes HTTP requests to the back-end. In strictly typed languages like TypeScript, Rust or Go, the developer needs to know the shape of the request and response objects in order to create type-safe code. This takes a lot of time and effort, especially when the API is large and complex. Let's say your RESTful API is implemented in TypeScript but there is requirement to use the API in Rust. There is what you would need to know in order to implement the client-side code:

- Endpoint
- HTTP method
- Input data:
  - Request body
  - Request parameters
  - Request query
- Output data

If the definitions are complex, this would take time that can be spent on something more useful. Besides that, these two separate codebases (client-side and server-side) need to be kept in sync and can lead to bugs and inconsistencies if back-end was changed but the client-side code was not updated. 

Vovk.ts introduces a universal way to generate RPC libraries for any strictly typed programming language that can be used to make HTTP requests and validate request input and output with JSON Schema - the most universal way to validate JSON data (this is optional). JSON Schema is a universal cross-platform data definition format that can be used to generate types, including nested structures. 

At this scenario, if back-end is changed (for example, `name` field is changed to `full_name`), all you need is to update the used library and check for compilation errors in your terminal or code editor.

That's not it. Vovk.ts emits corresponding package info file (package.json, Cargo.toml, pyproject.toml) extracting package name, description, version, authors etc from the **package.json** from the root of your project or from the [config file](/config) where the values can be configured for each language independently. It also emits **README.md** that uses package information (name, version, description, authors, etc) and the schema to build documentation with code examples. A distributable RPC library is built in one command (`npx vovk bundle [...flags]` for TypeScript and `npx vovk generate [...flags]`) for other languages and after that it can be published corresponding to the language ecosystem or used locally.

Another good news is that the schema is designed the way it it can be emitted by any framework and any language and then be used by Vovk.ts to generate RPC libraries for all supported languages (a standalone TypeScript RPC client would require a separate implementation). That's why I call it "cross-language", but not "multi-language" or similar.

By the time being the following languages are supported:

- [TypeScript](/typescript) - types are inferred from the back-end code
- [Python/mypy](/python) - types are generated from the schema
- [Rust](/rust) - types are generated from the schema

The list of languages is going to grow, being high priority for the project.

A demonstration is always better than a thousand words. The following example demonstrates an endpoint that updates user by ID. 

```ts
// TODO controller
```

```ts
// TODO seg
```

```ts
// TODO package.json
```


This is the only thing you need to define the endpoint, the rest is automatically generated.

- Schema.json
- TypeScript
- Readme
- Package.json
- Python
- Readme
- pyproject.toml
- Rust
- Readme
- Cargo.toml
- OpenAPI with Scalar

TODO Exemple goes here

#### JSON schema and type matching

As you can see at the example, the schema includes all the information required to generate a typed client-side library, such as:

- Endpoint and HTTP method
- RPC module name
- Handler name
- Input schemas
- Output schemas

That's all information needed to 

|                | Module       | Nested data          | Collections          | String     | Float            | Integer              | Boolean     | Null-ish |
|----------------|--------------|----------------------|----------------------|------------|------------------|----------------------|-------------|----------|
| **JSON Schema**| -            | "object"             | "array"              | "string"   | "number"         | "integer"            | "boolean"   | "null"   |
| **TypeScript** | export       | interface, object    | Array\<T\>, T[]      | string     | number           | number               | boolean     | null     |
| **Python**     | def          | class, dict          | List[T]              | str        | float            | int                  | bool        | None     |
| **Rust**       | pub&nbsp;mod | struct               | Vec\<T\>             | String     | f32, f64         | i8-i128, u8-u128     | bool        | None     |


## How it works

Even though it might look like something complicated, Vovk.ts uses the most primitive techniques to implement its features, avoid importing native Node.js modules that are not available in the Edge Runtime and make the whole development process as smooth as possible.

<Steps>
### `npm run dev`

Once Vovk.ts is [installed](/getting-started/quick-install), the first [segment](/segment) is created and the first [conteoller](/controller) is defined, the `npm run dev` command starts the Next.js dev server (`next dev`) and Vovk.ts dev CLI (`vovk dev`) concurrently.

### Ensuring the placeholder schema and placeholder client library are generated

Once `vovk dev` has been run, the first thing it does is it checks for the **route.ts** files, generates placeholder schema without definitions, ang generates a placeholder client to avoid compilation errors if one of the application modules imports the RPC client. If a file already exists, a placeholder isn't being generated. By default, the schema files are generated to **.vovk-schema** and composed client is generated to **node_modules/.vovk-client** that is re-exported from `vovk-client` package. These paths are [configurable](/config).

### Makes an initial request to the Next.js dev server to retrieve the schema

When `NODE_ENV` is set to `development`, Vovk.ts makes a request to each segment invoking the `_schema_` endpoint that serves the segment schema. Once each segment is requested and written to the **.vovk-schema** folder, it also generates the RPC client library that import the generated schema files.

### Watches for changes in the **modules** folder and the **route.ts** files

The Vovk.ts dev command watches for changes with [chokidar](https://www.npmjs.com/package/chokidar) in the **modules** folder and the **route.ts** segment files. When a change is detected, it extracts information about the changed segment or controller and makes a request to the `_schema_` endpoint of the segment that was changed, updates the schema file and generates the RPC client library. The RPC library is generated with [EJS](https://www.npmjs.com/package/ejs) code templates that are compiled in a few milliseconds.
</Steps>

In order to generate the schema and client once and stop the process, you can utilize `--exit` flag passed to the `vovk dev` command. This will make the process to exit once the schema and client are generated.

To generate the RPC client when schema already exists, you can use [generate](/cli/generate) command that should be run after node modules are reinstalled and before the `next build` command in CI/CD pipeline.

## Packages and repos

[Main repo](https://github.com/finom/vovk) packages:

- [vovk](https://www.npmjs.com/package/vovk) - the main library.
- [vovk-cli](https://www.npmjs.com/package/vovk-cli) - the [CLI](/cli).
- [vovk-init](https://www.npmjs.com/package/vovk-init) - shortcut for `vovk-cli init`.
- [vovk-client](https://www.npmjs.com/package/vovk-client) - re-exports generated RPC client.
- [vovk-dto](https://www.npmjs.com/package/vovk-dto) - [DTO](/validation/vovk-dto) validation.
- [vovk-yup](https://www.npmjs.com/package/vovk-yup) - [Yup](/validation/vovk-yup) validation.
- [vovk-zod](https://www.npmjs.com/package/vovk-zod) - [Zod](/validation/vovk-zod) validation.
- [vovk-validate-client-ajv](https://www.npmjs.com/package/vovk-validate-client-ajv) - client-side validation with Ajv that's used by [vovk-zod](/validation/vovk-zod) internally and can be reused with other validation libraries that generate JSON schemas for validation.

Other repos:

- [vovk-examples](https://github.com/finom/vovk-examples) - Vovk.ts examples that you can view [here](https://vovk-examples.vercel.app/). This website (vovk.dev) is powered by gh-pages and uses a [bundled NPM package](https://www.npmjs.com/package/vovk-examples) to create live examples at some pages of this documentation.
- [React Native example](https://github.com/finom/vovk-react-native-example) - example of using Vovk.ts with React Native with regular JSON requests but also with [streaming](/streaming) example.
- [Mapped types](https://www.npmjs.com/package/dto-mapped-types) - mapped types library forked from [@nestjs/mapped-types](https://www.npmjs.com/package/@nestjs/mapped-types) in order to make [vovk-dto](/validation/vovk-dto) classes created with [class-validator](https://www.npmjs.com/package/class-validator) to change their validation and type signatures.
- [vovk.dev](https://github.com/finom/vovk.dev) - [this website](https://vovk.dev). Feel free to submit a PR if you find a typo or want to improve the documentation. The author of Vovk.ts is not a native English speaker and will appreciate any help.

---------------

## Features

### RESTful

#### OpenAPI

#### JSON streaming

### Cross-language RPC

#### Client-side validation

#### TypeScript

#### Other languages


### Code templates

#### Pack and ship


### Multi-segment architecture

#### Edge runtime




---------

TODO folder structure

Vovk.ts is a back-end meta-framework for Next.js App Router that allows you to build RESTful APIs with auto-generated TypeScript RPC client. The framework based on standards and conventions that are widely used in the industry, making it easy to integrate with any HTTP client. The auto-emitted [schema](/schema) contains all the information about the API, including validation, represented as JSON schema.

## The syntax

The framework uses classes with static methods that are wrapped by decorators.

```ts
import { prefix, get } from 'vovk';

@prefix('users')
class UserController {
  @get()
  static getUsers() {
    return [];
  }
}
```

On the client-side the RPC library exports objects that have the same structure as the controllers.

```ts
import { UserRPC } from 'vovk-client';

await UserRPC.getUsers();
```

## Server-side validation and type-safety

The framework supports multiple validation libraries, including [Zod](/validation/vovk-zod), [Yup](/validation/vovk-yup), and [class-validator](/vovk-dto) that are used to validate the request body, query, parameters, output and iteration (for JSON streaming) in the server-side code. The libraries emit JSON schema (if not omitted) accessible by the client-side code.

```ts
import { z } from 'zod';
import { prefix, post } from 'vovk';
import { withZod } from 'vovk-zod';

@prefix('users')
class UserController {
  @post(':id')
  static updateUser = withZod({
    body: z
      .object({
        name: z.string(),
        age: z.number().min(0),
      })
      .describe('User object'),
    params: z.object({
      id: z.string().describe('User ID'),
    }),
    query: z.object({
      notify: z.enum(['email', 'push', 'none']),
    }),
    output: z.object({
      success: z.boolean(),
    }),
    async handle(req, { id }) {
      const { name, age } = await req.json(); // name is a string, age is a number
      const { notify } = req.nextUrl.searchParams.get('notify'); // notify is a string

      // do something with the data
      return {
        success: true,
      };
    },
  });
}
```

## Client-side validation and type-safety

The RPC library uses the schema to provide endpoint information and perform client-side [validtion](/validation) with the help of [Ajv](https://www.npmjs.com/package/ajv).

```ts {6-7}
import { UserRPC } from 'vovk-client';

// validates the request input with Ajv before sending it to /api/users/123?notify=EMAIL using POST method
await UserRPC.updateUser({
  body: {
    nane: 'John Doe',
    // ^ Object literal may only specify known properties, and 'nane' does not exist in type '{ name: string; age: number; }'.
    age: 30,
  },
  params: {
    id: '123',
  },
  query: {
    notify: 'EMAIL',
  },
});
```

Since the validation schema is available at the client-side, you can access it to validate forms with no effort.

```tsx {15-17}
'use client';
import { UserRPC } from 'vovk-client';
import type { VovkBody } from 'vovk';
import { useForm } from 'react-hook-form';
import { ajvResolver } from '@hookform/resolvers/ajv';
import { fastFormats } from 'ajv-formats/dist/formats';

export default function ZodHookFormExample() {
  const {
    register,
    handleSubmit,
    getValues,
    formState: { errors },
  } = useForm<VovkBody<typeof UserRPC.createUser>>({
    resolver: ajvResolver(UserRPC.createUser.schema.validation.body, {
      formats: fastFormats,
    }),
  });

  const onSubmit = async () => {
    await UserRPC.createUser({
      body: getValues(),
    });
  };

  return (
    <form onSubmit={handleSubmit(onSubmit)}>
      <input type="text" placeholder="Name" {...register('name')} />
      {errors.name && <p>❌ {errors.name.message}</p>}
      <input type="text" placeholder="Email" {...register('email')} />
      {errors.email && <p>❌ {errors.email.message}</p>}
      <button>Submit</button>
    </form>
  );
}
```

## OpenAPI

The emitted schema contains all the information that's needed to generate beautiful OpenAPI 3.1 documentation.

```ts
import { z } from 'zod';
import { prefix, post } from 'vovk';
import { withZod } from 'vovk-zod';
import { openapi } from 'vovk-openapi';

@prefix('users')
class UserController {
  @openapi({
    summary: 'Update user',
    description: 'Update user by ID',
  })
  @post(':id')
  static updateUser = withZod({
    body: z
      .object({
        name: z.string().describe('User name'),
        age: z.number().min(0).describe('User age'),
      })
      .describe('User object'),
    params: z.object({
      id: z.string().describe('User ID'),
    }),
    query: z.object({
      notify: z.enum(['email', 'push', 'none']).describe('Notification type'),
    }),
    output: z
      .object({
        success: z.boolean().describe('Success status'),
      })
      .describe('Response object'),
    async handle(req, { id }) {
      const { name, age } = await req.json();
      const { notify } = req.nextUrl.searchParams.get('notify');

      // do something with the data
      return {
        success: true,
      };
    },
  });
}
```

TODO Screenshot

## Simple implementation

Vovk.ts uses simple tachniques to implement its features. The schema is requested from Next.js dev server at `_schema_` endpoint of a segment. The client is generated with [EJS](https://www.npmjs.com/package/ejs) templates making it easy to implement a custom template and compile them in a few milliseconds.

On back-end

```ts
export function GET(req: NextRequest) {
  return handle(req);
}

export function POST(req: NextRequest) {
  return handle(req);
}

export function PATCH(req: NextRequest) {
  return handle(req);
}
```

On front-end

```ts
const user = fetch(`/api/users/${id}?notify=EMAIL`, {
  method: 'PATCH',
  body: JSON.stringify(body),
});
```

## Customizable RPC client

## Publish your RPC client on NPM

## Cross-language RPC

Simple and conventional design of Vovk.ts made possible to generate type-safe RPC clients with client-side validation for other programming languages that require a couple of well-known libraries for HTTP requests and JSON schema validation. The first implementation is made for [Python](/python) and more languages are coming soon.

```py
from vovk_client import UserRPC

body: UserRPC.infer_update_user_body = {
    'name': 'John Doe',
    'age': 30,
}

params: UserRPC.infer_update_user_params = {
    'id': '123',
}

query: UserRPC.infer_update_user_query = {
    'notify': 'EMAIL',
}

result: UserRPC.infer_update_user_output = UserRPC.update_user(
    body=body,
    params=params,
    query=query,
)
```

## Edge runtime

The framework is 100% compatible with Next.js edge runtime.

```ts
// define the runtime for the segment
export const runtime = 'edge';
```

## CLI

## JSON streaming

## Multi-segment

## Code generator

## Features

TODO

- Bridges two contrasting paradigms: REST and RPC, seamlessly combining their strengths.
- Prioritizes an exceptional developer experience.
- Adopts the highly effective **Controller-Service-Repository** pattern, ideal for building robust back-end architectures.
- Fully compatible with standard Next.js APIs, including `Response`, `headers`, `redirect`, and more.
- Lightweight with minimal overhead for optimized performance.
- Built for speed.
- Thoroughly tested for reliability and scalability.


