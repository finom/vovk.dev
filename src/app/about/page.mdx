# About

**Vovk.ts** is a RESTful API framework that seamlessly integrates with Next.js, enabling you to build scalable APIs without the complexity of monorepos or separate deployments.

Born from the challenge of scaling beyond Next.js's `route.ts` files, Vovk.ts solves the problem of managing dozens or hundreds of endpoints while maintaining full RESTful compatibility for third-party integrations—something RPC-only solutions can't provide.

**Key features:**

- Authentic RESTful APIs with an RPC-like developer experience
- Client-side validation with TypeScript inference
- First-class OpenAPI support
- Single deployment for frontend and backend
- Built on standards and battle-tested conventions

After two years of development and hundreds of iterations, Vovk.ts&nbsp;3+ delivers a framework that respects existing standards while providing modern developer ergonomics.

This documentation is divided into guides explaining how to use the framework within the existing TypeScript ecosystem (sometimes barely touching Vovk.ts features), and reference documentation detailing the API and features.

[Report issues or contribute on GitHub](https://github.com/finom/vovk)

{/*

I couldn't find a way to build a back-end for Next.js with NestJS-like syntax that elegantly combines RESTful API and RPC capabilities. After searching extensively, I discovered there wasn't a project implementing both the conventional REST with RPC in any language that could serve as a reference, making Vovk.ts likely the first of its kind. Next.js as a full-stack framework often forces developers to either navigate through complex `route.ts` implementations or use tools with hidden RPC implementations.

---

Vovk.ts emits a committable schema and generates a TypeScript library because implementing both RESTful API and RPC in a single framework required this compromise. However, this approach has led to some remarkable side-effects, enabling unique features such as:

- Client-side validation that validates request inputs and outputs using JSON Schema before sending requests to the server.
- Function Calling that enables API endpoint interaction with LLMs, both on client-side and server-side. Client-side calls are particularly valuable when implementing [Realtime conversations](https://platform.openai.com/docs/guides/realtime-conversations) through WebRTC protocol.
- Validation schema accessibility on the client-side for form validation or other purposes. For example, the schema for `UserController.updateUser` is available as `UserRPC.updateUser.schema.validation`.

Vovk.ts also implements other features common to modern back-end frameworks:

- OpenAPI documentation generation
- Code generation for TypeScript, Python, and Rust
- Multitenancy support via the [multitenant](/guides/multitenant) function applied in Next.js `middleware.ts`
- JSON streaming support using [JSON Lines](https://jsonlines.org/)
- Developer-friendly CLI

Plus many smaller but useful features you'll discover throughout the documentation.

Vovk.ts is designed to maximize the use of standards and conventions while providing a developer-friendly experience. Drawing on nearly 20 years of programming experience, I've created this framework to be both useful and enjoyable to work with.

This documentation is divided into guides explaining how to use the framework within the existing ecosystem, and reference documentation detailing the API and features.

---

OLD:

### Schema

`npm run dev` script runs `next dev` and `vovk dev` commands concurrently. The second one watches for changes in the **modules** folder and the **route.ts** files, makes request to Next.js dev server endpoint `_schema_` that is available when `NODE_ENV` is `development`, generates schema files in the **.vovk-schema** (a `.json` file is generated individually for each segment) folder and by default generates RPC client library in the **node_modules/.vovk-client** folder that is re-exported from `vovk-client` package.

An individual schema file called "segment schema" contains information about the segment path, RPC module names, their handlers and input/output schemas: for the root segment it is `.vovk-schema/root.json`, for the customer segment it is `.vovk-schema/customer.json`, for the nested segment `foo/bar/baz` it is `.vovk-schema/foo/bar/baz.json`.

## How it works

Even though it might look like something complicated, Vovk.ts uses the most primitive techniques to implement its features, avoid importing native Node.js modules that are not available in the Edge Runtime and make the whole development process as smooth as possible.

<Steps>
### `npm run dev`

Once Vovk.ts is [installed](/getting-started/quick-install), the first [segment](/segment) is created and the first [conteoller](/controller) is defined, the `npm run dev` command starts the Next.js dev server (`next dev`) and Vovk.ts dev CLI (`vovk dev`) concurrently.

### Ensuring the placeholder schema and placeholder client library are generated

Once `vovk dev` has been run, the first thing it does is it checks for the **route.ts** files, generates placeholder schema without definitions, ang generates a placeholder client to avoid compilation errors if one of the application modules imports the RPC client. If a file already exists, a placeholder isn't being generated. By default, the schema files are generated to **.vovk-schema** and composed client is generated to **node_modules/.vovk-client** that is re-exported from `vovk-client` package. These paths are [configurable](/config).

### Makes an initial request to the Next.js dev server to retrieve the schema

When `NODE_ENV` is set to `development`, Vovk.ts makes a request to each segment invoking the `_schema_` endpoint that serves the segment schema. Once each segment is requested and written to the **.vovk-schema** folder, it also generates the RPC client library that import the generated schema files.

### Watches for changes in the **modules** folder and the **route.ts** files

The Vovk.ts dev command watches for changes with [chokidar](https://www.npmjs.com/package/chokidar) in the **modules** folder and the **route.ts** segment files. When a change is detected, it extracts information about the changed segment or controller and makes a request to the `_schema_` endpoint of the segment that was changed, updates the schema file and generates the RPC client library. The RPC library is generated with [EJS](https://www.npmjs.com/package/ejs) code templates that are compiled in a few milliseconds.

</Steps>

In order to generate the schema and client once and stop the process, you can utilize `--exit` flag passed to the `vovk dev` command. This will make the process to exit once the schema and client are generated.

To generate the RPC client when schema already exists, you can use [generate](/cli/generate) command that should be run after node modules are reinstalled and before the `next build` command in CI/CD pipeline.

---

Since the validation schema is available at the client-side, you can access it to validate forms with no effort.

```tsx {15-17}
'use client';
import { UserRPC } from 'vovk-client';
import type { VovkBody } from 'vovk';
import { useForm } from 'react-hook-form';
import { ajvResolver } from '@hookform/resolvers/ajv';
import { fastFormats } from 'ajv-formats/dist/formats';

export default function ZodHookFormExample() {
  const {
    register,
    handleSubmit,
    getValues,
    formState: { errors },
  } = useForm<VovkBody<typeof UserRPC.createUser>>({
    resolver: ajvResolver(UserRPC.createUser.schema.validation.body, {
      formats: fastFormats,
    }),
  });

  const onSubmit = async () => {
    await UserRPC.createUser({
      body: getValues(),
    });
  };

  return (
    <form onSubmit={handleSubmit(onSubmit)}>
      <input type="text" placeholder="Name" {...register('name')} />
      {errors.name && <p>❌ {errors.name.message}</p>}
      <input type="text" placeholder="Email" {...register('email')} />
      {errors.email && <p>❌ {errors.email.message}</p>}
      <button>Submit</button>
    </form>
  );
}
```

## OpenAPI

The emitted schema contains all the information that's needed to generate beautiful OpenAPI 3.1 documentation.

```ts
import { z } from 'zod';
import { prefix, post } from 'vovk';
import { withZod } from 'vovk-zod';
import { openapi } from 'vovk-openapi';

@prefix('users')
class UserController {
  @openapi({
    summary: 'Update user',
    description: 'Update user by ID',
  })
  @post('{id}')
  static updateUser = withZod({
    body: z
      .object({
        name: z.string().describe('User name'),
        age: z.number().min(0).describe('User age'),
      })
      .describe('User object'),
    params: z.object({
      id: z.string().describe('User ID'),
    }),
    query: z.object({
      notify: z.enum(['email', 'push', 'none']).describe('Notification type'),
    }),
    output: z
      .object({
        success: z.boolean().describe('Success status'),
      })
      .describe('Response object'),
    async handle(req, { id }) {
      const { name, age } = await req.json();
      const { notify } = req.nextUrl.searchParams.get('notify');

      // do something with the data
      return {
        success: true,
      };
    },
  });
}
```

TODO Screenshot

## Simple implementation

Vovk.ts uses simple techniques to implement its features. The schema is requested from the Next.js dev server at the `_schema_` endpoint of a segment. The client is generated with [EJS](https://www.npmjs.com/package/ejs) templates, making it easy to implement custom templates and compile them in milliseconds.

On back-end:

```ts
export function GET(req: NextRequest) {
  return handle(req);
}

export function POST(req: NextRequest) {
  return handle(req);
}

export function PATCH(req: NextRequest) {
  return handle(req);
}
```

On front-end:

```ts
const user = fetch(`/api/users/${id}?notify=EMAIL`, {
  method: 'PATCH',
  body: JSON.stringify(body),
});
```

\*/}
