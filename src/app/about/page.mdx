import { FileTree, Tabs } from 'nextra/components';
import Image from 'next/image';

# About

This conceptual back-end meta-framework is designed and developed by [Andrey Gubanov](https://github.com/finom). Built for efficiency and unprecedented DX.

**Features:**

- RESTful APIs + RPC.
- Client-side validation and TypeScript inference.
- First-class OpenAPI support.
- Single point deployment for frontend and backend, as it's a normal Next.js app.
- Function calling framework that turns your back-end into an AI agent.
- Built on standards and conventions.

## Node.js/Next.js back-end framework

The project was heavily inspired by [NestJS](https://nestjs.com/) that's built on top of [Express](https://expressjs.com/) a lower-level Node.js framework, extending it with modular architecture for large back-end apps. Vovk.ts achieves similar goal using [Next.js Route Handlers](https://nextjs.org/docs/app/getting-started/route-handlers-and-middleware) as a lower-level HTTP framework, but installed on top of a new or existing Next.js project as a set of secondary dependencies.

**More info**
- [Next.js Route Handlers](https://nextjs.org/docs/app/getting-started/route-handlers-and-middleware)

## "Segment"

Vovk.ts introduces another hierarchical level to back-end called [segments](/segment/introduction) that allows to split the back-end into smaller parts configured differently, that emit RPC schema separately for each segment. Traditional hierarchy that looks like `back-end -> controller -> handler` gets extended to `back-end -> segment -> controller -> handler`. Each segment is a separate Next.js route that can be configured independently and compiled into a separate serverless function on build, creating multiple smaller "back-ends".


<Image src="/draw/segment-concept.svg" alt="Segment" width={1874.4446105957031} height={745.1328125} className="mt-4 dark:invert" />

A segment can be turned into a [static segment](/segment/static) that makes its endpoints to be compiled into static JSON files during the build time, allowing to use them for historical data, OpenAPI documentation, or any other data that is generated on build time.

**More info**
- [Segment docs](/segment/introduction)

## RESTful JSON API + RPC

Vovk.ts is a RESTful API back-end framework that implements well-known and widely used patterns. It can be used as a regular back-end framework to build endpoints that follow the market-wide RESTful API conventions, such as:

- Naming conventions for URLs and endpoints: `/users`, `/products/{id}`
- Query parameters for filtering and pagination: `?page=1&limit=10`
- HTTP methods explicitly defined by a developer: `GET`, `POST`, `PUT`, `DELETE` etc.
- Status codes returned by the server: `200 OK`, `404 Not Found`, etc.
  and so on.

On the client side, the back-end endpoints can be invoked using the `fetch` API or any other HTTP client:

```ts
// Update user with ID 12345
const resp = await fetch('/api/users/12345?notify=push', {
  method: 'PUT',
  body: JSON.stringify({ name: 'John Doe' }),
  headers: {
    'Content-Type': 'application/json',
  },
});

const result = (await resp.json()) as UserType; // some user type
```

For the RESTful API requests, Vovk.ts also implements [RPC](https://e2n.wikipedia.org/wiki/Remote_procedure_call) (Remote Procedure Call) paradigm that allows to call back-end functions as if they were local, making a normal `fetch` request under the hood.

```ts
import { UserRPC } from 'vovk-client';

const result = await UserRPC.updateUser({
  params: { id: '12345' },
  body: { name: 'John Doe' },
  query: { notify: 'push' },
});

result satisfies UserType;
```

These two concepts are usually oppose each other, but in Vovk.ts they are combined, making RESTful API client thinner and moving away from the idea of hidden implementation of RPC calls.

This idea is achieved by combining code generation with TypeScript inference, mapping each RPC call onto a specially constructed URL.

**How it Works?**

1. **Request Encoding**. The client encodes the target method name and its arguments into a URL.  
   `/api/users/12345?notify=push` translates to a call to the `updateUser` method of the `UserRPC` module with `id` parameter set to `12345` and `notify` query parameter set to `push`.
2. **URL Dispatching**. When the server receives this URL, its routing logic parses the path to identify the correct controller and method handler.
3. **Invocation**. The handler is invoked with the parsed parameters, executes the business logic, and returns the result.

**More info**

- [TypeScript RPC](/typescript)

## Controller and Service

HTTP handlers are implemented as decorated static class methods, that expect two arguments: `req: NextRequest` (enhanced with typed `req.json`, `req.nextUrl` etc using `VovkRequest<TBody, TQuery, TParams>` type) and `params: TParams`. The class (often called "static class" at this documentation) is initailized (but not instantiated with `new{:js}`) at `route.ts` file, declaring a new RPC module, described below.

A controller can be decomposed into the controller itself and one or more services that contain busines logic (DB/API calls). Service methods can safely infer controller method types, even if the controller method returns the reults of the service method, without triggering "explicit any" error on self-references, thanks to a fix [#58616](https://github.com/microsoft/TypeScript/issues/58616) to TypeScript, made by [Anders Hejlsberg](https://github.com/ahejlsberg).

<Tabs items={['Controller', 'Service', 'Segment route']}>
<Tabs.Tab>
```ts filename="src/modules/user/UserController.ts"
import { put, prefix } from 'vovk';
import UserService from './UserService';

@prefix('users')
export default class UserController {
  @put('{id}')
  static async updateUser(req: VovkRequest<{ name: string }, { notify: string }>, { id }: { id: string }) {
    return UserService.updateUser(await req.json(), req.nextUrl.searchParams.get('notify'), id);
  }
}
```
</Tabs.Tab>
<Tabs.Tab>
```ts filename="src/modules/user/UserService.ts"
import type { VovkBody, VovkQuery, VovkParams, VovkOutput } from 'vovk';
import type UserController from './UserController';

export default class UserService {
  static async updateUser(
    body: VovkBody<typeof UserController.updateUser>,
    notify: VovkQuery<typeof UserController.updateUser>['notify'],
    id: VovkParams<typeof UserController.updateUser>['id'],
  ) {
    // handle the request
    console.log({ body, notify, id }); // { body: { name: 'John Doe' }, notify: 'push', id: '12345' }
    return { body, notify, id, success: true } satisfies VovkOutput<typeof UserController.updateUser>;
  }
}
```
</Tabs.Tab>
<Tabs.Tab>
```ts filename="src/app/api/[[...vovk]]/route.ts"
import { initSegment } from 'vovk';
import UserController from '@/modules/user/UserController';

const controllers = {
  UserRPC: UserController,
};

export type Controllers = typeof controllers; // used for type safety at RPC client

export const { GET, POST, PUT, DELETE } = initSegment({
  controllers,
});
```
</Tabs.Tab>
</Tabs>

> [!IMPORTANT]
>
> This feature should use an additional check of return type, or manual type annotation, as `handle` function isn't related to its output type, allowing to return `any`. Use `x satisfies VovkOutput<typeof f>{:ts}` or annotate the return type manually. This is not required for proper type inference, but might be useful when handler requires strict type checking.

**More info**

- [Controller docs](/controller/introduction)
- [Service docs](/controller/service)
- [Type inference](/inference)

## "RPC Module"

A controller is initalized at `route.ts`, will be rendered as an RPC module that has the same list of methods with mapped signatures. The controller method accepts a request, and the RPC method accepts input + some other stuff.

Server-side controllers are implemented as classes with static methods only (called "static classes" in this documentation) that are initialized at the segment `route.ts` file with `initSegment` function. The `controllers` option of the `initSegment` defines names of the resulting **RPC modules**, that have similar shape with different arguments signatures.

Turned into an RPC module:

```ts
import { UserRPC } from 'vovk-client';

const result = await UserRPC.updateUser({
  params: { id: '12345' },
  body: { name: 'John Doe' },
  query: { notify: 'push' },
});

result satisfies { success: boolean };
```

Unlike traditional RPC frameworks, **Vovk.ts RPC modules have 3 inputs instead of 1**, allowing to pass URL parameters, query parameters, and request body separately.

When a controller method is implemented with a [validation library](/validation), the incoming HTTP request input is validated automatically on the server side, and if it's invoked from an RPC module, the **data is validated on the client side** as well using the JSON schema generated from the validation library. This allows to catch errors early on the client side, before the request is sent to the server.

**More info**

- [TypeScript RPC](/typescript)

## Schema

Each segment emits back-end schema into an individual JSON file that is used to generate client-side RPC modules. If you have different areas of your application (e.g. root, admin, customer), each area will have its own JSON schema file located at a configurable dir `.vovk-schema/`. For a segment structure like this:

<FileTree>
  <FileTree.Folder name="src/app/api" defaultOpen>
    <FileTree.Folder name="[[...vovk]]" defaultOpen>
      <FileTree.File
        name={
          <span>
            route.ts{' '}
            <span className="text-gray-500">
              (root segment <code>/api/</code>)
            </span>
          </span>
        }
      />
    </FileTree.Folder>
    <FileTree.Folder name="admin/[[...vovk]]" defaultOpen>
      <FileTree.File
        name={
          <span>
            route.ts{' '}
            <span className="text-gray-500">
              (admin segment <code>/api/admin</code>)
            </span>
          </span>
        }
      />
    </FileTree.Folder>
    <FileTree.Folder name="customer/[[...vovk]]" defaultOpen>
      <FileTree.File
        name={
          <span>
            route.ts{' '}
            <span className="text-gray-500">
              (customer segment <code>/api/customer</code>)
            </span>
          </span>
        }
      />
      <FileTree.Folder name="static/[[...vovk]]" defaultOpen>
        <FileTree.File
          name={
            <span>
              route.ts{' '}
              <span className="text-gray-500">
                (static segment <code>/api/customer/static</code> for OpenAPI)
              </span>
            </span>
          }
        />
      </FileTree.Folder>
    </FileTree.Folder>
  </FileTree.Folder>
</FileTree>

the resulting schema files will be located in `.vovk-schema/` directory like this:

<FileTree>
  <FileTree.Folder name=".vovk-schema" defaultOpen>
    <FileTree.File name="root.json" />
    <FileTree.File name="admin.json" />
    <FileTree.File name="customer.json" />
    <FileTree.Folder name="customer" defaultOpen>
      <FileTree.File name="static.json" />
    </FileTree.Folder>
    <FileTree.File name="_meta.json" />
  </FileTree.Folder>
</FileTree>

Each individual schema file represents a segment and contains and contains all RPC modules defined in that segment. It follows the same recursive structure as the segments, where `root.json` is a special name for the root segment with name `""`. `_meta.json` file contains additional metadata, such as explicitly emitted fields of the [vovk.config](/config) file.

**More info**
- [Schema docs](/schema)

## "Composed" vs "segmented" RPC clients

By default Vovk.ts emits a single RPC client that contains all RPC modules from all segments. This approach is called **"composed RPC client"** and it's useful for single-page applications where you want to have a single entry point for all RPC modules.

However, in larger applications, exposing schema for all segments in a single RPC client isn't always desirable. In this case, with a simple configuration change, you can instruct Vovk.ts to generate separate RPC clients for each segment.

<FileTree>
  <FileTree.Folder name="app/client" defaultOpen>
    <FileTree.Folder name="root" defaultOpen>
      <FileTree.File
        name={
          <span>
            index.ts{' '}
            <span className="text-gray-500">
              (imports <code>./schema.ts</code>)
            </span>
          </span>
        }
      />
      <FileTree.File
        name={
          <span>
            schema.ts{' '}
            <span className="text-gray-500">
              (imports <code>.vovk-schema/root.json)</code>
            </span>
          </span>
        }
      />
    </FileTree.Folder>
    <FileTree.Folder name="admin" defaultOpen>
      <FileTree.File
        name={
          <span>
            index.ts{' '}
            <span className="text-gray-500">
              (imports <code>./schema.ts</code>)
            </span>
          </span>
        }
      />
      <FileTree.File
        name={
          <span>
            schema.ts{' '}
            <span className="text-gray-500">
              (imports <code>.vovk-schema/admin.json)</code>
            </span>
          </span>
        }
      />
    </FileTree.Folder>
    <FileTree.Folder name="customer" defaultOpen>
      <FileTree.File
        name={
          <span>
            index.ts{' '}
            <span className="text-gray-500">
              (imports <code>./schema.ts</code>)
            </span>
          </span>
        }
      />
      <FileTree.File
        name={
          <span>
            schema.ts{' '}
            <span className="text-gray-500">
              (imports <code>.vovk-schema/customer.json</code>)
            </span>
          </span>
        }
      />
      <FileTree.Folder name="static" defaultOpen>
        <FileTree.File
          name={
            <span>
              index.ts{' '}
              <span className="text-gray-500">
                (imports <code>./schema.ts</code>)
              </span>
            </span>
          }
        />
        <FileTree.File
          name={
            <span>
              schema.ts{' '}
              <span className="text-gray-500">
                (imports <code>.vovk-schema/customer/static.json</code>)
              </span>
            </span>
          }
        />
      </FileTree.Folder>
    </FileTree.Folder>
  </FileTree.Folder>
</FileTree>

This approach is called **"segmented RPC client"** and it allows to split the client into smaller TypeScript files that can be imported separately, hiding RPC modules and corresponding schema on specific pages. For example, pages responsible for "customer" functionality isn't going to import "admin" RPC modules, therefore "admin" implementation details are hidden from the customer pages.

**More info**
- [Composed client](/composed)
- [Segmented client](/segmented)

## Validation

Vovk.ts supports any validation library that implements [Standard Schema](https://github.com/standard-schema/standard-schema/), including [Zod 4](https://github.com/colinhacks/zod), [Valibot](https://github.com/fabian-hiller/valibot), [Arktype](https://github.com/arktypeio/arktype), but also [Zod 3](https://github.com/colinhacks/zod), [class-validator](https://github.com/typestack/class-validator) and can be extended with any other TypeScript validation library. The only requirement is that the library should be able to generate JSON schema from the validation rules in order to validate the data on the client side, build typed client, generate OpenAPI documentation, etc. The primary validation library that is used in the documentation is Zod 4 but it's up to you to choose the one that fits your needs.

Methods that need to be validated are implemented with `with[LIBRARY]` function that accepts validation models and `handle` function that receives the request and the parameters. The types of the request and parameters are inferred from the validation models, allowing to use them in the `handle` function without any additional type annotations.

```ts
import { z } from 'zod';
import { prefix, post, operation, type VovkOutput } from 'vovk';
import { withZod } from 'vovk-zod';

@prefix('users')
export default class UserController {
  @operation({
    summary: 'Update user (Zod)',
    description: 'Update user by ID with Zod validation',
  })
  @post('{id}')
  static updateUser = withZod({
    body: z
      .object({
        name: z.string().describe('User full name'),
        age: z.number().min(0).max(120).describe('User age'),
        email: z.email().describe('User email'),
      })
      .describe('User object'),
    params: z.object({
      id: z.uuid().describe('User ID'),
    }),
    query: z.object({
      notify: z.enum(['email', 'push', 'none']).describe('Notification type'),
    }),
    output: z
      .object({
        success: z.boolean().describe('Success status'),
      })
      .describe('Response object'),
    async handle(req, { id }) {
      const { name, age } = await req.json();
      const notify = req.nextUrl.searchParams.get('notify');

      // do something with the data
      console.log(`Updating user ${id}:`, { name, age, notify });
      return {
        success: true,
      } satisfies VovkOutput<typeof UserZodController.updateUser>;
    },
  });
}
```

Thanks to the JSON schema emission and access to the back-end data that was never available to a developer before, a controller method that uses validation is being a source of truth for many things:

- Type inference:
  - Server-side, to enhance built-in functionality fo `NextRequest` object and provide types for `req.json()` etc.
  - Client-side, to build typed RPC modules with expected inputs.
- [Validation](/validation):
  - Server-side, to validate incoming requests with Zod, Arktype and other libraries and return an error if the data is invalid.
  - Client-side, to validate data with Ajv before sending the request and throw an error if the data is invalid in the client.
- Code generation for [TypeScript](/typescript), [Rust](/rust), [Python](/python), from the back-end schema.
- [OpenAPI](/openapi) object, exported as `openapi` variable.
- Copy-pastable code snippets for READMEs and OpenAPI documentation.
- [Function Calling](/function-calling):
  - Server-side to execute the function at the current evaluation context.
  - Client-side to call the function using HTTP protocol.
- And more, as developer now has access to the back-end schema to generate more ideas.

## JSON Lines

Vovk.ts includes first class support for [JSON Lines](https://jsonlines.org/) format, which is a convenient way to implement "one request - many responses". It's perfect for LLM completions, but also opens up a new field for experiments, such as [progressive responses](/controller/progressive) and [polling](/polling). JSONLines is another kind of output that uses `iteration` validation field and produces `application/jsonl` content-type if client-side includes `Accept: application/jsonl` header. If the `Accepts` header doesn't include `application/jsonl`, the output is returned as `text/plain` to be available when the endpoint URL is opened directly in the browser.

```ts
import { z } from 'zod';
import { prefix, post, type VovkIteration } from 'vovk';
import { withZod } from 'vovk-zod';

@prefix('stream')
export default class StreamController {
  @post('completions')
  static getJSONLines = withZod({
    // ...
    iteration: z.object({
      message: z.string(),
    }),
    async handle() {
      const tokens: VovkIteration<typeof StreamController.getJSONLines>[] = [
        { message: 'Hello,' },
        { message: ' World' },
        { message: ' from' },
        { message: ' Stream' },
        { message: '!' },
      ];

      for (const token of tokens) {
        await new Promise((resolve) => setTimeout(resolve, 300));
        yield token;
      }
    },
  });
}
```

On the client side, the JSONLines output can be consumed using disposable async iterators, allowing to process each line as it arrives:

```ts
import { StreamRPC } from 'vovk-client';

using stream = await StreamRPC.getJSONLines();

for await (const { message } of stream) {
  console.log('Received message:', message);
}
```

**More info**
- [JSON Lines docs](/controller/jsonlines)
- [LLM completions](/llm)

## Custom responses

Vovk.ts is a wrapper around Next.js API routes, so the handlers can return any instance of `Response` class, including `NextResponse` or `NextResponse.json()`, allowing to use all available Next.js features and create [proxies](/proxy).

```ts
import { NextResponse, headers } from 'next/server';
import { prefix, get } from 'vovk';

@prefix('users')
export default class UsersController {
  @get('{id}')
  static async getUser() {
    console.log('Headers:', await headers());
    return NextResponse.json({ name: 'John Doe' });
  }
}
```

**More info**
- [Controller docs](/controller)
- [Proxy endpoints](/proxy)

## `FormData`

Vovk.ts distinguishes JSON and `FormData` bodies with `isForm` flag passed as validation option. This option does two things: it changes the resulting type signature of the input `body` to `FormData` instance, and also adds `x-isForm` custom property to the body schema, to be able to distinguish it from regular JSON requests and validate it on the client side.

```ts {8}
export default class UserController {
  @post('create')
  static createUser = withZod({
    body: z.object({
      name: z.string(),
      age: z.number(),
    }),
    isForm: true, // this will change the body type to FormData
    async handle(req) {
      const formData = await req.formData();
      // ...
    },
  });
}
```

On the client-side the `createUser` RPC method will accept `FormData` instance as a body:

```ts {8}
import { UserRPC } from 'vovk-client';

const formData = new FormData();
formData.append('name', 'John Doe');
formData.append('age', '30');

const response = await UserRPC.createUser({
  body: formData,
});
```

**More info**
- [FormData docs](/controller/formdata)


## AI utilities

> Function calling is a powerful capability that enables Large Language Models (LLMs) to interact with your code and external systems in a structured way. Instead of just generating text responses, LLMs can understand when to call specific functions and provide the necessary parameters to execute real-world actions ([Hugging Face](https://huggingface.co/docs/hugs/en/guides/function-calling)).

Function calling is a simple but powerful capability that's well known for multiple years already. But it still considered a feature usually utilized by large tech companies or startups with strong AI focus. Libraries like AI SDK simplify the process of integrating LLMs and function calling into applications, solving the problem on **how to call** a function. Vovk.ts solves the problem of **what to call** by providing a framework to build back-end functions that are easily converted into LLM tools with `name`, `description`, `parameters` and `execute` function that can be mapped to any LLM Function Calling format.

The functions can be called either on the server side (by using a [controller](/controller)) or on the client side (by using an RPC module that calls the functions over HTTP), including calling remote APIs with [OpenAPI mixins](/codegen).

```ts
import { createLLMTools } from 'vovk';
import ProductController from '@/modules/product/ProductController';
import { UserRPC, GithubIssuesRPC } from 'vovk-client';
import { pick } from 'lodash';

const { tools } = createLLMTools({
  modules: {
    ProductController, // call ProductController methods at the current context
    UserRPC: pick(UserRPC, ['getUser', 'updateUser']), // only include specific methods of UserRPC
    GithubIssuesRPC: [ // add OpenAPI mixin
      GithubIssuesRPC,
      {
        init: {
          headers: {
            Authorization: `Bearer ${process.env.GITHUB_TOKEN}`,
            'X-GitHub-Api-Version': '2022-11-28',
          },
        },
      },
    ],
  },
});

console.log(tools); // [{ name, description, parameters, execute }, ...]
```

**More info**
- [AI tools](/function-calling)
- [Real-time UI](/realtime-ui)
- [Polling](/polling)
- [MCP server](/mcp)

## First class OpenAPI support

Vovk.ts generates OpenAPI 3.1 documentation from the back-end schema, without invoking any additional tools or libraries. Once you have defined your controllers with validation, and invoked `@operation` decorator to add `summary` and `description`, the OpenAPI doc is generated automatically on build, and can be accessed as `openapi` variable.

```ts
import { UserRPC, openapi } from 'vovk-client';

console.log(openapi);
```

The OpenAPI doc feature includes first class support for [Scalar](https://github.com/scalar/scalar), generating copy-pastable code snippets that include documentation to the input and output data represented in comments. Here is an example of a snippet generated automatically for the ["Hello World" example](/hello-world) that you can also view [here](https://vovk-hello-world.vercel.app/openapi):

```ts
import { UserRPC } from 'vovk-client';

const response = await UserRPC.updateUser({
    body: {
        // User email
        email: "john@example.com",
        // User profile object
        profile: {
            // User full name
            name: "John Doe",
            // User age
            age: 25
        }
    },
    query: {
        // Notification type
        notify: "email"
    },
    params: {
        // User ID
        id: "123e4567-e89b-12d3-a456-426614174000"
    },
});

console.log(response); 
/* 
{
    // -----
    // Response object
    // -----
    // Success status
    success: true
}
*/
```

**More info**
- [OpenAPI documentation](/openapi)
- ["Hello World" example](/hello-world)

## OpenAPI mixins

Vovk.ts schema and OpenAPI 3+ schema are different but convertible to each other. This allows to mix Vovk.ts RPC modules ones that are generated from OpenAPI schema files, overriding the same signature with triple input: `params`, `query`, `body`, and other options available for all RPC modules, such as `init` to pass custom headers, `apiRoot` to override the API root, etc.

```ts
import { GithubIssuesRPC } from 'vovk-client';

const issues = await GithubIssuesRPC.list({
  query: { filter: 'created' },
  init: {
    headers: {
      Authorization: `Bearer ${process.env.GITHUB_TOKEN}`,
      'X-GitHub-Api-Version': '2022-11-28',
    },
  },
});
```

The inputs are validated on the client side using the JSON schema extracted from the OpenAPI schema.

**More info**
- [Code generation via OpenAPI mixins](/codegen)

## Standalone codegen tool

As Vovk.ts is powered by code generation, and supports OpenAPI documents, it can be used as a standalone codegen tool to generate client libraries for TypeScript but also for Python, Rust (experimental) preserving the same interface and structure as in TypeScript but also performing client-side validation.

**More info**
- [Code generation via OpenAPI mixins](/codegen)
- [`generate` command](/generate)
- [Python client](/python)
- [Rust client](/rust)

## Build & shipment

Vovk.ts CLI provides commands to build distributable packages. For example, to build a package for NPM, you can use `bundle` command that will bundle the client into a single package with [tsdown](https://tsdown.dev) behind the scenes.

```sh npm2yarn
npx vovk bundle --out dist
```

The command will bundle the RPC modules of all or specified segments into a single package in the `dist` directory, with `package.json` file and `README.md` that contains auto-generated documentation for the shipped RPC modules. Package name, description and version are taken either from the root `package.json` or can be configured at [vovk.config](/config). The only thing left is to publish the package to NPM or any other package registry.

```sh npm2yarn
npm publish dist
```

Similar approach can be used to build a package for Python or Rust, allowing to ship the back-end functionality to other languages and platforms.

```sh npm2yarn
npx vovk generate --from py --out dist_py
```

The command will generate a Python/mypy package in the `dist_py` directory with all RPC modules and OpenAPI schema files, ready to be published to PyPI.

For more information, take a look at ["Hello World" example](/hello-world).

**More info**
- [`bundle` command](/bundle)
- ["Hello World" example](/hello-world)
