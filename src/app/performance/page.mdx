# Overhead Performance

## TL;DR

- Goal: measure Vovk.ts overhead over native Next.js route handlers (not HTTP stack).
- Routing: O(1) across 1–10,000 controllers (20,000 endpoints). Median latency ~1.3–1.5 µs; at 10,000 controllers ~1.6 µs. Throughput ~630k–780k ops/s/core.
- Cold start: O(n). ~6.0 ms at 1,000 controllers; ~85 ms at 10,000. About 8–11× the cost of no‑op decorators.
- Notes: Tinybench on Apple M4 Pro. Next.js runtime cost is out of scope. Compiled from real benchmark output with AI assistance and minor edits. See vovk-perf-test repo for scripts.

## Reproducing the Tests

Clone the repo:

```sh
git clone https://github.com/finom/vovk-perf-test.git
cd vovk-perf-test
```

Install dependencies via:

```sh npm2yarn copy
npm i
```

Run performance tests via:

```sh npm2yarn copy
npm run perf-test
```

## Overview

Vovk.ts sits on top of Next.js API routes and generates handlers via decorators applied to procedures:

```ts showLineNumbers copy filename="src/app/api/[[...vovk]]/route.ts"
export const { GET, POST } = initSegment({ controllers });
```

We measure framework overhead in two dimensions:

- Request Overhead: per-request routing/handler overhead.
- Cold Start Overhead: initialization time for controllers/metadata.

Source: test scripts in the vovk-perf-test repository.

## Request Overhead

Example controller (N = 1) used in the request-overhead tests:

```ts showLineNumbers copy filename="src/modules/one/a/AController.ts" repository="finom/vovk-perf-test"
import { procedure, prefix, get, post, operation } from "vovk";

@prefix("as")
export default class AController {
  @operation({
    summary: "Get AS",
  })
  @get()
  static getAS = procedure({
    handle: (_req, params: unknown) => {
      if (params && typeof params === "object" && "id" in params)
        throw new Error("Unexpected id param");
      return null;
    },
  });

  @operation({
    summary: "Create A",
  })
  @post("{id}")
  static createA = procedure({
    handle: (_req, params: unknown) => {
      if (!(params && typeof params === "object" && "id" in params))
        throw new Error("Missing id param");
      return null;
    },
  });
}
```
*[The code above is fetched from GitHub repository.](https://github.com/finom/vovk-perf-test/blob/main/src/modules/one/a/AController.ts)*

### Methodology (short)

- Autogenerate N controllers (N ∈ \{1, 10, 100, 1,000, 10,000\}), each exposing:
  - GET without params (reject unexpected id).
  - POST with path param "\{id\}" (require id).
- Minimal handler logic; measure full routing + handler path.
- Tinybench: 100 ms min per test, nanosecond timing; report median latency/throughput.

### Results

| Controllers | Endpoints | GET Latency (med) | POST Latency (med) | GET Throughput (med ops/s) | POST Throughput (med ops/s) |
| ----------- | --------- | ----------------- | ------------------ | -------------------------- | --------------------------- |
| 1           | 2         | 1,292 ns          | 1,333 ns           | 773,994                    | 750,188                     |
| 10          | 20        | 1,292 ns          | 1,333 ns           | 773,994                    | 750,188                     |
| 100         | 200       | 1,333 ns          | 1,375 ns           | 750,188                    | 727,273                     |
| 1,000       | 2,000     | 1,291 ns          | 1,333 ns           | 774,593                    | 750,188                     |
| 10,000      | 20,000    | 1,542 ns          | 1,583 ns           | 648,508                    | 631,712                     |

Key takeaways:

- O(1) routing: stable latency from 1 to 1,000 controllers; small bump at 10,000.
- Sub‑µs overhead at typical scales; GET≈POST indicates efficient param extraction.

## Cold Start Overhead

Example cold-start benchmark (N = 1) contrasting Vovk.ts vs. no-op decorators:

```ts showLineNumbers copy filename="perf/generated_coldStartPerfTest.ts"
bench.add("Cold start for 1 controllers", async () => {
  const controllers: Record<string, Function> = {};
  @prefix("one/0")
  class One0Controller {
    @operation({
      summary: "Create",
    })
    @post("{id}")
    static create = procedure({
      handle: () => null,
    });
  }

  controllers["One0Controller"] = One0Controller;

  initSegment({
    segmentName: "",
    emitSchema: true,
    controllers,
  });
});

bench.add("No-op decorators for 1 classes", async () => {
  const controllers: Record<string, Function> = {};
  @noopClassDecorator()
  class One0Controller {
    @noopDecorator({
      summary: "Create",
    })
    @noopDecorator("{id}")
    static create = (_req: unknown, params: any) => {
      return null;
    };
  }
});
```

### Methodology (short)

For N ∈ \{1, 10, 100, 1,000, 10,000\} measure:

- App creation, decorator processing, metadata build, and initSegment().
- Compare to equivalent classes using no‑op decorators to isolate framework work.

Example no‑op decorators:

```ts showLineNumbers copy
function noopDecorator() {
  return function (..._args: any[]) {};
}
function noopClassDecorator() {
  return function <T extends new (...a: any[]) => any>(c: T) {
    return c;
  };
}
```

### Results

| Controllers | Vovk.ts Init Time (med) | No-op Time (med) | Overhead Ratio | Throughput (ops/s) |
| ----------- | ----------------------- | ---------------- | -------------- | ------------------ |
| 1           | 6.208 μs                | 0.584 μs         | 10.6x          | 161,082            |
| 10          | 54.250 μs               | 5.084 μs         | 10.7x          | 18,433             |
| 100         | 567.896 μs              | 53.125 μs        | 10.7x          | 1,761              |
| 1,000       | 6,032.355 μs            | 745.834 μs       | 8.1x           | 166                |
| 10,000      | 85,207.376 μs           | 17,858.750 μs    | 4.8x           | 12                 |

Key takeaways:

- O(n) init: linear in controller count; per‑controller cost rises at 10,000 because decorator overhead dominates.
- Absolute times are small for long‑lived services; still acceptable for serverless at typical sizes.

## Practical guidance

- For high-performance workloads: split the app into multiple [segments](/segment) (e.g., serverless functions built with Next.js route.ts files).
- In theory, with careful segment management and adequate hardware, a single Next.js/Vovk.ts app can host up to ~1,000,000 endpoints. Validate this in your environment; practical limits will be memory, bundle size, cold start budgets, and platform quotas.

---

Benchmarks: Tinybench on Node.js; hardware Apple M4 Pro. Numbers can vary by runtime, hardware, and build settings. Scripts/results: https://github.com/finom/vovk-perf-test
