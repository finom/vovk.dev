# RPC for NestJS

NestJS provides built‑in OpenAPI support via [@nestjs/swagger](https://docs.nestjs.com/openapi/introduction), and Vovk.ts can generate a client from an [OpenAPI 3+ specification](/codegen). Together, you can generate a type‑safe “RPC” client for a NestJS app with all the benefits of Vovk.ts, including client‑side validation, [function calling](/function-calling), and more.

## Install Dependencies

```sh npm2yarn
npm i vovk-client
```

```sh npm2yarn
npm i vovk-cli@draft -D
```

## Expose OpenAPI Spec in Your NestJS App

In this example, the spec is exposed at `/api-ref`, with Swagger UI available at `/docs`.

```ts filename="src/main.ts" {18-20}
import { NestFactory } from '@nestjs/core';
import { DocumentBuilder, SwaggerModule } from '@nestjs/swagger';
import { AppModule } from './app.module';

async function bootstrap() {
  const appOptions = { cors: true };
  const app = await NestFactory.create(AppModule, appOptions);
  app.setGlobalPrefix('api');

  const options = new DocumentBuilder()
    .setTitle('NestJS Example App')
    .setDescription('The API description')
    .setVersion('1.0')
    .addBearerAuth()
    .build();
  const document = SwaggerModule.createDocument(app, options);

  app.getHttpAdapter().get('/api-ref', (req, res) => {
    res.json(document);
  });

  SwaggerModule.setup('/docs', app, document);

  await app.listen(3000);
}
bootstrap()
  .catch((err) => {
    console.log(err);
  });
```

## Use OpenAPI Decorators from [@nestjs/swagger](https://www.npmjs.com/package/@nestjs/swagger)

Follow the [official documentation](https://docs.nestjs.com/openapi/decorators) to decorate controllers and DTOs with OpenAPI decorators.

```ts
import { 
  Controller, 
  Post, 
  Body, 
  Query, 
  Param, 
  HttpStatus 
} from '@nestjs/common';
import { 
  ApiOperation, 
  ApiResponse, 
  ApiParam,
  ApiBody,
  ApiQuery,
  ApiExtraModels
} from '@nestjs/swagger';
import { CreateUserDto, QueryParamsDto, UserResponseDto } from './dto/user.dto';

@Controller('users')
@ApiExtraModels(UserResponseDto) // Ensures the DTO appears in schemas
export class UserController {
  @Post(':organizationId')
  @ApiOperation({ summary: 'Create a new user' })
  @ApiParam({
    name: 'organizationId',
    type: 'string',
    description: 'Organization ID',
  })
  @ApiBody({ 
    type: CreateUserDto,
    description: 'User creation data'
  })
  @ApiQuery({ 
    type: QueryParamsDto,
    required: false 
  })
  @ApiResponse({
    status: HttpStatus.CREATED,
    description: 'User successfully created',
    type: UserResponseDto, // This ensures it appears in components/schemas
  })
  async createUser(
    @Param('organizationId') organizationId: string,
    @Body() createUserDto: CreateUserDto,
    @Query() queryParams: QueryParamsDto
  ): Promise<UserResponseDto> {
    // ...
  }
}
```

## Add `generate` Script to `package.json`

Run the development server so NestJS is available at http://localhost:3000. Set `--openapi-root-url` to your server URL if it differs.

```json filename="package.json" {5}
{
    "scripts": {
        // ...
        "start:dev": "nest start --watch",
        "generate": "vovk g --openapi=http://localhost:3000/api-ref --openapi-get-module-name=nestjs-operation-id --openapi-get-method-name=nestjs-operation-id --openapi-root-url=http://localhost:3000 --openapi-fallback=.openapi-cache/openapi.json"
    }
}
```

Here’s what each flag does:

- `--openapi=http://localhost:3000/api-ref` — URL of the OpenAPI spec.
- `--openapi-get-module-name=nestjs-operation-id` — derive module names from `operationId`.
- `--openapi-get-method-name=nestjs-operation-id` — derive method names from `operationId`.
- `--openapi-root-url=http://localhost:3000` — root URL of your API.
- `--openapi-fallback=.openapi-cache/openapi.json` — cache the spec locally and use it if the URL is unavailable (useful in CI/CD).

The `nestjs-operation-id` strategy assumes `operationId` values like `XxxController_methodName` (e.g., `UserController_createUser`). Under this strategy, `XxxController` becomes `XxxRPC`, and `methodName` is used verbatim. For custom behavior, create a [config](/config) file and define `getModuleName`/`getMethodName`.

Run the generate script in a separate terminal:

```sh npm2yarn
npm run generate
```

You can run `start:dev` and `generate` in parallel with [concurrently](https://www.npmjs.com/package/concurrently). The `--watch` option makes the generator rebuild on spec changes.

```json filename="package.json" {6}
{
    "scripts": {
        // ...
        "generate": "...",
        "start:dev": "nest start --watch",
        "dev": "concurrently \"npm run start:dev\" \"sleep 5 && npm run generate -- --watch\" --kill-others"
    }
}
```

The `dev` script runs both commands in parallel, waiting 5 seconds before `generate` to let NestJS start.

```sh npm2yarn
npm run dev
```

For more flexibility, create a [config](/config) file as shown below.

## Import and Use

Import the generated client from any `fetch`‑enabled environment:

```ts
import { UserRPC } from 'vovk-client';

const user = await UserRPC.createUser({
    body: {
        name: 'John Doe',
        email: 'john.doe@example.com'
    },
    query: {
        page: 1,
        limit: 10
    },
    params: {
        organizationId: 'org123'
    }
});
```

## Create Config File

If the CLI flags are too long or you want more features, create a [config](/config) file in the project root:

```ts filename="vovk.config.mjs"
/** @type {import('vovk-cli').VovkConfig} */
const config = {
  outputConfig: {
    segments: {
      nest: {
        openAPIMixin: {
          source: {
            url: 'http://localhost:3000/api-ref',
            fallback: '.openapi-cache/openapi.json',
          },
          apiRoot: 'http://localhost:3000',
          getModuleName: 'nestjs-operation-id',
          getMethodName: 'nestjs-operation-id',
        },
      },
    },
  },
};
export default config;
```

In this case, the generate script simplifies to:

```json filename="package.json" {4}
{
    "scripts": {
        // ...
        "generate": "vovk g"
    }
}
```

## Configure `fetcher`

To configure authorization headers, add custom options to the generated client, or transform the response, create a custom [`fetcher`](/imports#fetcher) (requires a config file).

```ts
import { UserRPC } from 'vovk-client';

await UserRPC.updateUser({
  // ...
  successMessage: 'User updated successfully',
  useAuthorization: true,
  somethingCustom: 'customValue',
});
```

## Enable Client-Side Validation

Client‑side validation isn’t enabled by default. For a NestJS app, choose one of two options:

- Validate using the emitted JSON Schema via [vovk-ajv](/validation/client#vovk-ajv).
- Validate with DTOs via [vovk-dto/validateOnClient](/validation/dto#validateonclient).

### vovk-ajv

```sh npm2yarn
npm i vovk-ajv@draft
```

```ts filename="vovk.config.mjs"
/** @type {import('vovk').VovkConfig} */
const config = {
  outputConfig: {
    imports: {
      validateOnClient: 'vovk-ajv',
    },
  },
};
export default config;
```

See the [vovk-ajv](/validation/client#vovk-ajv) section for details.

### vovk-dto/validateOnClient

```sh npm2yarn
npm i vovk-dto@draft
```

```ts filename="vovk.config.mjs"
/** @type {import('vovk').VovkConfig} */
const config = {
  outputConfig: {
    imports: {
      validateOnClient: 'vovk-dto/validateOnClient',
    },
  },
};
export default config;
```

In this setup, generated client methods validate inputs with DTOs using [class-validator](https://www.npmjs.com/package/class-validator) before sending requests. Transform plain objects to class instances with [class-transformer](https://www.npmjs.com/package/class-transformer):

```ts
import { UserRPC } from 'vovk-client';
import { plainToInstance } from 'class-transformer';
import { UpdateUserBodyDto, UpdateUserResponseDto } from '@/modules/user/UserDto';
 
const user = await UserRPC.updateUser({
  body: plainToInstance(UpdateUserBodyDto, {
    name: 'John Doe',
    age: 42,
  } satisfies UpdateUserBodyDto),
  // ... same for query and params
  // optionally transform response data to DTO
  transform: (data) => plainToInstance(UpdateUserResponseDto, data)
});
```

See the [vovk-dto/validateOnClient](/validation/dto#validateonclient) section for more information.

## Function Calling

As with any RPC module, the generated NestJS RPC modules can be turned into LLM tools and invoke server methods over HTTP.

For details, see [function calling](/function-calling).