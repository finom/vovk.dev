# Proxy Endpoints

## JSON

You can easily create a proxy endpoint by fetching data from another server with the `fetch` function, which, in turn, returns a `Response` instance that's automatically handled by Next.js. The only thing you need to do is force a different return type to make the client infer it correctly.

```ts
import { get } from 'vovk';

export default class ProxyController {
  @get('greeting')
  static getHello() {
    return fetch('https://vovk.dev/api/hello/greeting.json') as unknown as { greeting: string };
  }
}
```

See this [example in action](http://vovk-examples.vercel.app/proxy).

On the client side, the return type will be inferred as expected.

```ts
import { ProxyRPC } from 'vovk-client';

// ...
const { greeting } = await ProxyRPC.getHello();
```

You can also define the response type at the client method if you want to keep the original return type as `Response`.

```ts
import { ProxyRPC } from 'vovk-client';

// ...
const { greeting } = await ProxyRPC.getHello<{ greeting: string }>();
```

## Blob

When the return type isn't changed, the client will automatically resolve the response as a `Response` object. This is useful when you need to fetch a file or binary data.

```ts
import { get } from 'vovk';

export default class ProxyController {
  @get('pdf-proxy')
  static getPdf() {
    return fetch('https://example.com/example.pdf');
  }
}
```

```ts
import { ProxyRPC } from 'vovk-client';

// ...
const response = await ProxyRPC.getPdf();
const buffer = await response.arrayBuffer();
const blob = new Blob([buffer], { type: 'application/pdf' });
// ...
```
