# Proxy endpoints

## JSON

You can easily create a proxy endpoint by fetching data from another server with `fetch` function that, in its turn, returns `Response` instance that's automatically handled by Next.js. The only thing you need to do is to force a different return type in order to make the client infer it correctly.

```ts
import { get } from 'vovk';

export default class ProxyController {
  @get('greeting')
  static getHello() {
    return fetch('https://vovk.dev/api/hello/greeting.json') as unknown as { greeting: string };
  }
}
```

See this [example in action](http://vovk-examples.vercel.app/proxy).

On the client-side the return type is going to be inferred as expected.

```ts
import { ProxyRPC } from 'vovk-client';

// ...
const { greeting } = await ProxyRPC.getHello();
```

You can also define response type at the client method if you want to keep the original return type to be `Response`.

```ts
import { ProxyRPC } from 'vovk-client';

// ...
const { greeting } = await ProxyRPC.getHello<{ greeting: string }>();
```

## Blob

When return type isn't changed, the client will automatically resolve the response as `Response` object. This is useful when you need to fetch a file or binary data.

```ts
import { get } from 'vovk';

export default class ProxyController {
  @get('proxy')
  static proxy() {
    return fetch('https://example.com/example.pdf');
  }
}
```

```ts
import { ProxyRPC } from 'vovk-client';

// ...
const response = await ProxyRPC.proxy();
const buffer = await response.arrayBuffer();
const blob = new Blob([buffer], { type: 'application/pdf' });
// ...
```
