import { Steps, Tabs, Callout } from 'nextra/components';

# Manual Install

<Steps>

## Create a Next.js project (App Router + TypeScript)

```bash npm2yarn copy
npx create-next-app my-app --ts --app --src-dir
```

```bash
cd my-app
```

The `src` directory is optional but recommended because it keeps the project root clean.

## Install vovk and vovk-client

```sh npm2yarn copy
npm i vovk vovk-client
```

**More info:**

- [Vovk.ts Packages](/packages)

## Create the config file

Create **vovk.config.mjs** at the project root with the following content:

```ts showLineNumbers copy filename="vovk.config.mjs"
// @ts-check
/** @type {import('vovk').VovkConfig} */
const vovkConfig = {};

export default vovkConfig;
```

**More info:**

- [Config](/config)

## Install a validation library and enable client-side validation

For Zod validation on the server and Ajv on the client, install:

```sh npm2yarn copy
npm i zod vovk-zod vovk-ajv
```

Configure `validateOnClient` in your config file to enable client-side validation:

```ts showLineNumbers copy filename="vovk.config.mjs"
// @ts-check
/** @type {import('vovk').VovkConfig} */
const vovkConfig = {
  outputConfig: {
    imports: {
      validateOnClient: 'vovk-ajv',
    },
  },
};

export default vovkConfig;
```

**More info:**

- [Validation](/validation/introduction)
- [Client-side Validation](/validation/client)

## Update the dev script and add a prebuild script

There are two ways to run Vovk.ts and the Next.js server together: explicitly and implicitly. The explicit option uses the `concurrently` package to run both processes (you must set `PORT`). The implicit option lets the Vovk.ts CLI start Next.js for you; in that case, **vovk-cli** assigns the port automatically.

The `prebuild` script runs `vovk generate` before `next build` so the client library is generated ahead of the Next.js build.

<Tabs items={['Explicit', 'Implicit']} >
  <Tabs.Tab>
    Install concurrently:
```sh npm2yarn copy
npm i -D concurrently
```

    Update the "dev" script in **package.json**:

    ```json
    "scripts": {
        "build": "next build",
        "dev": "PORT=3000 concurrently 'vovk dev' 'next dev' --kill-others",
        "prebuild": "vovk generate"
    }
    ```

  </Tabs.Tab>
  <Tabs.Tab>
    Update the "dev" script in **package.json**:

    ```json
    "scripts": {
        "build": "next build",
        "dev": "npx vovk dev --next-dev",
        "prebuild": "vovk generate"
    }
    ```

  </Tabs.Tab>
</Tabs>

**More info:**

- [vovk dev](/dev)
- [vovk generate](/generate)

## Enable decorators

In your **tsconfig.json**, set `"experimentalDecorators"` to `true`.

```json
{
  "compilerOptions": {
    "experimentalDecorators": true
    // ...
  }
}
```

## Create a controller

Create **HelloController.ts** in **/src/modules/hello/** with a class of the same name.

```ts showLineNumbers copy filename="src/modules/hello/HelloController.ts"
import { get, prefix } from 'vovk';

@prefix('greetings') // prefix is optional
export default class HelloController {
  @get('greeting')
  static getHello() {
    return { greeting: 'Hello, World!' };
  }
}
```

**More info:**

- [Controller](/controller)
- [Service](/controller/service)

## Create a root segment

Create the root [segment](/segment) **/src/app/api/[[...vovk]]/route.ts**, where **[[...vovk]]** is an ["Optional Catch-all Segment"](https://nextjs.org/docs/app/api-reference/file-conventions/dynamic-routes#optional-catch-all-segments). The slug can be any valid name, such as <nobr>**[[...mySlug]]**</nobr>.

In the code below, `HelloRPC` is the name of the generated RPC module, and `HelloController` is the controller created above.

```ts showLineNumbers copy filename="src/app/api/[[...vovk]]/route.ts"
import { initSegment } from 'vovk';
import HelloController from '../../../modules/hello/HelloController';

const controllers = { HelloRPC: HelloController };

// export types that are inferred by the client
export type Controllers = typeof controllers;

// export Next.js route handlers
export const { GET, POST, PUT, DELETE } = initSegment({ controllers });
```

**More info:**

- [Segment](/segment)

## Run the dev server

Run `npm run dev` to start Vovk.ts and Next.js concurrently.

```sh npm2yarn copy
npm run dev
```

Navigate to [http://localhost:3000/api/greetings/greeting](http://localhost:3000/api/greetings/greeting) to see the result.

## Create a React component

Once the client is generated, you can import it from **vovk-client**.

```ts showLineNumbers copy filename="src/app/page.tsx"
'use client';
import { useState } from 'react';
import { HelloRPC } from 'vovk-client';
import type { VovkReturnType } from 'vovk';

export default function MyComponent() {
  const [serverResponse, setServerResponse] = useState<VovkReturnType<typeof HelloRPC.getHello>>();

  return (
    <>
      <button
        onClick={async () => {
          const response = await HelloRPC.getHello();
          setServerResponse(response);
        }}
      >
        Get Greeting from Server
      </button>
      <div>{serverResponse?.greeting}</div>
    </>
  );
}
```

Open [http://localhost:3000](http://localhost:3000) to see the result.

<Callout type="info" emoji="ℹ️">
  If you're using VSCode, you may need to
  <a href="https://stackoverflow.com/questions/64454845/where-is-vscodes-restart-ts-server">restart the TS server</a>
  when you add a new controller class. This is the only time a manual restart is typically required; other changes—like
  adding methods or updating validation—are picked up automatically.
</Callout>

**More info:**

- [TypeScript RPC](/typescript)
- [Composed Client](/composed)
- [Segmented Client](/segmented)

</Steps>
