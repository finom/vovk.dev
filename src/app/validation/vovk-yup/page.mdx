import { Tabs } from 'nextra/components';

# vovk-yup

TODO: Explain AJV

<Tabs items={['npm', 'pnpm', 'yarn']}>
  <Tabs.Tab>
  ```
  npm i vovk-yup yup
  ```
</Tabs.Tab>
  <Tabs.Tab>
  ```
  pnpm i vovk-yup yup
  ```
  </Tabs.Tab>
  <Tabs.Tab>
  ```
  yarn add vovk-yup yup
  ```
  </Tabs.Tab>
</Tabs>

See [live example](https://vovk-examples.vercel.app/yup).

[vovk-yup](https://github.com/finom/vovk-yup) is the library that implements [Yup](https://github.com/jquense/yup) validation. It performs validation on the Controller side with `YupSchema.validate`, [serializes the Yup object to a JSON Schema](https://www.npmjs.com/package/@sodaru/yup-to-json-schema) that's stored at [schema](/schema) files, and runs validation on the client before the HTTP request is made with [schema-to-yup](https://www.npmjs.com/package/schema-to-yup).  `withYup` accepts body model, an optional query model and the handler function.

```ts filename="/src/modules/user/UserController.ts"
import * as yup from 'yup';
import { put } from 'vovk';
import { withYup } from 'vovk-yup';
import UserService from './UserService';

const UpdateUserSchema = yup.object({ name: yup.string().required(), email: yup.string().email().required() }).strict();
const UpdateUserQuerySchema = yup.object({ id: yup.string().uuid().required() }).strict();

export default class UserController {
    @put.auto()
    static updateUser = withYup(UpdateUserSchema, UpdateUserQuerySchema, async (req) => {
        const { name, email } = await req.json();
        const id = req.nextUrl.searchParams.get('id');

        return UserService.updateUser(id, { name, email });
    });
}
```

The request body and query receive the type inferred from the Yup objects.

`withYup` is implemented with multiple overloads where the query model is optional, and both body and query models can be set to null.

- `withYup(bodySchema: Yup.ObjectSchema | null, querySchema: Yup.ObjectSchema | null, handler: RequestHandler)`
- `withYup(bodySchema: Yup.ObjectSchema | null, handler: RequestHandler)`

Here is body-only validation where `withYup` accepts 2 arguments: the body schema and the handler.

```ts filename="/src/modules/user/UserService.ts"
// ...
export default class UserService {
    static async updateUser = withYup(UpdateUserSchema, async (id, { name, email }) => {
        // ...
    });
}
```

To validate query-only, withYup accepts 3 arguments: null, the query schema, and the handler.

```ts filename="/src/modules/user/UserController.ts"
// ...
export default class UserController {
    @put.auto()
    static updateUser = withYup(null, UpdateUserQuerySchema, async (req) => {
        // ...
    });
}
```


## Client validation

**vovk-yup** provides `validateOnClient` function exported from **vovk-yup/validateOnClient** that can be used to validate the request on the client-side at the resulting RPC function.

```ts
import { UserRPC } from 'vovk-client';
import validateOnClient from 'vovk-yup/validateOnClient';

UserRPC.updateUser({
    body: { name: 'John', email: 'john@example.com' },
    query: { id: '123' },
    validateOnClient,
});
```

You can also define `validateOnClient` option at [/config](/config) file to apply it to all RPC functions globally so you don't need to pass it every time.

```ts filename="vovk.config.mjs"
export default {
    // ...
    validateOnClient: 'vovk-yup/validateOnClient',
};
```



## Form data

In order to use `FormData` with `withYup` to validate the request query, you need to fake type casting of body to `y.Schema<FormData>`. At this case the library isn't going to validate the request body but still will validate the query.

```ts filename="/src/modules/user/UserController.ts"
import * as y from 'yup';

export default class UserController {
    @put.auto()
    static updateUser = withYup(
        null as unknown as y.Schema<FormData>, // fake type casting
        yup.object({ id: yup.string().required() }).strict(), // query model
        async (req) => {
            // get the FormData instance
            const formData = await req.formData();
            
            // or serialize the FormData to an object
            const formData = req.vovk.form<{ email: string; file: File }>();
        }
    );
}
```
See [VovkRequest](/controller/request) for more information.

At this case the RPC function is going to expect `body` to be an instance of `FormData`.

```ts
import { UserRPC } from 'vovk-client';

const body = new FormData();
body.append('email', 'john@example.com');
body.append('file', new File(['Hello, World!'], 'file.txt'));

UserRPC.updateUser({
    body,
    query: { id: '123' },
});
```