import { Tabs } from 'nextra/components';

# Validation

The framework provides a set of validation libraries and related tools to help you validate your requests on the server and client side. 

## Server-side validation

By the time being the framework supports the following libraries for server-side validation:

- [Zod](https://www.npmjs.com/package/zod) with [vovk-zod](https://www.npmjs.com/package/vovk-zod)
- [Yup](https://www.npmjs.com/package/yup) with [vovk-yup](https://www.npmjs.com/package/vovk-yup)
- [class-validator](https://www.npmjs.com/package/class-validator) with [vovk-dto](https://www.npmjs.com/package/vovk-dto)

TODO Install

They all have similar API, providing a function `with<name>` that accepts validation models, a handler function and some additional options. The function returns a new handler function that infers the type of the used models. The function accepts the following parameters:

- `body` - the request body validation model.
- `query` - the request query validation model.
- `params` - the request params validation model.
- `output` - the handler output validation model.
- `iteration` - the model for stream iteration validation.
- `handler` - the request handler function that accepts an inferred [request](/controller/request) object and params.

And a few secondary options:

- `disableServerSideValidation: boolean | ("body" | "query" | ...etc)[]` - disables server-side validation for the specified validation model or all models if `true`. This is useful if you need to emit JSON schema for some models but don't want to validate them on the server side. The default value is `false`.
- `skipSchemaEmission: boolean | ("body" | "query" | ...etc)[]` - disables JSON schema emission for the specified validation model or all models if `true`. This is useful if you need to validate the request but don't want to emit JSON schema for it. The default value is `false`.
- `validateEveryIteration: boolean` - if `true`, the validation will be performed for every iteration for [JSONL streaming](/streaming). The default value is `false`.

<Tabs items={['Zod', 'Yup', 'class-validator']}>
<Tabs.Tab>
```ts filename="src/modules/user/UserController.ts"
import { z } from 'zod';
import { prefix, post } from 'vovk';
import { openapi } from 'vovk-openapi';
import { withZod } from 'vovk-zod';

@prefix('users')
export default class UserController {
  @openapi({
    summary: 'Update user',
    description: 'Update user by ID with Zod validation',
  })
  @post(':id')
  static updateUser = withZod({
    body: z
      .object({
        name: z.string().describe('User full name'),
        age: z.number().min(0).describe('User age'),
        email: z.string().email().describe('User email'),
      })
      .describe('User object'),
    params: z.object({
      id: z.string().uuid().describe('User ID'),
    }),
    query: z.object({
      notify: z.enum(['email', 'push', 'none']).describe('Notification type'),
    }),
    output: z
      .object({
        success: z.boolean().describe('Success status'),
      })
      .describe('Response object'),
    async handle(req, { id }) {
      const { name, age } = await req.json();
      const notify = req.nextUrl.searchParams.get('notify');

      // do something with the data
      console.log(`Updating user ${id}:`, { name, age, notify });
      return {
        success: true,
      };
    },
  });
}
```  
</Tabs.Tab>
<Tabs.Tab>
```ts filename="src/modules/user/UserController.ts"
import * as yup from 'yup';
import { prefix, post } from 'vovk';
import { openapi } from 'vovk-openapi';
import { withYup } from 'vovk-yup';

@prefix('users')
export default class UserController {
  @openapi({
    summary: 'Update user',
    description: 'Update user by ID with Yup validation',
  })
  @post(':id')
  static updateUser = withYup({
    body: yup
      .object()
      .required()
      .shape({
        name: yup.string().required().meta({ description: 'User full name' }),
        age: yup.number().min(0).required().meta({ description: 'User age' }),
        email: yup.string().email().required().meta({ description: 'User email' }),
      })
      .meta({ description: 'User object' }),
    params: yup
      .object()
      .shape({
        id: yup.string().required().meta({ description: 'User ID' }),
      })
      .required(),
    query: yup
      .object()
      .shape({
        notify: yup.string().oneOf(['email', 'push', 'none']).required().meta({ description: 'Notification type' }),
      })
      .required(),
    output: yup
      .object()
      .shape({
        success: yup.boolean().required().meta({ description: 'Success status' }),
      })
      .meta({ description: 'Response object' })
      .required(),
    async handle(req, { id }) {
      const { name, age } = await req.json();
      const notify = req.nextUrl.searchParams.get('notify');

      // do something with the data
      console.log(`Updating user ${id}:`, { name, age, notify });
      return {
        success: true,
      };
    },
  });
}
```
</Tabs.Tab>
<Tabs.Tab>
```ts filename="src/modules/user/UserController.ts"
import { IsString, IsNumber, Min, IsEmail, IsUUID, IsIn, IsBoolean } from 'class-validator';
import { JSONSchema } from 'class-validator-jsonschema';
import { prefix, post } from 'vovk';
import { openapi } from 'vovk-openapi';
import { withDto } from 'vovk-dto';

@JSONSchema({ description: 'User object' })
export class UpdateUserBodyDTO {
  @IsString()
  @JSONSchema({ description: 'User full name' })
  name!: string;

  @IsNumber()
  @Min(0)
  @JSONSchema({ description: 'User age' })
  age!: number;

  @IsEmail()
  @JSONSchema({ description: 'User email' })
  email!: string;
}

@JSONSchema({ description: 'Path parameters' })
export class UpdateUserParamsDTO {
  @IsUUID()
  @JSONSchema({ description: 'User ID' })
  id!: string;
}

@JSONSchema({ description: 'Query parameters' })
export class UpdateUserQueryDTO {
  @IsIn(['email', 'push', 'none'])
  @JSONSchema({ description: 'Notification type' })
  notify!: string;
}

@JSONSchema({ description: 'Response object' })
export class UpdateUserResponseDTO {
  @IsBoolean()
  @JSONSchema({ description: 'Success status' })
  success!: boolean;
}

@prefix('users')
export default class UserController {
  @openapi({
    summary: 'Update user',
    description: 'Update user by ID with DTO validation',
  })
  @post(':id')
  static updateUser = withDto({
    body: UpdateUserBodyDTO,
    params: UpdateUserParamsDTO,
    query: UpdateUserQueryDTO,
    output: UpdateUserResponseDTO,
    async handle(req, { id }) {
      const { name, age, email } = await req.json();
      const notify = req.nextUrl.searchParams.get('notify');
      // do something with the data
      console.log(`Updating user ${id}:`, { name, age, email, notify });
      return { success: true };
    },
  });
}
```
</Tabs.Tab>
</Tabs>

As you can see at the examples above, all validation models are defined with description, that is optional but recommended. It's going be used for the OpenAPI documentation generation:

![Scalar](/img/update-user-screenshot.png)

The screenshot is taken from [this page](http://vovk-examples.vercel.app/scalar#tag/default/POST/api/users-yup/{id}) that uses [Scalar](https://github.com/scalar/scalar). See [OpenAPI documentation](/openapi) for more details.

### `req.vovk`

[`VovkRequest`](/controller/request) provides `vovk` object that allows you to work with input data with more flexibility. It's methods such as `body`, `query`, `params` normally return regular objects. In case if you use **vovk-dto**, data returned from these methods is transformed to corresponding DTO classes. The standard request methods such as `req.json()` work as usually, returning raw untransformed data.

```ts filename="src/modules/user/UserController.ts"
// ...
export default class UserController {
  @post(':id')
  static updateUser = withDto({
    body: UpdateUserBodyDTO,
    params: UpdateUserParamsDTO,
    query: UpdateUserQueryDTO,
    async handle(req) {
      const body = await req.vovk.body();
      const query = req.vovk.query();
      const params = req.vovk.params();

      console.log(body instanceof UpdateUserBodyDTO); // true
      console.log(query instanceof UpdateUserQueryDTO); // true
      console.log(params instanceof UpdateUserParamsDTO); // true
    },
  });
}
```

If you're working on a custom validation library, you can modify the methods of `req.vovk` freely but the builtin methods should always return raw data.


TODO streaming sample


## `output` and `iteration` inference

Besides the types `VovkControllerBody`, `VovkControllerQuery`, `VovkControllerParams`, `VovkControllerYieldType` described at [the controller documentation](/types/controller) you can also use `VovkControllerOutput` and `VovkControllerIteration` to infer the output type of the controller method and the iteration type of the stream method respectively when methods are defined with one of the validation libraries.

```ts
// infer output type
type Output = VovkControllerOutput<typeof UserController.updateUser>;
// infer iteration type from stream methods
type Iteration = VovkControllerIteration<typeof StreamController.streamTokens>;
```

Note that `VovkControllerOutput` and `VovkControllerIteration` are not the same as `VovkControllerYieldType` and `VovkReturnType`. `VovkControllerOutput` and `VovkControllerIteration` only infer types of the models used with a validation library. These types are created as a workaround in order to be able to avoid circular reference errors (implicit "any") when other types such as `VovkControllerBody` are used. If you want the `handler` to be check the return type, ypu're going to need to use the types above explicitly.

```ts filename="src/modules/user/UserController.ts"
export default class UserController {
  @post(':id')
  static updateUser = withZod({
    // ...
    output: z
      .object({
        success: z.boolean().describe('Success status'),
      }),
    handle(req): VovkControllerOutput<typeof UserController.updateUser> {
      // ...
      return {
        success: true,
      };
    },
  });
}
```

TODO explain how to add description


## Client-side validation

The design of the framework allows to perform zero-cost validation on the client-side before the request is made. Each validation library described on this page emits JSON schemas that is stored in a segment [schema](/schema) and can be used for client-side validation. Third-party validation libraries can follow the same approach but it's not required.

> [!WARNING]
>
> The correctness of the emitted schemas is not guaranteed by the author of this project. All validation libraries use third-party packages to convert the models to JSON schemas. If you find any issues with the emitted schemas, please create an issue. Here is the list of the libraries that are used for the conversion:
> - [zod-to-json-schema](https://github.com/StefanTerdell/zod-to-json-schema) - well-maintained library for Zod conversion.
> - [@sodaru/yup-to-json-schema](https://github.com/sodaru/yup-to-json-schema) - poorly maintained library for Yup conversion. **vovk-yup** applies a few workarounds to fix some issues with the emitted schemas.
> - [class-validator-jsonschema](https://github.com/epiphone/class-validator-jsonschema) - poorly maintained library for class-validator conversion but no issues were found so far.

Client-side validation is performed in a so-called `validateOnClient` function that extends `VovkValidateOnClient` type. It accepts two arguments:

- An input with `body`, `query`, `params` and `endpoint` that can be used for debugging purposes.
- A validation object pulled from [schema](/schema) that contains validation schema (as it is mentioned above, it can be non-standard) for `body`, `query` and `params`.

The function can be impmenented in a way and doesn't need to return anything. 

There are two ways to use the function:

**Explicitly passing it to an RPC method.** At this case the `validateOnClient` function is passed to the RPC method as an option.

```ts
import { validateOnClient } from './lib/validateOnClient';
import { UserRPC } from 'vovk-client';

await UserRPC.updateUser({
  body,
  query,
  params,
  validateOnClient,
});
```

See all options at [TypeScript client documentation](/typescript).

**Implicitly by overriding an import path at the generated client in [config](/config)**. At this case you need to set `imports.validateOnClient` to the path of your `validateOnClient` function exported as `validateOnClient` variable.

```ts filename="vovk.config.mjs"
/** @type {import('vovk').VovkConfig} */
const vovkConfig = {
  imports: {
    validateOnClient: './src/lib/validateOnClient',
  },
};

export default vovkConfig;
```

The generated TypeScript client will import the `validateOnClient` function from the specified path and use it for all RPC methods (you can still override it for a specific method by passing it as an option). Relative paths are adjusted automatically.

```ts filename="node_modules/.vovk-client/index.ts"
import { validateOnClient } from '../../src/lib/validateOnClient';
// ...
```

### Ajv client-side validation

The main package that implements `validateOnClient` function is [vovk-ajv](https://www.npmjs.com/package/vovk-ajv) that uses [Ajv](https://www.npmjs.com/package/ajv) to validate JSON schemas. It's installed and set up automatically when `npx vovk-init` is used. 

Manual install:

<Tabs items={['npm', 'yarn', 'pnpm']}>
<Tabs.Tab>
```bash
npm install vovk-ajv
```
</Tabs.Tab>
<Tabs.Tab>
```bash
yarn add vovk-ajv
```
</Tabs.Tab>
<Tabs.Tab>
```bash
pnpm add vovk-ajv
```
</Tabs.Tab>
</Tabs>

Then update the `vovk.config.mjs` file to use it:

```ts filename="vovk.config.mjs"
/** @type {import('vovk').VovkConfig} */
const vovkConfig = {
  imports: {
    validateOnClient: 'vovk-ajv',
  },
};

export default vovkConfig;
```

Or pass it as an option to the RPC method as described above.

### DTO client-side validation

Since DTOs are regular classes, they can be directly used as a type. This feature made possible to use DTOs for client-side validation. **vovk-dto** provides its own `validateOnClient` function imported from **vovk-dto/validateOnClient** that uses [class-validator](https://www.npmjs.com/package/class-validator) to validate the request. The function is used in the same way as described above.

```ts filename="vovk.config.mjs"
/** @type {import('vovk').VovkConfig} */
const vovkConfig = {
  imports: {
    validateOnClient: 'vovk-dto/validateOnClient',
  },
};
export default vovkConfig;
```

The input data needs to be transformed to the corresponding DTO class with [class-transformer](https://www.npmjs.com/package/class-transformer). If it's not a DTO class, the data will not be validated.

```ts
import { UserRPC } from 'vovk-client';
import { plainToInstance } from 'class-transformer';
import { UpdateUserBodyDTO } from './UserDTO';


await UserRPC.updateUser({
  body: plainToInstance(UpdateUserBodyDTO, {
    name: 'John Doe',
    age: 42,
  } satisfies UpdateUserBodyDTO),
  // ... same for query and params
});
```

### Disable client validation

To disable client-side validation, you can set `disableClientValidation` option to `true` when calling the RPC method. This is can useful for debugging purposes to validate the request on the server-side only.

```ts
import { UserRPC } from 'vovk-client';

await UserRPC.updateUser({
  body: {
    name: 'John Doe',
    age: 42,
  },
  // ... query and params
  disableClientValidation: true,
});
```

## FormData

If no validation is used, in order to make the RPC method to accept form data, you need to define the handler with `VovkRequest<FormData>` type (see example at the [TypeScript client documentation](/typescript/form-data)). The form data is not validated, but you need to fake the type of the request body to be `FormData` in order to make the RPC method accept it but set the body validation model to `null`. For example for Zod validation you'd need to use an unpleasant workaround by defining the validation body with `null as unknown as z.ZodType<FormData>`.

```ts filename="src/modules/user/UserController.ts"
import { prefix, post } from 'vovk';
import { withZod } from 'vovk-zod';
import { z } from 'zod';

export default class UserController {
  @post('form')
  static updateUser = withZod({
    body: null as unknown as z.ZodType<FormData>, // ¯\_(ツ)_/¯
    async handle(req) {
      const formData = await req.formData();
      // or serialize it to an object with req.vovk.form<T>()
      const data = req.vovk.form<{
        name: string;
        age: number;
        file: File;
      }>();
    },
  });
}
```

Since it looks quite ugly, every validation library provides `formData` property that does the same but makes the code look nicer.

<Tabs items={['Zod', 'Yup', 'class-validator']}>
<Tabs.Tab>
```ts filename="src/modules/user/UserController.ts" {5}
// ...
export default class UserController {
  @post('form')
  static updateUser = withZod({
    body: withZod.formData,
    async handle(req) {
      // ...
    },
  });
}
```
</Tabs.Tab>
<Tabs.Tab>
```ts filename="src/modules/user/UserController.ts" {5}
// ...
export default class UserController {
  @post('form')
  static updateUser = withYup({
    body: withYup.formData,
    async handle(req) {
      // ...
    },
  });
}
```
</Tabs.Tab>
<Tabs.Tab>
```ts filename="src/modules/user/UserController.ts" {5}
// ...
export default class UserController {
  @post('form')
  static updateUser = withDto({
    body: withDto.formData,
    async handle(req) {
      // ...
    },
  });
}
```
</Tabs.Tab>
</Tabs>

## Disabling validation schema emission for a segment

If you want to disable the validation schema emission for a specific segment, you can set `exposeValidation` option to `false` in the segment file. This will prevent the validation schemas from being emitted for that segment.

```ts filename="src/app/api/[[...vovk]]/route.ts"
// ...
export const { GET, POST, PATCH, PUT } = initVovk({
  controllers,
  exposeValidation: false, // don't populate schema file with validation information
});
```

## Additional notes

### Prisma generators

If you use [Prisma ORM](https://www.prisma.io/) it is possible to generate the models with `prisma generate` command and use them for request validation. You can find an appropriate generator for that [here](https://www.prisma.io/docs/orm/prisma-schema/overview/generators). The example below uses [zod-prisma](https://www.npmjs.com/package/zod-prisma) generator.

```prisma
generator client {
  provider = "prisma-client-js"
}

generator zod {
  provider      = "zod-prisma"
  output        = "../src/zod"
  relationModel = false
}

datasource db {
  provider  = "postgresql"
  url       = env("PRISMA_DATABASE_URL")
  directUrl = env("PRISMA_DIRECT_DATABASE_URL")
}

model User {
    id    String @id @default(uuid())
    email String @unique
    name  String
}
```

`npx prisma generate` will generate the following Zod schema for the user model:

```ts
import { z } from 'zod';

export const UserModel = z.object({
  id: z.string(),
  email: z.string(),
  name: z.string(),
});
```

That, in its turn, can me imported at the controller and used for the request validation.

```ts
import { put } from 'vovk';
import { withZod } from 'vovk-zod';
import { UserModel } from '../zod';

export default class UserController {
  @put.auto()
  static updateUser = withZod(UserModel.omit({ id: true }).partial(), UserModel.pick({ id: true }), async (req) => {
    const { name, email } = await req.json();
    const id = req.nextUrl.searchParams.get('id');
    // ...
  });
}
```

You can perform the same idea with Yup or DTOs.

### Using with react-hook-form

If you use [react-hook-form](https://react-hook-form.com/) the models can also be used for the form validation. You can check an example [here](https://vovk-examples.vercel.app/zod-hook-form).

```ts
import { useForm } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';
import { UserModel } from '../zod';

export default function UserForm() {
  const { register, handleSubmit, errors } = useForm({
    resolver: zodResolver(UserModel.omit({ id: true })),
  });

  // ...
}
```

Find an appropriate resolver at [@hookform/resolvers](https://www.npmjs.com/package/@hookform/resolvers) README.


### DTO mapped types

TODO