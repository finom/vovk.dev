import { Tabs } from 'nextra/components';

# vovk-dto

TODO: transform: (resp) => plainToInstance(ReturnDto, resp),

<Tabs items={['npm', 'pnpm', 'yarn']}>
  <Tabs.Tab>``` npm i vovk-dto vovk-mapped-types class-validator class-transformer reflect-metadata ```</Tabs.Tab>
  <Tabs.Tab>``` pnpm i vovk-dto vovk-mapped-types class-validator class-transformer reflect-metadata ```</Tabs.Tab>
  <Tabs.Tab>``` yarn add vovk-dto vovk-mapped-types class-validator class-transformer reflect-metadata ```</Tabs.Tab>
</Tabs>

See [live example](https://vovk-examples.vercel.app/dto).

[vovk-dto](https://github.com/finom/vovk-dto) is the library that performs request data validation with [class-validator](https://www.npmjs.com/package/class-validator). `withDto` accepts body DTO, an optional query DTO and the handler function.

```ts filename="/src/modules/user/UserController.ts"
import { put } from 'vovk';
import { withDto } from 'vovk-dto';
import { IsString, IsEmail, IsUUID } from 'class-validator';
import UserService from './UserService';

// DTO for the body of the request
class UpdateUserDto {
  @IsString()
  name: string;

  @IsEmail()
  email: string;
}

// DTO for the query parameters
class UpdateUserQueryDto {
  @IsUUID()
  id: string;
}

export default class UserController {
  @put.auto()
  static updateUser = withDto(UpdateUserDto, UpdateUserQueryDto, async (req) => {
    const { name, email } = await req.json();
    const id = req.nextUrl.searchParams.get('id');

    return UserService.updateUser(id, { name, email });
  });
}
```

Note that you need to set `"strictPropertyInitialization"` to `false` at the `tsconfig.json` file to avoid the error `Property 'name' has no initializer and is not definitely assigned in the constructor`.
The request body and query receive the type inferred from the Zod objects.

`withDto` is implemented with multiple overloads where query model is optional and both body and query models can be set to null.

- `withDto(bodyDto: ClassConstructor | null, queryDto: ClassConstructor | null, handler: RequestHandler)`
- `withDto(bodyDto: ClassConstructor | null, handler: RequestHandler)`

Here is body only validation where `withDto` accepts 2 arguments: the body DTO and the handler.

```ts filename="/src/modules/user/UserService.ts"
// ...
export default class UserService {
    static async updateUser = withZod(UpdateUserDto, async (id, { name, email }) => {
        // ...
    });
}
```

To validate query only `withDto` accepts 3 arguments: `null`, the query DTO and the handler.

```ts filename="/src/modules/user/UserController.ts"
// ...
export default class UserController {
  @put.auto()
  static updateUser = withDto(null, UpdateUserQueryDto, async (req) => {
    // ...
  });
}
```

## Client validation

Unlike [vovk-zod](/validation/vovk-zod) and [vovk-yup](/validation/vovk-yup), **vovk-dto** doesn't emit [validation](/schema) schema. Instead, it defines it as `{ isDto: true }` and the client-side expects the body and the query to be converted into the DTO instances with `plainToInstance` exported from [class-transformer](https://www.npmjs.com/package/class-transformer). If `body` or `query` arent the instances of the DTO, the client-side will perform no validation.

```ts
import { UserRPC } from 'vovk-client';
import validateOnClient from 'vovk-dto/validateOnClient';
import { plainToInstance } from 'class-transformer';
import { UpdateUserDto, UpdateUserQueryDto } from './UserDto';

// ...
UserRPC.updateUser({
  body: plainToInstance(UpdateUserDto, {
    name: 'John Doe',
    email: 'john@example.com',
  }),
  query: plainToInstance(UpdateUserQueryDto, {
    id: '123',
  }),
  validateOnClient,
});
```

You can also define `validateOnClient` option at [/config](/config) file to apply it to all RPC functions globally so you don't need to pass it every time.

```ts filename="vovk.config.mjs"
export default {
  // ...
  validateOnClient: 'vovk-dto/validateOnClient',
};
```

## Form data

In order to use `FormData` with `withDto` to validate the request query, you need to fake type casting of body to `typeof FormData`. At this case the library isn't going to validate the request body but still will validate the query.

```ts filename="/src/modules/user/UserController.ts"
export default class UserController {
  @put.auto()
  static updateUser = withDto(
    null as unknown as typeof FormData, // fake type casting
    UpdateUserQueryDto, // query model
    async (req) => {
      // get the FormData instance
      const formData = await req.formData();

      // or serialize the FormData to an object
      const formData = req.vovk.form<{ email: string; file: File }>();
    }
  );
}
```

See [VovkRequest](/controller/request) for more information.

At this case the RPC function is going to expect `body` to be an instance of `FormData`.

```ts
import { UserRPC } from 'vovk-client';

const body = new FormData();
body.append('email', 'john@example.com');
body.append('file', new File(['Hello, World!'], 'file.txt'));

UserRPC.updateUser({
  body,
  query: { id: '123' },
});
```

## Mapped types

In order to modify a DTO you can use [vovk-mapped-types](https://www.npmjs.com/package/vovk-mapped-types) library. This package is a fork of [@nestjs/mapped-types](https://www.npmjs.com/package/@nestjs/mapped-types) that can be run in Edge Runtime.

```ts filename="/src/modules/user/UserDto.ts"
import { IsString, IsEmail } from 'class-validator';
import { PartialType, OmitType } from 'vovk-mapped-types';

export class UserDto {
  @IsString()
  id: string;

  @IsString()
  name: string;

  @IsEmail()
  email: string;
}

export class UpdateUserDto extends PartialType(OmitType(UserDto, ['id'] as const)) {}
```

The library requires [reflect-metadata](https://www.npmjs.com/package/reflect-metadata) to be installed as a peer dependency.
