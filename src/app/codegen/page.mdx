import { Tabs } from 'nextra/components';


# Code generation via OpenAPI mixins

Vovk.ts is able to mix the existing Vovk.ts app with modules generated from one or more OpenAPI specifications. This allows to easily integrate third-party APIs into your application, or to generate client libraries for your own APIs. The feature doesn't require Next.js to be installed and can be used to generate code as a standalone CLI tool. This page will cover [configuration](/config) file options related to code generation, but [generate](/generate) command doesn't require config file to be present.

> [!NOTE]
>
> The generated exports are still refered as "RPC modules" for consistency, not being actual "RPC" as we don't know if a client-side method actually invokes same-named server-side procedure. Let's call it "Remote imaginary Procedure Call", while there is no better term. Feel free to start a [discussion](https://github.com/finom/vovk/discussions) if you want to suggest better terminology.

## Features

### Ð¡omprehensible syntax

Unlike other OpenAPI code generators, Vovk.ts always preserves the same set of options for each method in a single argument object, making it easy to remember and use:

```ts
import { PetstoreRPC } from 'vovk-client';

await PetstoreRPC.updatePet({
  params: { id: '123' }, // URL params if any
  query: { hello: 'world' }, // Query params if any
  body: { name: 'Doggo' }, // Request body if any
  disableClientValidation: true, // Optional, disable client-side validation
  init: { headers: { 'X-Custom-Header': 'value' } }, // Optional, fetch init
  apiRoot: 'https://api.example.com', // Optional, override API root URL
});
```

### Client-side validation availability of schema

The RPC modules generated by Vovk.ts include built-in, yet optional client-side validation using [Ajv](https://ajv.js.org/) library. This allows to validate input data before sending a request to the server, ensuring that the data conforms to the expected schema. The validation can be disabled by passing `disableClientValidation: true` option to the method.

```ts
import { UserRPC } from 'vovk-client';

await UserRPC.updateUser({ // will throw a validation error if input data is invalid
  // ...
});
```

Besides runtime validation, the generated code also includes the Vovk.ts schema that can be used for form generation and validation, debugging, etc. [Composed client](/composed) as well as each chunk of [segmented client](/segmented) exports `schema` object that contains the organised and easy to access Vovk.ts schema.

```ts
import { schema } from 'vovk-client';
// import { schema } from 'vovk-client/schema';
```

```ts
import { UserRPC } from 'vovk-client';
UserRPC.updateUser.schema.validation.body; // JSON Schema for request body
```

### Using AI Tools

Every RPC module generated by Vovk.ts can be mapped into [AI tools](/ai-tools), granting the access to the third-party APIs to the Function Calling.

```ts
import { PetstoreRPC } from 'vovk-client';

const { tools } = createLLMTools({
    modules: {
        PetstoreRPC,
    }
});

console.log(tools);
// [{ execute: (llmInput) => {}, name: 'PetstoreRPC_updatePet', description: 'Update an existing pet by Id', parameters: { body: { ... } } }, ...]
```


### Python and Rust clients (experimental)

Vovk.ts templates also support generating Python and Rust clients, that support client-side validation and fixed set of options. Take a look at [Python](/python) and [Rust](/rust) pages for more details.

### Component-agnostic type inference

A good practice for OpenAPI/Codegen design is to use `components/schemas` to define input and output data. This allows to generate properly named types, that expected to be accepted by the generated client functions. Problem is that not all OpenAPI specifications are designed this way, and turning every input/output bit into a components/schema requires additional effort that's not always justified, especially if there is no specified task given to the developer.

Due to the lack of `component/schemas`, codegens will generate types with gibberish names such as `ApiUsersIdPostRequest` or `ApiUsersIdPost200Response`, making them hard to use but also making developers to avoid using codegens at all, prefering to use `fetch` or `axios` directly, providing URL and casting a type manually.

Vovk.ts is designed to support component-agnostic type inference, meaning that even if the OpenAPI specification doesn't define `components/schemas`, Vovk.ts will still try to infer input and output types with simple utilities.

```ts
import { PetstoreRPC } from 'vovk-client';
import type { VovkBody, VovkQuery, VovkParams, VovkOutput } from 'vovk';

type Body = VovkBody<typeof PetstoreRPC.updatePet>;
type Query = VovkQuery<typeof PetstoreRPC.updatePet>;
type Params = VovkParams<typeof PetstoreRPC.updatePet>;
type Output = VovkOutput<typeof PetstoreRPC.updatePet>;
```

At the previously mentioned Python client, the types are stored part of typedicts.

```py
from vovk_client import PetstoreRPC

body: PetstoreRPC.UpdateUserBody = {}
query: PetstoreRPC.UpdateUserQuery = {}
params: PetstoreRPC.UpdateUserParams = {}
output: PetstoreRPC.UpdateUserOutput = {}
```

For Rust client, the types are generated as nested modules with structs.

```rs
use vovk_client::petstore_rpc;

use user_rpc::update_user_::{
    body as Body, 
    body_::profile as Profile, // for nested data
    query as Query,
    params as Params,
    output as Output,
};
```

### Bundle

The artifacts can be bundled into an NPM package using `bundle` command that also creates `package.json` and `README.md` files, where README documents each method with self-documented code samples. See [example](/hello-world#bundle) for more details.

Note that, in order to create a [bundle](/bundle), you need to have `package.json` and `tsconfig.json` files in the root of your project.

## Getting started

### Install dependencies

In case if the codegen feature is used as a standalone CLI tool without `package.json`, install `vovk-cli` package globally or as a dev dependency.

```sh
npm install -g vovk vovk-cli
```

In case if you're in another Node.js project, and you want to use [composed client](/composed) (where all generated API clients are combined into a single client), you can also install `vovk-client` package that re-exports files generated by Vovk.ts at default path `node_modules/.vovk-client`.

```sh
npm install vovk-client
```

### Create config file

You can create a config file as described at [config](/config) page. Another way to create a config file is to use `vovk-cli init` command.

```sh
npx vovk-cli init
```

### Customize fetcher


### Composed client

(+ path to output dir)

### Segmented client



-------

# [OLD] OpenAPI code generation

Vovk.ts provides a powerful code generation feature that allows you to generate client-side RPC modules from OpenAPI specifications and merge them into.

---

Vovk.ts CLI can be used as a standalone OpenAPI code generator, allowing to generate TypeScript, Rust, and Python code from OpenAPI specification files. The generated code is split into modules, allowing to mix multiple OpenAPI specifications into a single codebase and optionally use together with modules emitted by Vovk.ts back-end framework.

<Tabs items={['TypeScript', 'Rust', 'Python']}>
<Tabs.Tab>
```ts
import {
    UserRPC, // Vovk.ts RPC module for UserController
    GithubIssuesRPC, // Codegen RPC module for GitHub Issues API
    MedusaCartRPC, // Codegen RPC module for Medusa Cart API
} from 'vovk-client';
```
</Tabs.Tab>
<Tabs.Tab>

```rs
use vovk_client::{user_rpc, github_issues_rpc, medusa_cart_rpc};
```

</Tabs.Tab>
<Tabs.Tab>

```py
from vovk_client import UserRPC, GithubIssuesRPC, MedusaCartRPC
```

</Tabs.Tab>
</Tabs>

The generated modules have similar signature, accepting `params` for URL parameters such as `users/:id`, `query` for query parameters such as `?page=1`, and `body` for request body. Every method supports client-side validation out if the box, that can be disabled by passing `disableClientValidation: true` option to the method.

<Tabs items={['TypeScript', 'Rust', 'Python']}>
<Tabs.Tab>
```ts
await UserRPC.updateUser({
    params: { id: '123' },
    query: { hello: 'world' },
    body: { name: 'John Doe' },
    disableClientValidation: true, // optional
});
```
</Tabs.Tab>
<Tabs.Tab>
```rs
user_rpc::update_user(
    id: "123",
    query: Some("hello=world"),
    body: Some("{\"name\": \"John Doe\"}"),
    disable_client_validation: true, // optional
);
```
</Tabs.Tab>
<Tabs.Tab>
```py
UserRPC.update_user(
    params={"id": "123"},
    query={"hello": "world"},
    body={"name": "John Doe"},
    disable_client_validation=True,  # optional
)
```
</Tabs.Tab>
</Tabs>
