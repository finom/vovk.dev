import { Tabs } from 'nextra/components';

# Code Generation via OpenAPI Mixins

Vovk.ts is able to mix the existing Vovk.ts client with modules generated from one or more OpenAPI specifications. This allows you to easily integrate third-party APIs into a Next.js/Vovk.ts application or to be used as a standalone codegen tool, as it doesn't require Next.js to be installed. This page will cover [configuration](/config) file options related to code generation, but it's good to know that the [generate](/generate) command doesn't require a config file to be present.

> [!NOTE]
>
> The generated exports are still referred to as "RPC modules" for consistency, even though they aren't actual "RPC" as we don't know if a client-side method actually invokes a same-named server-side procedure.

## Features

### Comprehensible Syntax

Unlike other OpenAPI code generators, Vovk.ts always preserves the same set of options for each method in a single argument object, making it easy to remember and use:

```ts
import { PetstoreRPC } from 'vovk-client';

await PetstoreRPC.updatePet({
  params: { id: '123' }, // URL params if any
  query: { hello: 'world' }, // Query params if any
  body: { name: 'Doggo' }, // Request body if any
  disableClientValidation: true, // Optional, disable client-side validation
  init: { headers: { 'X-Custom-Header': 'value' } }, // Optional, fetch init
  apiRoot: 'https://api.example.com', // Optional, override API root URL
});
```

### Client-Side Validation and Schema Availability

The RPC modules generated by Vovk.ts include built-in, yet optional, client-side validation using the [Ajv](https://ajv.js.org/) library. This allows you to validate input data before sending a request to the server, ensuring that the data conforms to the expected schema. The validation can be disabled by passing the `disableClientValidation: true` option to the method.

```ts
import { UserRPC } from 'vovk-client';

await UserRPC.updateUser({ // will throw a validation error if input data is invalid
  // ...
});
```

Besides runtime validation, the generated code also includes the Vovk.ts schema that can be used for various purposes. The [composed client](/composed) as well as each chunk of the [segmented client](/segmented) exports a `schema` object that contains the organized and easy-to-access Vovk.ts schema.

```ts
import { schema } from 'vovk-client';
// import { schema } from 'vovk-client/schema';
```

The schema is also accessible for every generated method.

```ts
import { UserRPC } from 'vovk-client';
UserRPC.updateUser.schema.validation.body; // JSON Schema for request body
```

### Using Function Calling

Every RPC module generated by Vovk.ts can be mapped into [AI tools](/function-calling), making them accessible by function calling APIs.

```ts
import { PetstoreRPC } from 'vovk-client';

const { tools } = createLLMTools({
    modules: {
        PetstoreRPC,
    }
});

console.log(tools);
// [{ execute: (llmInput) => {}, name: 'PetstoreRPC_updatePet', description: 'Update an existing pet by Id', parameters: { body: { ... } } }, ...]
```


### Python and Rust Clients (Experimental)

Vovk.ts templates also support generating Python and Rust clients that support client-side validation and the fixed set of options. Take a look at the [Python](/python) and [Rust](/rust) pages for more details.

### Component-Agnostic Type Inference

A good practice for OpenAPI/codegen design is to use `components/schemas` to define input and output data. This allows you to generate properly named types that are accepted by the generated client functions. The problem is that not every OpenAPI specification is designed this way, and turning every input/output bit into a `components/schema` requires additional effort that's not always justified.

Due to the lack of `components/schemas`, codegens will generate types with gibberish names such as `ApiUsersIdPostRequest` or `ApiUsersIdPost200Response`, making them hard to use and causing developers to avoid using codegens at all, preferring to use `fetch` or `axios` directly, providing the URL and casting a type manually.

Vovk.ts is designed to support component-agnostic type inference, meaning that even if the OpenAPI specification doesn't define `components/schemas`, Vovk.ts will still be able to infer input and output types with simple utilities.

```ts
import { PetstoreRPC } from 'vovk-client';
import type { VovkBody, VovkQuery, VovkParams, VovkOutput } from 'vovk';

type Body = VovkBody<typeof PetstoreRPC.updatePet>;
type Query = VovkQuery<typeof PetstoreRPC.updatePet>;
type Params = VovkParams<typeof PetstoreRPC.updatePet>;
type Output = VovkOutput<typeof PetstoreRPC.updatePet>;
```

At the previously mentioned [Python](/python) client, the types are stored as TypedDicts.

```py
from vovk_client import PetstoreRPC

body: PetstoreRPC.UpdateUserBody = {}
query: PetstoreRPC.UpdateUserQuery = {}
params: PetstoreRPC.UpdateUserParams = {}
output: PetstoreRPC.UpdateUserOutput = {}
```

For the [Rust](/rust) client, the types are generated as nested modules that contain structs.

```rs
use vovk_client::petstore_rpc;

use user_rpc::update_user_::{
    body as Body, 
    body_::profile as Profile, // for nested data
    query as Query,
    params as Params,
    output as Output,
};
```

### Bundle

The [TypeScript](/typescript) artifacts can be bundled into an NPM package using the `bundle` command, which also creates `package.json` and `README.md` files, where the README file outlines each method with self-documented code samples. See the ["Hello World" example](/hello-world#bundle) for more details.

Note that to create a [bundle](/bundle), you need to have `package.json` and `tsconfig.json` files in the root of your project.

## Getting Started

### Install Dependencies

If the codegen feature is used as a standalone CLI tool (even without `package.json`), install the `vovk-cli` package globally or as a dev dependency.

```sh npm2yarn
npm install -g vovk-cli@draft
```

or install `vovk-cli` as a dev dependency and `vovk` and `vovk-ajv` as regular dependencies.


```sh npm2yarn
npm install -D vovk-cli@draft
```

```sh npm2yarn
npm install vovk@draft vovk-ajv@draft
```

If you're in another Node.js project and you want to use the [composed client](/composed) (where all generated API clients are combined into a single client), you can also install the `vovk-client` package that re-exports files generated by Vovk.ts at the default path `node_modules/.vovk-client`.

```sh
npm install vovk-client@draft
```

### Create Config File

You can create a config file as described on the [config](/config) page. Another way to create a config file is to use the `vovk-cli init` command.

```sh npm2yarn
npx vovk-cli@draft init --channel draft
```

A basic config file will look like this:

```ts filename="vovk.config.js"
/** @type {import('vovk').VovkConfig} */
const config = {
  outputConfig: {
    imports: {
      validateOnClient: 'vovk-ajv',
    },
  },
};
export default config;
```

### Define OpenAPI Mixins

A mixin can be defined as a pseudo-[segment](/segment) in the `segments` object of the `outputConfig` by setting the `openAPIMixin` property. It expects an object with the following properties:

- `source` - an object with either `url` (for remote specs), `path` (for local specs), or `object` (for inline specs). The `url` variant can also be extended with a `fallback` property that points to a local file path to be used when the remote URL is not reachable.
- `getModuleName` - a string or a function that defines names of the generated RPC modules. The string can be `nestjs-operation-id`, described on the [NestJS](/nestjs) page, or any other string that will be used as is.
- `getMethodName` - a string or a function that defines how the method names will be generated. The string can be `nestjs-operation-id`, described on the [NestJS](/nestjs) page, `camel-case-operation-id` that converts `operationId` to camel case (`get_users` will turn into `getUsers`), or `auto` that generates method names automatically from `operationId` or based on the HTTP method and path if `operationId` isn't suitable or isn't set.
- `apiRoot` (optional) - a string that defines the root URL of the API, which can be overridden by passing the `apiRoot` option to each method. Required when the `servers` property is not defined in the OAS document.

A Petstore example with a remote URL and fallback to a local file:

```ts filename="vovk.config.js"
/** @type {import('vovk').VovkConfig} */
const config = {
  outputConfig: {
    imports: {
      validateOnClient: 'vovk-ajv',
    },
    segments: {
      petstore: {
        openAPIMixin: {
          source: {
            url: 'https://petstore3.swagger.io/api/v3/openapi.json',
            fallback: './.openapi-cache/petstore.json',
          },
          getModuleName: 'PetstoreRPC',
          getMethodName: 'auto',
          apiRoot: 'https://petstore3.swagger.io/api/v3',
        },
      },
    }
  },
};
export default config;
```

This will generate a single `PetstoreRPC` module with methods for each operation defined in the OpenAPI specification.


```ts
import { PetstoreRPC } from 'vovk-client';

await PetstoreRPC.getPets({ query: { limit: 10 } });
```

When `getModuleName` or `getMethodName` are functions, they receive an object with the following properties:

- `operationObject` - the OpenAPI Operation Object for a particular operation.
- `method` - the HTTP method (in uppercase) as a string.
- `path` - the path of the operation as a string.
- `openAPIObject` - the entire OpenAPI document object.

For a more advanced example, let's create an alternative client for the [GitHub REST API](https://docs.github.com/en/rest). The `operationId` presented in the [GitHub OpenAPI spec](https://raw.githubusercontent.com/github/rest-api-description/main/descriptions/api.github.com/api.github.com.json) has a shape like `scope/operation` (for example, `repos/remove-status-check-contexts` or `codespaces/list-for-authenticated-user`). We can use the first part of the `operationId` to generate module names and the second part to generate method names using lodash.

An `operationId` that looks like `issues/list-for-org` will turn into the `GithubIssuesRPC` module with the `listForOrg` method.

```ts filename="vovk.config.js"
// @ts-check
import camelCase from 'lodash/camelCase.js';
import startCase from 'lodash/startCase.js';

/** @type {import('vovk').VovkConfig} */
const config = {
  outputConfig: {
    imports: {
      validateOnClient: 'vovk-ajv',
    },
    segments: {
      github: {
        openAPIMixin: {
          source: {
            url: 'https://raw.githubusercontent.com/github/rest-api-description/main/descriptions/api.github.com/api.github.com.json',
            fallback: './.openapi-cache/github.json',
          },
          getModuleName: ({ operationObject }) => {
            const [operationNs] = operationObject.operationId?.split('/') ?? ['unknown'];
            return `Github${startCase(camelCase(operationNs)).replace(/ /g, '')}RPC`;
          },
          getMethodName: ({ operationObject }) => {
            const [, operationName] = operationObject.operationId?.split('/') ?? ['', 'ERROR'];
            return camelCase(operationName);
          },
        },
      },
    },
  },
};

export default config;
```

You may also want to set `ajv` options to be less strict, as the OAS documents provided by third-party APIs may contain non-standard keywords that will cause validation errors.

```ts filename="vovk.config.js"
// @ts-check
/** @type {import('vovk').VovkConfig} */
const config = {
  // ...
  libs: {
    /** @type {import('vovk-ajv').VovkAjvConfig} */
    ajv: {
      options: {
        strict: false, // Petstore OAS provides "xml" keyword that causes errors in strict mode
      },
    },
  },
};

export default config;
```


### Customize Fetcher

You can customize the fetching function for each mixin individually or use a single fetcher for all mixins. The [fetcher](/imports#fetcher) is a function that is used to prepare handlers, perform client-side validation, and make and handle HTTP requests.

```ts filename="vovk.config.js"
/** @type {import('vovk').VovkConfig} */
const config = {
  outputConfig: {
    // ...
    segments: {
        petstore: {
            openAPIMixin: { /* ... */ },
            imports: { fetcher: './src/lib/petstoreFetcher' },
        },
    }
  },
};
export default config;
```


### Composed Client

#### `mjs` + `cjs` (default)

By default, the [composed client](/composed) feature uses [mjs](/templates#mjs) and [cjs](/templates#cjs) templates to generate both ESM and CJS clients, emitted to the `node_modules/.vovk-client` folder that can be imported as the `vovk-client` package.

```ts
import { PetstoreRPC, GithubIssuesRPC, type Mixins } from 'vovk-client';

await PetstoreRPC.getPets({ query: { limit: 10 } });
await GithubIssuesRPC.listForOrg({ params: { org: 'finom' } });
```

The `Mixins` namespace contains types generated from `components/schemas` of all mixed OpenAPI specifications, giving an alternative way to access types.

```ts
import { PetstoreRPC, type Mixins } from 'vovk-client';

const pet: Mixins.Pet = { id: 1, name: 'Doggo' };
// ^ alternative to component-agnostic inference
const pet: VovkOutput<typeof PetstoreRPC.getPet> = { id: 1, name: 'Doggo' };
```

#### `ts`

The [ts](/templates#ts) template generates an uncompiled TypeScript client that can be emitted directly to your codebase.

```ts filename="vovk.config.js"
/** @type {import('vovk').VovkConfig} */
const config = {
  composedClient: {
    fromTemplates: ['ts'], // use 'ts' instead of 'mjs' and 'cjs'
    outDir: './src/lib/client', // emit to your codebase
    prettifyClient: true, // prettify the output
  },
};
export default config;
```

```ts
import { PetstoreRPC, GithubIssuesRPC, type Mixins } from '../lib/client';
// ...
```

### Segmented Client

The [segmented client](/segmented) splits the code into multiple chunks, storing each mixin in a separate folder described as a segment name (`petstore`, `github`, etc., from `outputConfig.segments`).

By default, they are emitted to the `src/client` folder, but you can change the output folder by setting the `outDir` property in the `segmentedClient` config.

```ts filename="vovk.config.js"
/** @type {import('vovk').VovkConfig} */
const config = {
  segmentedClient: {
    outDir: './src/lib/client', // emit to your codebase
    prettifyClient: true, // prettify the output
  },
};
export default config;
```

```ts
import { PetstoreRPC, type Mixins as PetstoreMixins } from '@/lib/client/petstore';
import { GithubIssuesRPC, type Mixins as GithubMixins } from '@/lib/client/github';
// ...
```

A bonus for this approach is that it also generates an alternative OAS document that contains [Scalar](https://scalar.com/)-compatible code samples.


```ts
import { openapi as petstoreOpenAPI } from '@/lib/client/petstore/openapi';
import { openapi as githubOpenAPI } from '@/lib/client/github/openapi';
console.log(petstoreOpenAPI, githubOpenAPI);
```