import { FileTree, Tabs } from 'nextra/components';
import GithubFiles from '@/components/GithubFiles';


# Python RPC Client (Experimental)

The Python client can be generated with the `vovk generate` command using the [py](/templates#py) template or [pySrc](/templates#pysrc) template.

You can generate a Python package with the [CLI](/cli):

```sh npm2yarn
npx vovk generate --from py --out ./python_package
```

This will generate a Python package with the following structure:

<FileTree>
  <FileTree.Folder name="python_package" defaultOpen>
    <FileTree.Folder name="src/package_name" defaultOpen>
      <FileTree.File name="__init__.py" />
      <FileTree.File name="api_client.py" />
      <FileTree.File name="py.typed" />
      <FileTree.File name="schema.json" />
    </FileTree.Folder>
    <FileTree.File name="pyproject.toml" />
    <FileTree.File name="setup.cfg" />
    <FileTree.File name="README.md" />
  </FileTree.Folder>
</FileTree>

The package is ready to be published to [PyPI](https://pypi.org/) with the following command:

```sh
python3 -m build ./python_package --wheel --sdist && python3 -m twine upload ./python_package/dist/*
```

If you want to generate Python source only to be used as part of another Python project, you can use the `pySrc` template:

```sh npm2yarn
npx vovk generate --from pySrc --out ./python_src
```

This will generate a Python source with the following structure:

<FileTree>
  <FileTree.Folder name="python_src" defaultOpen>
    <FileTree.File name="__init__.py" />
    <FileTree.File name="api_client.py" />
    <FileTree.File name="py.typed" />
    <FileTree.File name="schema.json" />
  </FileTree.Folder>
</FileTree>

## Configuring the Python Client

The generation can be [configured](/config) so the client will be generated automatically with the [generate](/generate) command with no flags, and also when [vovk dev](/dev) is run, which performs "hot generation" whenever the schema changes. To do that, you need to add the `py` template to the [composed client](/composed) config:

```ts filename="vovk.config.mjs"
/** @type {import('vovk').VovkConfig} */
const config = {
  composedClient: {
    fromTemplates: ['cjs', 'mjs', 'py'], // keeps the default "cjs" and "mjs" templates
  },
};
export default config;
```

The [py](/templates#py) template, as well as some other templates, has a default `outDir` (by default equals to `./dist_python`) for the composed client configuration, which can be changed with [template definitions](/templates#defs) in the config:

```ts filename="vovk.config.mjs"
/** @type {import('vovk').VovkConfig} */
const config = {
  // ...
  clientTemplateDefs: {
    py: {
      extends: 'py', // extends the built-in "py" template
      composedClient: {
        outDir: './my_dist_python', // updates the out directory for the composed client
      },
    },
  },
};
export default config;
```

## Generated Python Client Example

### JSON Endpoints

All the code below was copied with slight modifications from a real example, explained on the [Hello World](/hello-world) page.

A [controller](/controller) like this:

<GithubFiles paths={['src/modules/user/UserController.ts', 'src/modules/user/UserService.ts']} repo="vovk-hello-world" />

...will emit a [Vovk.ts schema](/schema), which will, in turn, be used to generate the Python client, following the language conventions where possible, adding comments defined in the schema `description`, and generating the most suitable number types. For example, `age` is generated as `int` as per the controller method definition.

```py filename="./dist_python/src/package_name/__init__.py"
from __future__ import annotations
from typing import Any, Dict, List, Literal, Optional, Set, TypedDict, Union, Tuple, Generator # type: ignore
from .api_client import ApiClient, HttpException

HttpException = HttpException

client = ApiClient('https://vovk-hello-world.vercel.app/api')
 
class UserRPC: 
    # UserRPC.update_user POST `https://vovk-hello-world.vercel.app/api/users/{id}`
    class __UpdateUserBody_profile(TypedDict):
        """
        User profile object
        """
        name: str
        age: int
    class UpdateUserBody(TypedDict):
        """
        User data object
        """
        email: str
        profile: UserRPC.__UpdateUserBody_profile
    class UpdateUserQuery(TypedDict):
        """
        Query parameters
        """
        notify: Literal["email", "push", "none"]
    class UpdateUserParams(TypedDict):
        """
        Path parameters
        """
        id: str
    class UpdateUserOutput(TypedDict):
        """
        Response object
        """
        success: bool
    @staticmethod
    def update_user(
        body: UpdateUserBody,
        query: UpdateUserQuery,
        params: UpdateUserParams,
        headers: Optional[Dict[str, str]] = None,
        files: Optional[Dict[str, Any]] = None,
        api_root: Optional[str] = None,
        disable_client_validation: bool = False
    ) -> UpdateUserOutput:
        """ 
        Update user
        Description: Update user by ID
        Body: User data object
        Query: Query parameters
        Returns: Response object
        """
        return client.request( # type: ignore
            segment_name='',
            rpc_name='UserRPC',
            handler_name='updateUser',
            body=body,
            query=query,
            params=params,
            headers=headers,
            files=files,
            api_root=api_root,
            disable_client_validation=disable_client_validation
        )
```

All RPC modules are generated in the `__init__.py` file, which contains all the RPC methods as functions as well as types that are used in the RPC methods. Types for nested data structures are generated as `TypedDict`s.

The types of `body`, `query`, and `params` can be obtained from the RPC module using the pattern `[PascalCaseMethodName][InputType]`. For example, a controller method originally named `updateUser` will have types `UpdateUserBody`, `UpdateUserQuery`, and `UpdateUserParams` generated.


```py
from dist_python.src.vovk_hello_world import UserRPC
import vovk_hello_world

def main() -> None:
    body: UserRPC.UpdateUserBody = {
        "email": "john@example.com",
        "profile": {
            "name": "John Doe",
            "age": 25
        }
    }
    query: UserRPC.UpdateUserQuery = {"notify": "email"}
    params: UserRPC.UpdateUserParams = {"id": "123e4567-e89b-12d3-a456-426614174000"}
    # Update user using local module
    update_user_response = UserRPC.update_user(
        params=params,
        body=body,
        query=query
    )
    print('UserRPC.update_user:', update_user_response)
  
if __name__ == "__main__":
  try:
      main()
  except Exception as e:
      print(f"Error: {e}")

```

Behind the scenes, it uses [requests](https://pypi.org/project/requests/) for HTTP requests, [jsonschema](https://pypi.org/project/jsonschema/) for client-side validation, plus some other common libraries.

### JSON Lines Endpoints

To implement continuous streaming with [JSON Lines](/controller/jsonlines) endpoints, the Python client implements a `Generator` that can be used to iterate over the streamed data.

A controller like this:

<GithubFiles paths={['src/modules/stream/StreamController.ts', 'src/modules/stream/StreamService.ts']} repo="vovk-hello-world" />

Will be compiled to the following Python code:

```py filename="./dist_python/src/package_name/__init__.py"
class StreamRPC: 
    # StreamRPC.stream_tokens GET `https://vovk-hello-world.vercel.app/api/streams/tokens`
    class StreamTokensIteration(TypedDict):
        """
        Streamed token object
        """
        message: str
    @staticmethod
    def stream_tokens(

        headers: Optional[Dict[str, str]] = None,
        files: Optional[Dict[str, Any]] = None,
        api_root: Optional[str] = None,
        disable_client_validation: bool = False
    ) -> Generator[StreamTokensIteration, None, None]:
        """ 
        Stream tokens
        Description: Stream tokens to the client
        """
        return client.request( # type: ignore
            segment_name='',
            rpc_name='StreamRPC',
            handler_name='streamTokens',

            headers=headers,
            files=files,
            api_root=api_root,
            disable_client_validation=disable_client_validation
        )
```

That can be utilized like this:

```py
from dist_python.src.vovk_hello_world import StreamRPC  # local module
import vovk_hello_world

def main() -> None:
    stream_response = StreamRPC.stream_tokens()
    print("streamTokens:")
    for item in stream_response:
        print(item['message'], end='', flush=True)

if __name__ == "__main__":
    try:
        main()
    except Exception as e:
        print(f"Error: {e}")

```

## Roadmap

- üêû Allow circular $refs with [OpenAPI mixins](/codegen).
- ‚ú® Generate importable types for named schemas defined in `components/schemas`.