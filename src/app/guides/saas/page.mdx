import { Steps } from 'nextra/components'

# Framework for SaaS applications


Next.js in tandem with Vovk.ts offer a framework for building SaaS applications. The app is implemented as a single Next.js application, that, when deployed, split into multiple Edge Functions (smaller "back-ends"), each serving a specific purpose. This makes deployment infrastructure cheaper, having only one Next.js app to deploy with minimal configuration, while still being able to scale horizontally by adding more functions defined as Next.js `page.tsx` (UI) and `route.ts` (server-side code) files. The offering also makes development cheaper, as you don't need to maintain monorepo with common UI and libraries, that require additional configuration and tooling, and planning in general.

As a SaaS framework Vovk.ts also offers a set of features that are usually implemented separately:

- Multi-domain support, allowing to serve areas of the application from different domains, for example `https://example.com`, `https://admin.example.com`, `https://customer.example.com`, `https://acme.customer.example.com` (wildcard subdomains).
- First-party OpenAPI support, allowing to describe the API of the application or a single segment of the application, so that it can be used by third-party developers to integrate with your application.
- Typed code generation of so-called "RPC modules" that can be distributed as public or private packages for TypeScript, Python, or Rust, allowing to call the API endpoints from the client-side code.

<Steps>

## Split the app into multiple areas

In the most classical case a SaaS application is split into 3 "areas" or "tenants":
1. Root area - serves landing page with some features like "subscribe to newsletter", stats collection, etc. It's available to all unauthenticated users serving marketing content, pricing plans, etc.
2. Customer area - serves authenticated paid or trial customers, providing access to the main features of the application.
3. Admin area - serves authenticated administrators, providing access to the admin features of the application, managing customer, billing, etc.

Each area is going to have its own `route.ts` file, representing so-called [segment](/segment) in Vovk.ts that is served as a separate Edge Function:

- Root area is served from `/api` endpoint, implemented in `src/app/api/route.ts` file.
- Customer area is served from `/api/customer` endpoint, implemented in `src/app/api/customer/route.ts` file.
- Admin area is served from `/api/admin` endpoint, implemented in `src/app/api/admin/route.ts` file.

Each segment have its own set of [controllers](/controller) and [services](/controller/service) defined in `src/modules/`. The services are used to implement the business logic of the application (perform DB calls etc), while controllers define the API endpoints and their methods. Services can be shared between controllers as well as between segments, so you can implement the business logic once and use it in multiple places. For example, you can implement a service for the customer area that fetches the current user data and use it in both customer and admin segments.

SHARED LIB DRAWING TODO

Each controller of the segments automaticaly transformed into so-called RPC module, represented as an object that implements the same methods as the controller's methods. The RPC modules can be imported from `"vovk-client"` package and used in the client-side code to call the API endpoints.

CODE TODO

## Enable segmented client

The generated TypeScript client library imports `.json` files from the `.vovk-schema/` directory that is generated by `npm run dev`. This makes the entire back-end schema available to the client-side inspection, revealing all the API endpoints (customer area gets access to the schema of admin area). In order to fix that you can switch to using "segmented client" that only exposes the API endpoints of the current segment. The client is split by segment, having its own folder and importing `.json` files that are responsible for one segment only. This way the customer area will only have access to the customer segment API endpoints, while the admin area will have access to both customer and admin segments if needed.

SEGMENTD CLIENT DRAWING TODO

This can be achieved by updating [config](/config) or by using flags with [vovk generate](/cli/generate) command:

EXAMPLE TODO

## Enable multi-tenancy

MULTITENANT DRAWING TODO

Vovk.ts supports multi-tenancy out of the box, allowing to serve different areas of the application from different domains. This is achieved by using [multitenant TODO](/multitenant) function that processes the request information and returns the action to take, such as redirecting to a specific subdomain or rewriting the request to a different path.

## Offer public API to your customers

The back-end framework implements the conventional REST API, allowing to expose the API endpoints to the public without additional explanation.

## Offer installable libraries for your public API

xxxx

**TypeScript**

```sh npm2yarn
npx vovk bundle --out ./mylib
```

Vovk.ts provides TypeScript library bundler with auto-generated `README.md` and `package.json` files, allowing to publish the library to npm registry with `npm publish` command. Since the library uses `fetch` under the hood, it can be used in both Node.js and browser environments. Package name, description, and other metadata are taken from the `package.json` file in the root of the project and can be configured in the [config](/config) file.

**Rust and Python**

Vovk.ts also provides support for generating Rust and Python libraries that can be used to call the API endpoints from the client-side code. The libraries are generated using the same `vovk generate` command, but with different flags for Rust and Python.

```sh npm2yarn
npx vovk generate --out ./mylib --from rs
```

```sh npm2yarn
npx vovk generate --out ./mylib --from py
```

## Implement AI-powered client

Coming soon.

</Steps>