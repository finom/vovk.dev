import { FileTree } from 'nextra/components';

# Schema

The `npm run dev` script runs [vovk dev](/dev) alongside `next dev` via [concurrently](https://www.npmjs.com/package/concurrently). The Vovk process watches the `modules` folder for controller and [validation](/validation) changes. On the first run or after changes, it calls the Next.js dev serverâ€™s `_schema_` endpoint for the relevant segment (available only when `process.env.NODE_ENV` is `development`). That endpoint returns the schema for the target segment, enabling isolated JSON emission per segment. This works in the [Edge Runtime](https://edge-runtime.vercel.app/) because `route.ts` files do not import Node.js modules like `fs`.

Each segment emits its backend schema to an individual JSON file, which is then used to generate client-side RPC modules. If your application has multiple areas (e.g., root, admin, customer), each area has its own schema file.

For a segment structure like this:

<FileTree>
  <FileTree.Folder name="src/app/api" defaultOpen>
    <FileTree.Folder name="[[...vovk]]" defaultOpen>
      <FileTree.File
        name={
          <span>
            route.ts{' '}
            <span className="text-gray-500">
              (root segment <code>/api/</code>)
            </span>
          </span>
        }
      />
    </FileTree.Folder>
    <FileTree.Folder name="admin/[[...vovk]]" defaultOpen>
      <FileTree.File
        name={
          <span>
            route.ts{' '}
            <span className="text-gray-500">
              (admin segment <code>/api/admin</code>)
            </span>
          </span>
        }
      />
    </FileTree.Folder>
    <FileTree.Folder name="customer/[[...vovk]]" defaultOpen>
      <FileTree.File
        name={
          <span>
            route.ts{' '}
            <span className="text-gray-500">
              (customer segment <code>/api/customer</code>)
            </span>
          </span>
        }
      />
      <FileTree.Folder name="static/[[...vovk]]" defaultOpen>
        <FileTree.File
          name={
            <span>
              route.ts{' '}
              <span className="text-gray-500">
                (static segment <code>/api/customer/static</code> for OpenAPI)
              </span>
            </span>
          }
        />
      </FileTree.Folder>
    </FileTree.Folder>
  </FileTree.Folder>
</FileTree>

The resulting schema files are written to `.vovk-schema/`:

<FileTree>
  <FileTree.Folder name=".vovk-schema" defaultOpen>
    <FileTree.File name="root.json" />
    <FileTree.File name="admin.json" />
    <FileTree.File name="customer.json" />
    <FileTree.Folder name="customer" defaultOpen>
      <FileTree.File name="static.json" />
    </FileTree.Folder>
    <FileTree.File name="_meta.json" />
  </FileTree.Folder>
</FileTree>

Emitted files mirror the segment tree. For example, a `foo/bar/baz` segment emits `.vovk-schema/foo/bar/baz.json`. The root segment is the only exception and uses `root.json` for clarity.

`_meta.json` contains additional metadata, including selected fields from [vovk.config](/config) under the `config` key, plus other information.

When the Vovk CLI reads these files, it builds a single object with `segments` and `meta`. `segments` is flat, keyed by segment name, and `meta` contains the `_meta.json` content. This object powers client-side RPC generation and OpenAPI output, and is also available on both the client and server as the `schema` export.

```ts showLineNumbers copy
{
  "segments": {
    "": { ... }, // root segment schema from root.json
    "admin": { ... }, // admin segment schema from admin.json
    "customer": { ... }, // customer segment schema from customer.json
    "customer/static": { ... } // static segment schema from customer/static.json
  },
  "meta": { ... } // content of _meta.json file
}
```

```ts showLineNumbers copy
import { schema } from 'vovk-client';
// or
import { schema } from 'vovk-client/schema'; // exports only the schema object (no RPC modules)

import type { VovkSchema, VovkSegmentSchema } from 'vovk';

console.log(schema satisfies VovkSchema); // full schema
console.log(schema.segments.admin satisfies VovkSegmentSchema); // admin segment schema
```

The `schema` is also available in the [segmented client](/composed-and-segmented), containing exactly one segment:

```ts showLineNumbers copy
{
  "segments": {
    "": { ... } // root segment schema from root.json
  },
  "meta": { ... } // content of _meta.json file
}
```

```ts showLineNumbers copy
import { schema } from '@client/root';
// or
import { schema } from '@client/root/schema';
```

---

Example of a segment schema file:

```json filename=".vovk-schema/segments/foo.json"
{
  // Segment schema version
  "$schema": "https://vovk.dev/api/spec/v3/segment.json",
  // initSegment option controlling whether this segment emits a schema
  "emitSchema": true,
  // Segment name; the root segment uses an empty string
  "segmentName": "foo",
  // Controllers as key-value pairs for fast access:
  // Key: exported RPC module name from "vovk-client"
  // Value: controller information
  "controllers": {
    "HelloRPC": {
      // RPC module name used on the client
      "rpcModuleName": "HelloRPC",
      // Original controller class name (used to resolve segment
