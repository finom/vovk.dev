import { Tabs } from 'nextra/components';

# Code Generation via OpenAPI Mixins

Vovk.ts can combine the existing Vovk.ts client with modules generated from one or more OpenAPI specifications. This lets you integrate third-party APIs into a Next.js/Vovk.ts application, or use it as a standalone codegen tool—Next.js is not required. This page covers [configuration](/config) options related to code generation; note that the [generate](/generate) command does not require a config file.

## Features

### Comprehensible Syntax

Vovk.ts preserves a consistent call signature for every method using a single argument object, making it easy to learn and remember:

```ts showLineNumbers copy
import { PetstoreAPI } from 'vovk-client';

await PetstoreAPI.updatePet({
  params: { id: '123' }, // URL params (if any)
  query: { hello: 'world' }, // Query params (if any)
  body: { name: 'Doggo' }, // Request body (if any)
  disableClientValidation: true, // Optional: disable client-side validation
  init: { headers: { 'X-Custom-Header': 'value' } }, // Optional: fetch init
  apiRoot: 'https://api.example.com', // Optional: override API root URL
});
```

### Client-Side Validation and Schema Availability

API modules generated by Vovk.ts include built-in, optional client-side validation using [Ajv](https://ajv.js.org/). You can validate input data before sending a request to ensure it conforms to the expected schema. Disable validation by passing `disableClientValidation: true`.

```ts showLineNumbers copy
import { UserAPI } from 'vovk-client';

await UserAPI.updateUser({
  // ...will throw a validation error if input data is invalid
});
```

In addition to runtime validation, the generated code also exports the Vovk.ts schema for broader use cases. The [composed client](/composed) and each chunk of the [segmented client](/segmented) export a `schema` object that contains an organized, easy-to-navigate Vovk.ts schema.

```ts showLineNumbers copy
import { schema } from 'vovk-client';
// import { schema } from 'vovk-client/schema';
```

The schema is also accessible on every generated method.

```ts showLineNumbers copy
import { UserAPI } from 'vovk-client';
UserAPI.updateUser.schema.validation.body; // JSON Schema for request body
```

### Deriving AI Tools

Every API module generated by Vovk.ts can be mapped to [AI tools](/tools), making them accessible through function calling APIs.

```ts showLineNumbers copy
import { deriveTools } from 'vovk';
import { PetstoreAPI } from 'vovk-client';

const { tools } = deriveTools({
  modules: {
    PetstoreAPI,
  },
});

console.log(tools);
// [{ execute: (llmInput) => {}, name: 'PetstoreAPI_updatePet', description: 'Update an existing pet by Id', parameters: { body: { ... } } }, ...]
```

### Python and Rust Clients (Experimental)

Vovk.ts templates also support generating Python and Rust clients with client-side validation and the same consistent options. See the [Python](/python) and [Rust](/rust) pages for details.

### Type Inference for Unnamed Schemas

A good practice in OpenAPI/mixins design is to use `components/schemas` to define input and output data. This enables properly named types for generated client functions. However, not every OpenAPI specification follows this pattern, and extracting every input/output into `components/schemas` can be impractical.

Without `components/schemas`, many code generators produce awkward type names (e.g., `ApiUsersIdPostRequest`, `ApiUsersIdPost200Response`). This often drives developers to use `Parameters<T>[index]` generic or avoid code generation and fall back to `fetch` or `axios` with manual casting.

Vovk.ts supports type inference for unnamed schemas. Even if the OpenAPI spec doesn't define `components/schemas`, Vovk.ts can infer input and output types using simple utilities.

```ts showLineNumbers copy
import { PetstoreAPI } from 'vovk-client';
import type { VovkBody, VovkQuery, VovkParams, VovkOutput } from 'vovk';

type Body = VovkBody<typeof PetstoreAPI.updatePet>;
type Query = VovkQuery<typeof PetstoreAPI.updatePet>;
type Params = VovkParams<typeof PetstoreAPI.updatePet>;
type Output = VovkOutput<typeof PetstoreAPI.updatePet>;
```

In the [Python](/python) client, types are exposed as TypedDicts.

```py
from vovk_client import PetstoreAPI

body: PetstoreAPI.UpdatePetBody = {}
query: PetstoreAPI.UpdatePetQuery = {}
params: PetstoreAPI.UpdatePetParams = {}
output: PetstoreAPI.UpdatePetOutput = {}
```

For the [Rust](/rust) client, types are generated as nested modules that contain structs and enums, following the same structure as the OpenAPI spec schemas via `_::` separator.

```rs
use vovk_client::petstore_api::update_pet_::{
    body as Body,
    body_::foo as Foo, // for nested data
    query as Query,
    params as Params,
    output as Output,
};
```

### Bundle

The [TypeScript](/typescript) artifacts can be bundled into an npm package using the `bundle` command after configuring `bundle.build` function (see [bundle page](/bundle)). It also creates `package.json` and `README.md` files, where the README outlines each method with self-documenting code samples. See the ["Hello World" example](/hello-world#bundle) for details.

To create a bundle, ensure `package.json` and `tsconfig.json` are present at the project root.

## Getting Started

### Using Standalone Codegen

If you’re using codegen as a standalone CLI (even without `package.json`), install **vovk-cli** globally or as a dev dependency. You can skip this section if you use Vovk.ts within a Next.js project.

```sh npm2yarn copy
npm install -g vovk-cli
```

Or install **vovk-cli** as a dev dependency and `vovk` and **vovk-ajv** as regular dependencies:

```sh npm2yarn copy
npm install -D vovk-cli
```

```sh npm2yarn copy
npm install vovk vovk-ajv
```

If you’re in another Node.js project and want to use the [composed client](/composed) (where all generated API clients are combined into a single client), install **vovk-client**. It re-exports files generated by Vovk.ts at the default path `node_modules/.vovk-client`.

```sh
npm install vovk-client
```

### Create Config File

Create a config file as described on the [config](/config) page to customize code generation results. Alternatively, use the `vovk-cli init` command:

```sh npm2yarn copy
npx vovk-cli init
```

A basic config file looks like this:

```ts showLineNumbers copy filename="vovk.config.js"
/** @type {import('vovk').VovkConfig} */
const config = {
  outputConfig: {
    imports: {
      validateOnClient: 'vovk-ajv',
    },
  },
};
export default config;
```

### Define OpenAPI mixins

Define a mixin as a pseudo-[segment](/segment) in `outputConfig.segments` by setting the `openAPIMixin` property. It accepts:

- `source`: an object with either `url` (remote specs), `path` (local specs), or `object` (inline specs). The `url` variant may include a `fallback` file path used if the remote URL is unreachable.
- `getModuleName`: a string or function to name generated API modules. The string can be any custom string for hard-coded module names.
- `getMethodName`: a string or function to generate method names. Supported strings: `camel-case-operation-id` (converts `operationId` like `get_users` to `getUsers`), or `auto` (generates from `operationId` or from HTTP method + path if `operationId` is unsuitable or missing).
- `apiRoot` (optional): the API root URL, overridable per call via the `apiRoot` option. Required if the OAS document has no `servers` property.

Petstore example with a remote URL and a local fallback:

```ts showLineNumbers copy filename="vovk.config.js"
/** @type {import('vovk').VovkConfig} */
const config = {
  outputConfig: {
    imports: {
      validateOnClient: 'vovk-ajv',
    },
    segments: {
      petstore: {
        openAPIMixin: {
          source: {
            url: 'https://petstore3.swagger.io/api/v3/openapi.json',
            fallback: './.openapi-cache/petstore.json',
          },
          getModuleName: 'PetstoreAPI',
          getMethodName: 'auto',
          apiRoot: 'https://petstore3.swagger.io/api/v3',
        },
      },
    },
  },
};
export default config;
```

This generates a single `PetstoreAPI` module with methods for each operation defined in the OpenAPI spec.

```ts showLineNumbers copy
import { PetstoreAPI } from 'vovk-client';

await PetstoreAPI.getPets({ query: { limit: 10 } });
```

When `getModuleName` or `getMethodName` are functions, they receive:

- `operationObject`: the Operation Object for the operation.
- `method`: the HTTP method (uppercase string).
- `path`: the operation path.
- `openAPIObject`: the entire OpenAPI document.

For a more advanced example, consider the [GitHub REST API](https://docs.github.com/en/rest). The `operationId` in the [GitHub OpenAPI spec](https://raw.githubusercontent.com/github/rest-api-description/main/descriptions/api.github.com/api.github.com.json) has the form `scope/operation` (e.g., `repos/remove-status-check-contexts`, `codespaces/list-for-authenticated-user`). We can use the first part to generate module names and the second part to generate method names via lodash.

For example, `issues/list-for-org` becomes the `GithubIssuesAPI` module with a `listForOrg` method.

```ts showLineNumbers copy filename="vovk.config.js"
// @ts-check
import camelCase from 'lodash/camelCase.js';
import startCase from 'lodash/startCase.js';

/** @type {import('vovk').VovkConfig} */
const config = {
  outputConfig: {
    imports: {
      validateOnClient: 'vovk-ajv',
    },
    segments: {
      github: {
        openAPIMixin: {
          source: {
            url: 'https://raw.githubusercontent.com/github/rest-api-description/main/descriptions/api.github.com/api.github.com.json',
            fallback: './.openapi-cache/github.json',
          },
          getModuleName: ({ operationObject }) => {
            const [operationNs] = operationObject.operationId?.split('/') ?? ['unknown'];
            return `Github${startCase(camelCase(operationNs)).replace(/ /g, '')}API`;
          },
          getMethodName: ({ operationObject }) => {
            const [, operationName] = operationObject.operationId?.split('/') ?? ['', 'ERROR'];
            return camelCase(operationName);
          },
        },
      },
    },
  },
};

export default config;
```

You may also want to loosen `ajv` options, as third-party OAS documents can contain non-standard keywords that cause validation errors.

```ts showLineNumbers copy filename="vovk.config.js"
// @ts-check
/** @type {import('vovk').VovkConfig} */
const config = {
  // ...
  libs: {
    /** @type {import('vovk-ajv').VovkAjvConfig} */
    ajv: {
      options: {
        strict: false,
      },
    },
  },
};

export default config;
```

### Customize Fetcher

You can customize the fetch function per mixin or use a single fetcher for all mixins. The [fetcher](/imports#fetcher) prepares authorization headers, performs client-side validation, and makes/handles HTTP requests.

```ts showLineNumbers copy filename="vovk.config.js"
/** @type {import('vovk').VovkConfig} */
const config = {
  outputConfig: {
    // ...
    segments: {
      petstore: {
        openAPIMixin: {
          /* ... */
        },
        imports: { fetcher: './src/lib/petstoreFetcher' },
      },
    },
  },
};
export default config;
```

### Composed Client

#### `mjs` + `cjs` (default)

By default, the [composed client](/composed) uses [mjs](/templates#mjs) and [cjs](/templates#cjs) templates to generate both ESM and CJS clients. They are emitted to `node_modules/.vovk-client` and importable as the **vovk-client** package.

```ts showLineNumbers copy
import { PetstoreAPI, GithubIssuesAPI, type Mixins } from 'vovk-client';

await PetstoreAPI.getPets({ query: { limit: 10 } });
await GithubIssuesAPI.listForOrg({ params: { org: 'finom' } });
```

The `Mixins` namespace contains types generated from `components/schemas` across all mixed OpenAPI specifications, providing an alternative to the inference.

```ts showLineNumbers copy
import { PetstoreAPI, type Mixins } from 'vovk-client';

const pet: Mixins.Pet = { id: 1, name: 'Doggo' };
// Alternatively:
const pet2: VovkOutput<typeof PetstoreAPI.getPet> = { id: 1, name: 'Doggo' };
```

#### `ts`

The [ts](/templates#ts) template generates an uncompiled TypeScript client that can be emitted directly into your codebase.

```ts showLineNumbers copy filename="vovk.config.js"
/** @type {import('vovk').VovkConfig} */
const config = {
  composedClient: {
    fromTemplates: ['ts'], // use 'ts' instead of 'mjs' and 'cjs'
    outDir: './src/lib/client', // emit to your codebase
    prettifyClient: true, // prettify the output
  },
};
export default config;
```

```ts showLineNumbers copy
import { PetstoreAPI, GithubIssuesAPI, type Mixins } from '../lib/client';
// ...
```

### Segmented Client

The [segmented client](/segmented) splits code into multiple chunks, placing each mixin in a folder named after its segment (`petstore`, `github`, etc., from `outputConfig.segments`).

By default, output goes to `src/client`. You can change the folder via `segmentedClient.outDir`.

```ts showLineNumbers copy filename="vovk.config.js"
/** @type {import('vovk').VovkConfig} */
const config = {
  segmentedClient: {
    outDir: './src/lib/client', // emit to your codebase
    prettifyClient: true, // prettify the output
  },
};
export default config;
```

```ts showLineNumbers copy
import { PetstoreAPI, type Mixins as PetstoreMixins } from '@/lib/client/petstore';
import { GithubIssuesAPI, type Mixins as GithubMixins } from '@/lib/client/github';
// ...
```

This approach also generates an alternative OAS document that includes [Scalar](https://scalar.com/)-compatible code samples.

```ts showLineNumbers copy
import { openapi as petstoreOpenAPI } from '@/lib/client/petstore/openapi';
import { openapi as githubOpenAPI } from '@/lib/client/github/openapi';
console.log(petstoreOpenAPI, githubOpenAPI);
```
