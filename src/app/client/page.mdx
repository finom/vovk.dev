import { Callout } from 'nextra/components'

# Generated RPC-ish client

TODO - Client method accepts `fetcher` and `validateOnClient` options.

```sh filename="bash"
npx vovk generate
```

`vovk generate` (as well as [vovk dev](/cli/vovk-dev)) command creates client library that is generated from [schema](/schema). By default the files are stored in the **node_modules/.vovk-client/** folder (can be changes at [config](/config)) and re-exported by **vovk-client** package. 

It creates 3 files:

- **index.ts** - an "uncompiled" TypeScript file. Used rarely but useful if code is generated to the root of the project. See [vovk-examples](https://github.com/finom/vovk-examples).
- **compiled.js** - a "compiled" JavaScript file.
- **compiled.d.ts** - TypeScript definitions.

TODO: Tabs with generated examples + route.ts

As you can see all the files export one variable per controller or worker and their functionality is built from the [schema](/schema) and types exported from **route.ts** file, making the client library type-safe and very compact in size for production use.

The code for these files is built using [EJS](https://www.npmjs.com/package/ejs) templates instead of AST, making the generation take not more than a couple of milliseconds (takes more if `prettifyClient` is set to `true` in the config). The templates are located in the **client-templates** folder of [vovk-cli](/cli) package.

The variables re-exported from **vovk-client** package is plain old JavaScript with typings that calls the regular `fetch` function.

```ts
import { UserRPC } from 'vovk-client';

// ...

const updatedUser = await UserRPC.updateUser({
    body: { firstName, lastName },
    query: { role: 'admin' },
    params: { id },
});

// same as
fetch(`/api/users/${id}?role=admin`, {
    method: 'PUT',
    body: JSON.stringify({ firstName, lastName }),
});
```

If you don't like the naming convention of the generated client library, you can change it in the **route.ts** file.

```ts
// ...
const controllers = { 
    users: UserController 
};
// ...
```

The client import may look like this:

```ts
import * as api from 'vovk-client';

await api.users.updateUser({
    // ...
});
```

The client library's fetching function, as well as its types [can be customised](/client/customization) in order to follow logic required by the application.

```ts
await UserRPC.updateUser({
    // ...
    successMessage: 'Successfully updated the user',
    someOtherCustomFlag: true,
});
```

## Type override

In case if your code makes it impossible to recognise the return type, you can override it manually with no need to convert it to `unknown` first.

```ts
import { UserRPC } from 'vovk-client';
import type { SomeType } from '../types';

// ...

// Override the return type
const updatedUser = await UserController.updateUser<SomeType>(/* ... * /);
```

## Async iterable

```ts
// ...
export default class MyController {
    @get()
    static async *doSomething(/* ... */) {
        yield* iterable;
    }
}
```

If iterable is returned, the client library is going to cast the method as a disposable async generator to implement response streaming. It's explained in more details on the [JSON streaming documentation page](/streaming).

## Custom client

The [dev command](/cli/vovk-dev) creates [schema](/schema) files represented as JSON files. The generic way to build a custom client is to read the files of the schema output directory (by default **.vovk-schema**) and build the client library based on them.

Good news is that Vovk.ts also provides an experimental way to generate a completely custom client library, including a client for a different programming language. Since the client is generated from [ejs](https://www.npmjs.com/package/ejs) templates, you can implement your own templates and generate a client library that fits your needs. Please refer to the [vovk generate](/cli/vovk-generate) documentation page for more details.