import { Callout } from 'nextra/components'

# Segment

```sh filename="Create root segment with CLI"
npx vovk new segment # create root segment
npx vovk new segment admin # create "admin" segment
```

[`vovk new` documentation](/cli/vovk-new)

[Controllers](/controller) are initialised at a ["Optional Catch-all Segment"](https://nextjs.org/docs/pages/building-your-application/routing/dynamic-routes#optional-catch-all-segments) defined as **route.ts** file in **/src/app/api/[[...slug]]/** for root segment or **/src/app/api/`segment-name`/[[...slug]]/** folder for multi-segment apps (**[[...slug]]** is the folder name). It exports [route handlers](https://nextjs.org/docs/app/building-your-application/routing/route-handlers) such as `GET`, `POST` etc, created by `initVovk` function. The file can also export any of the Next.js [segment config options](https://nextjs.org/docs/app/building-your-application/routing/route-handlers#segment-config-options) such as `runtime` or `maxDuration` to determine behaviour of the Next.js route.

<Callout type="info" emoji="ℹ️">
  You can change the API folder name from `api` to any other name by modifying [config](/config) option `rootEntry`.
</Callout>

Besides the Next.js variables it's important to also export `Controller` type that is used to type the generated RPC library.

[The code generator](/cli/vovk-new) as well as this documentation uses "vovk" as the slug name but it can be called in any way since it's never used to determine something in the code.

Here is an example of a **route.ts** file for a single-segment app:

```ts filename="/src/app/api/[[...slug]]/route.ts"
import { initVovk } from 'vovk'
import UserController from '../../modules/user/UserController';
import PostController from '../../modules/post/PostController';

// run code on the edge network — distributed globally across multiple data centers
export const runtime = 'edge';

// maximum duration of request in seconds, useful for AI apps
export const maxDuration = 300;

const controllers = {
    UserRPC: UserController,
    PostRPC: PostController,
};

export type Controller = typeof controllers;

export const { GET, POST, PUT, DELETE } = initVovk({
    controllers,
});
```

[Schema](/schema) for the root segment is going to be stored as **.vovk-schema/segments/_root.json** file.

With the root segment as the only segment, the back-end code of the app is going to be bundled into a single serverless function. In most of cases it's enough to have only the root segment.

## Multiple segments

You can create multiple segments in your app to split the back-end code into multiple serverless functions. There might be multiple reasons for that:

- Split the back-end code into multiple serverless functions to reduce the size of the function bundle.
- Divide the back-end code into multiple areas e. g. `admin`, `user`, `public` etc.
- Support different versions of the same API (e.g. v1, v2).
- Create a static segment explained on the next page for OpenAPI or other purposes.

Each segment is located in a nested folder determining the API path and the segment name. For example, a segment located in **/src/app/api/`segment-name`/[[...slug]]/** folder is going to be served at **/api/`segment-name`** path. The level of nesting is unlimited. 

For non-root segments `initVovk` function requires to provide segment name as `segmentName` option. By default it's an empty string that means the root segment.

```ts filename="/src/app/api/foo/[[...slug]]/route.ts"
// ...

export const { GET, POST, PUT, DELETE } = initVovk({
    segmentName: 'foo',
    controllers,
});
```

The schema for the segment `foo` is going to be stored as **.vovk-schema/segments/`foo`.json** file.

For segments of deeper nesting (let's say **/src/app/api/`foo/bar/baz`/[[...slug]]/**) the segment name is going to be `foo/bar/baz` and the schema is going to be stored as **.vovk-schema/segments/`foo/bar/baz`.json** file.

## Segment priority

In case if you have multiple segments, more nested one is going to have higher priority. For example, if you have the following segments:

- **/src/app/api/[[...slug]]/** for the root segment
- **/src/app/api/foo/[[...slug]]/** for `foo` segment
- **/src/app/api/foo/bar/[[...slug]]/** for `foo/bar` segment

Then request to **/api/foo/bar** is going to have the highest priority and is going to be handled by the `foo/bar` segment. If the request doesn't match the `foo/bar` segment but matches the `foo` segment, it's going to be handled by the `foo` segment. If the request doesn't match the `foo` segment, it's going to be handled by the root segment.
