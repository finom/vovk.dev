# Decorators and metadata

The purpose of controller decorators is to provide a way to extend the functionality of controller methods. They can be used to implement cross-cutting concerns, such as logging, caching, validation, and authorization. They also allow to add custom metadata to the handler, which can be used for various purposes, such as identifying authorized users.

`createDecorator` is a higher-order function that produces a decorator factory (a function that returns a decorator) for controller class methods. It accepts a middleware function with the following parameters:

- `request`, which extends [VovkRequest](/controller/request). It provides `req.vovk.meta` method to get and set metadata for the request object to share data between decorators and the route handler.
- `next`, a function that should be invoked and its result returned to call subsequent decorators or the route handler.
- Additional arguments are passed through to the decorator factory.

The second argument of `createDecorator` is an optional init handler. It's called every time when decorator is initialised and it's purpose is to populate **.vovk-schema/segments/\*.json** with validation or custom data. It can return an object with optional keys `"validation"`, `"openapi"` and `"custom"` that will be merged with the handler schema or a function that returns the object and receives the existing handler schema as an argument for proper merging.

```ts
import { createDecorator, get, HttpException, HttpStatus } from 'vovk';

interface ReqMeta {
  foo: string;
}

const myDecorator = createDecorator(
  (req, next, a: string, b: number) => {
    console.log(a, b); // Outputs: "foo", 1

    if (isSomething) {
      req.vovk.meta<ReqMeta>({ foo: 'bar' }); // Add metadata to the request object
      // override route method behavior and return { hello: 'world' } from the endpoint
      return { hello: 'world' };
    }

    if (isSomethingElse) {
      // throw HTTP error if needed
      throw new HttpException(HttpStatus.BAD_REQUEST, 'Something went wrong');
    }

    // continue to the next decorator or the route handler
    return next();
  },
  (a: string, b: number) => {
    console.info('Decorator is initialised with', a, b);
    return {
      validation: {
        /* ... */
      },
      custom: { a, b },
    };
  }
);

export default class MyController {
  @get.auto()
  @myDecorator('foo', 1) // Passes 'foo' as 'a', and 1 as 'b'
  static doSomething() {
    // ...
  }
}
```

## Examples

### Vercel cron jobs

In order to create a cron job on Vercel, you can create a decorator that checks authorization header with a secret key defined as `CRON_SECRET` in the environment variable.

```ts filename="/src/decorators/cronGuard.ts"
import { HttpException, HttpStatus, createDecorator } from 'vovk';

const cronGuard = createDecorator(async (req, next) => {
  if (req.headers.get('authorization') !== `Bearer ${process.env.CRON_SECRET}`) {
    throw new HttpException(HttpStatus.UNAUTHORIZED, 'Unauthorized');
  }

  return next();
});

export default cronGuard;
```

```ts filename="/src/modules/cron/CronController.ts"
import { get, prefix } from 'vovk';
import cronGuard from '../decorators/cronGuard';

@prefix('cron')
export default class CronController {
  @get('do-something')
  @cronGuard()
  static async doSomething() {
    // ...
  }
}
```

Add the cron job to the `vercel.json` file. The `schedule` field uses the cron syntax (at this case the cron job will run every day at midnight). Read more about [Vercel cron jobs](https://vercel.com/docs/cron-jobs).

```json filename="/vercel.json"
{
  "crons": [
    {
      "path": "/api/cron/do-something",
      "schedule": "0 0 * * *"
    }
  ]
}
```

### Authorization with RBAC

The `authGuard` decorator below does the following:

- Checks if a user is authorised and returns an `Unauthorised` status if not.
- Adds `currentUser` to the request metadata object, represented as `AuthMeta` interface, to make it accessible in the controller.
- Adds a custom `x-permission` field to the OpenAPI operation object.
- Implements role-based access control with `Permission` enum.

```ts filename="/src/decorators/authGuard.ts"
import { createDecorator, HttpException, HttpStatus, type VovkRequest } from 'vovk';
import { User } from '@prisma/client';

export enum Permission {
  CAN_DO_THIS = 'CAN_DO_THIS',
  CAN_DO_THAT = 'CAN_DO_THAT',
}

// Metadata interface allows to access the currentUser in the controller
export interface AuthMeta {
  currentUser: User;
}

// Create a function that identifies the user, checks permissions and updates the request metadata
const checkAuth = async (req: VovkRequest, permission: Permission) => {
  const currentUser = identifyUserSomehowAndCheckPermissions(req, permission);

  if (!currentUser) {
    return false;
  }

  // Add currentUser to the request metadata
  req.vovk.meta<AuthMeta>({ currentUser });

  return true;
};

// Create the decorator
const authGuard = createDecorator(
  async (req, next, permission: Permission) => {
    const isAuthorized = await checkAuth(req, permission);

    if (!isAuthorized) {
      throw new HttpException(HttpStatus.UNAUTHORIZED, 'Unauthorized');
    }

    return next();
  },
  (permission) => {
    // Add the permission to the OpenAPI operation object
    return (handlerMetadata) => ({
      ...handlerMetadata,
      openapi: {
        ...handlerMetadata?.openapi,
        'x-permission': permission, // just an example
      },
    });
  }
);

export default authGuard;
```

Usage:

```ts filename="/src/modules/user/UserController.ts"
import { get, prefix } from 'vovk';
import { openapi } from 'vovk-openapi';
import authGuard, { Permission, type AuthMeta } from '../decorators/authGuard';

@prefix('users')
export default class UserController {
  // ...
  @openapi({
    summary: 'Get something',
    description: 'Returns something',
  })
  @get('something')
  @authGuard(Permission.CAN_DO_THIS)
  static async getSomething(req: VovkRequest) {
    const { currentUser } = req.vovk.meta<AuthMeta>();
    // ...
  }

  // ...
}
```
