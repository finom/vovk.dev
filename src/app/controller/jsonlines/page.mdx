import { JSONLinesExample } from '../../../components/vovk-examples';
import { Suspense } from 'react';

# JSON Lines Streaming

<div className="example">
  <JSONLinesExample />
</div>

Vovk.ts includes first-class support for the [JSON Lines](https://jsonlines.org/) format, which is a convenient way to implement "one request - many responses". It's perfect for LLM completions and also opens up new possibilities for experiments, such as [progressive responses](/controller/progressive) and [polling](/polling). JSON Lines is another output type that uses the `iteration` validation field and produces the `application/jsonl` content type if the client side sends an `Accept: application/jsonl` header. If the `Accept` header doesn't include `application/jsonl`, the output is returned as `text/plain` to be viewable when the endpoint URL is opened directly in a browser.

```ts
import { z } from 'zod';
import { prefix, post, type VovkIteration } from 'vovk';
import { withZod } from 'vovk-zod';

@prefix('stream')
export default class StreamController {
  @post('completions')
  static getJSONLines = withZod({
    // ...
    iteration: z.object({
      message: z.string(),
    }),
    async handle() {
      const tokens: VovkIteration<typeof StreamController.getJSONLines>[] = [
        { message: 'Hello,' },
        { message: ' World' },
        { message: ' from' },
        { message: ' Stream' },
        { message: '!' },
      ];

      for (const token of tokens) {
        await new Promise((resolve) => setTimeout(resolve, 300));
        yield token;
      }
    },
  });
}
```

When used with a [service](./service), the iterable can be delegated using the `yield*` syntax:

```ts filename="src/modules/stream/StreamController.ts"
import { prefix, post, type VovkIteration } from 'vovk';
import StreamService from './StreamService';

@prefix('stream')
export default class StreamController {
  @post('completions')
  static getJSONLines = withZod({
    // ...
    iteration: z.object({
      message: z.string(),
    }),
    async *handle() {
      yield* StreamService.getJSONLines();
    },
  });
}
```

```ts filename="src/modules/stream/StreamService.ts"
import type { VovkIteration } from 'vovk';
import type { StreamController } from './StreamController';

export default class StreamService {
  static async *getJSONLines() {
    const tokens: VovkIteration<typeof StreamController.getJSONLines>[] = [
      { message: 'Hello,' },
      { message: ' World' },
      { message: ' from' },
      { message: ' Stream' },
      { message: '!' },
    ];

    for (const token of tokens) {
      await new Promise((resolve) => setTimeout(resolve, 300));
      yield token;
    }
  }
}
```

On the client side, the JSON Lines output can be consumed using [disposable](https://github.com/tc39/proposal-explicit-resource-management) [async iterators](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/AsyncIterator), allowing you to process each line as it arrives:

```ts
import { StreamRPC } from 'vovk-client';

using stream = await StreamRPC.getJSONLines();

for await (const { message } of stream) {
  console.log('Received message:', message);
}
```

<a name="jsonlinesresponse" />
## `JSONLinesResponse` Class

If generators aren't suitable for JSON streaming in a particular case, you can use the `JSONLinesResponse` class, which inherits from the `Response` class and uses `TransformStream#readable` as the response body.

This is a lower-level API that is used behind the scenes to implement the generator logic described above.

A service method in this case is implemented as a regular function that accepts a `JSONLinesResponse` instance as a pointer to send messages manually.

Here's what the streaming service might look like:

```ts filename="src/modules/stream/StreamService.ts"
import type { JSONLinesResponse } from 'vovk';

export type Token = { message: string };

export default class StreamService {
  static async streamTokens(resp: JSONLinesResponse<Token>) {
    const tokens: Token[] = [{ message: 'Hello,' }, { message: ' World' }, { message: '!' }];

    for (const token of tokens) {
      await new Promise((resolve) => setTimeout(resolve, 300));
      resp.send(token);
    }

    resp.close();
  }
}
```

As you can see, tokens are sent using the `JSONLinesResponse#send` method, and when the stream is completed, it needs to be closed with `JSONLinesResponse#close`.

The controller class returns an instance of `JSONLinesResponse`, and the streaming is performed in a floating Promise above the `return` statement.

```ts
import { prefix, get, JSONLinesResponse, type VovkRequest } from 'vovk';
import StreamService, { type Token } from './StreamService';

@prefix('stream')
export default class StreamController {
  @get('tokens')
  static async streamTokens(req: Request) {
    const resp = new JSONLinesResponse<Token>(req);

    void StreamService.streamTokens(resp);

    return resp;
  }
}
```

The `JSONLinesResponse` class also provides a `throw` method that safely closes the stream and causes the client to re-throw the received error.

```ts
await resp.throw(new Error('Stream error'));
```