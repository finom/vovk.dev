import { Callout } from 'nextra/components';

# `VovkRequest` Type

The request object accepted by controller methods is represented by the `VovkRequest` type. It extends the `NextRequest` type from Next.js by defining input `body` and `query` (as well as `params`, see below) types. You can use it to strictly type built-in response methods like `req.json()` and `req.nextUrl.searchParams`, which are originally loosely typed as `any` and `string | null`.

```ts
import { put, type VovkRequest } from 'vovk';

export default class UserController {
  @put('{id}')
  static async updateUser(req: VovkRequest<{ foo: 'foo' }, { bar: 'bar' }>, { id }: { id: string }) {
    const data = await req.json(); // data type is { foo: 'foo' }
    const bar = req.nextUrl.searchParams.get('bar'); // bar type is 'bar'
    // ...
  }
}
```

[Validation libraries](/validation) define the request type themselves, so you don't usually need to use `VovkRequest` manually.

Also note the second argument of the handler method. It is used to define the type of parameters extracted from the request URL.

### `req.vovk`

To avoid modifying the original `NextRequest` object, Vovk introduces the `req.vovk` object, which contains additional utilities for request processing. Validation libraries (like [vovk-dto](/validation/dto)) can override these functions to return a different type.

### `async req.vovk.body()`

The `req.vovk.body` function returns the request body serialized as an object. In most cases, it behaves the same as the `req.json()` method.

```ts
import { post, type VovkRequest } from 'vovk';
export default class UserController {
  @post()
  static async createUser(req: VovkRequest<{ foo: string }>) {
    const body = await req.vovk.body(); // body type is { foo: string }
    // ...
  }
}
```

### `req.vovk.query()`

The `req.vovk.query` function returns serialized query parameters of the request.

```ts
import { get, type VovkRequest } from 'vovk';
export default class UserController {
  @get()
  static async getUser(req: VovkRequest<null, { id: string }>) {
    const query = req.vovk.query(); // query type is { id: string }
    // ...
  }
}
```

#### Nested Queries

Nested data is serialized as a query string with square brackets. This is commonly known as "PHP-style query string notation" or "bracket notation".

In this notation:

- Square brackets `[ ]` are used to denote keys for arrays or nested objects.
- Sequential numeric indices (e.g., `[0]`, `[1]`) represent array elements.
- Named keys (e.g., `[f]`, `[u]`) represent properties of an object.
- The structure can be nested to arbitrary depth, allowing for complex hierarchical data.

The following query string:

```
?simple=value&array[0]=first&array[1]=second&object[key]=value&nested[obj][prop]=data&nested[arr][0]=item1&nested[arr][1]=item2&complex[items][0][name]=product&complex[items][0][price]=9.99&complex[items][0][tags][0]=new&complex[items][0][tags][1]=featured
```

Is parsed as:

```ts
{
  simple: "value",
  array: ["first", "second"],
  object: {
    key: "value"
  },
  nested: {
    obj: {
      prop: "data"
    },
    arr: ["item1", "item2"]
  },
  complex: {
    items: [
      {
        name: "product",
        price: "9.99",
        tags: ["new", "featured"]
      }
    ]
  }
}
```

### `req.vovk.params()`

The `req.vovk.params` function returns serialized parameters of the request. To define proper typing for it, you need to use the third generic argument for the `VovkRequest` type.

```ts
import { get, type VovkRequest } from 'vovk';

export default class UserController {
  @get('{id}')
  static async getUser(req: VovkRequest<null, null, { id: string }>) {
    const params = req.vovk.params(); // params type is { id: string }
    // ...
  }
}
```

### `async req.vovk.form()`

The `req.vovk.form` function returns the `FormData` of the request serialized as an object. It's a type-safe alternative to `req.formData()` that reads form data and uses `Object.fromEntries(formData.entries())` to convert it to a normal object. The generic argument defines the shape of the form data.

```ts
interface Data {
  foo: string;
  bar: string;
  file: File;
}

const formDataObject = await req.vovk.form<Data>();

// the same as
// const body = await req.formData();
// const formDataObject = Object.fromEntries(body.entries()) as Data;
```

When [validation](/validation) libraries are used with the `isForm` option, the `req.vovk.form` method will be typed automatically with no need to specify the generic parameter.

### `req.vovk.meta()`

The `req.vovk.meta` function allows you to get and set the meta value of the request. The only argument is optional and, if provided, sets meta information by extending the existing meta information. It returns the current meta value. To define the type of the meta value, you need to pass a generic type.

```ts
interface RequestMeta {
  foo: string;
  bar: string;
  currentUser: User;
}

// set foo and bar meta information
req.vovk.meta<RequestMeta>({ foo: 'foo', bar: 'bar' });

// set currentUser meta information
req.vovk.meta<RequestMeta>({ currentUser: user });

// get meta information
const meta = req.vovk.meta<RequestMeta>(); // meta type is RequestMeta including foo, bar, and currentUser
```

The metadata is usually set in a custom [decorator](/controller/decorator) and read in the controller method. Read more about it in the [meta documentation](/controller/meta).