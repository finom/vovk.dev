import { Callout } from 'nextra/components';

# Controller

```sh filename="Create a new controller with CLI"
# without service class
vovk new controller user # create user controller for the root segment
vovk new controller admin/user # create user controller for the "admin" segment

# with service class
vovk new controller service user # create user controller and service for the root segment
vovk new controller service admin/user # create user controller and service for the "admin" segment
```

[`vovk new` documentation](/cli/new)

## Definition

Controller is a static class (a class that has static methods only and it's never instantiated) that handles incoming HTTP requests.

Methods of this class, that are decorated with an HTTP decorator (like `@get()` or `@post()`), accept 2 arguments: [VovkRequest](/controllers/request) (that is inherited from `NextRequest`) and parameters that are defined by the decorator path.

`NextRequest` type doesn't provide any information about the request body or query parameters, so the body is casted as `any` and query parameters are casted as `string | null`.

```ts
import type { NextRequest } from 'next';
import { prefix, put } from 'vovk';

@prefix('users')
export default class UserController {
  // Example request: PUT /api/users/69?role=moderator
  @put(':id')
  static async updateUser(req: NextRequest, { id }: { id: string }) {
    const data = await req.json(); // any
    const userRole = req.nextUrl.searchParams.get('role'); // string | null
    // ...
    return updatedUser;
  }
}
```

To add the required body and query types you need replace `NextRequest` by `VovkRequest` and define the types as generic arguments.

```ts filename="src/modules/user/UserController.ts"
import { prefix, put, type VovkRequest } from 'vovk';
import type { User } from '../../types';

@prefix('users')
export default class UserController {
  // Example request: PUT /api/users/69?role=moderator
  @put(':id')
  static async updateUser(
    req: VovkRequest<Partial<User>, { notify: 'email' | 'push' | 'none' }>,
    { id }: { id: string }
  ) {
    const data = await req.json(); // Partial<User>
    const notify = req.nextUrl.searchParams.get('notify'); // 'email' | 'push' | 'none'
    // ...
    return updatedUser;
  }
}
```

<Callout type="info" emoji="ℹ️">
  Hint: to make sure that the class is never instantiated, you can make it abstract.

```ts
export default abstract class UserController {
  /* ... */
}
```

</Callout>

As you can see we've changed nothing more than the type of `req` but now `data` receives type of `Partial<User>` and `userRole` is casted as `'user' | 'moderator' | 'admin'` and does not extend `null` anymore.

## Initialization

Once the controller is defined it needs to be initialized at the wildcard route (we call it "segment") by adding it to the `controllers` object. The key is the name of the resulting library variable exported from `"vovk-client"`. Read more about that in the [client](/client) section.

```ts filename="src/app/api/[[...vovk]]/route.ts"
import { initVovk } from 'vovk';
import UserController from '../../../modules/user/UserController';

const controllers = {
  UserRPC: UserController,
};

export type Controllers = typeof controllers;

export const { GET, POST, PUT, DELETE } = initVovk({ controllers });
```

This will make the `UserRPC` fetch library available at **vovk-client**.

```ts
import { UserRPC } from 'vovk-client';

const updatedUser = await UserRPC.updateUser({
  query: { notify: 'push' },
  params: { id: '69' },
  body: { ...userData },
});
```

## Auto-generated endpoints

All HTTP decorators provide `.auto` method that generates endpoint name automatically from the method name.

```ts filename="src/modules/user/UserController.ts"
import { prefix, put } from 'vovk';

@prefix('users')
export default class UserController {
  // Example request: PUT /api/users/do-something
  @put.auto()
  static async doSomething(/* ... */) {
    // ...
  }
}
```

Since the client is generated automatically, if your REST API is used internally only, you can use auto-generated endpoints to save a little bit of time thinking of a new endpoint name.


TODO FormData for controller
