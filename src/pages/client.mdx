import { Callout } from 'nextra/components'

# Generated RPC-ish client

```sh filename="bash"
npx vovk generate
```

`vovk generate` (as well as [vovk dev](/cli/vovk-dev)) command generates a client library that can be used in the client-side code from [controllers](/controller) and [workers](/worker) that be used in any environment that supports `fetch` function (including back-end).



{/*
TODO npm install

```sh filename="bash"
npx vovk generate
```

## RPC library

<Callout type="warning" emoji="⚠️">
    **Workaround notice**. In order to identify arrays, [RPC methods](/client) use a custom parameter `_vovkarr`. See [request documentation](/controller/request) for more information.
</Callout>


`initVovk` performs required actions to generate client-side library and no additional action from your side is required (but you probably would need to restart TS Server to update types if you use VSCode when a new controller is added).

Name of an RPC library is defined by the key in the `controllers` object. The key is used to import the library in the client code.

```ts filename="/src/app/api/[[...vovk]]/route.ts"
// ...
const controllers = { 
    UserRPC: UserController 
};
// ...
export const { GET } = initVovk({ controllers });
```

The client library implements same-named methods but changes the method signature so you can pass required input data as options (`body`, `query` and `params`). **vovk-client** can be used in client components, server components, application state and even be distributed as a standalone package. For an illustration [vovk-examples](https://github.com/finom/vovk-examples) is published as a [standalone NPM package](https://www.npmjs.com/package/vovk-examples) to be used on [vovk.dev](https://vovk.dev) that, by itself, is a static website powered by gh-pages.

Everything exported from **vovk-client** is plain old JavaScript with typings that calls the regular `fetch` function.

```ts
import { UserRPC } from 'vovk-client';

// ...

const updatedUser = await UserRPC.updateUser({
    body: { firstName, lastName },
    query: { role: 'admin' },
    params: { id },
});

// same as
fetch(`/api/users/${id}?role=admin`, {
    method: 'PUT',
    body: JSON.stringify({ firstName, lastName }),
});
```

The naming convention isn't strict and can be changed to fit the application's needs. For example `UserRPC` can be renamed to `users` or any other appropriate name.

```ts filename="/src/app/api/[[...vovk]]/route.ts"
// ...
const controllers = { 
    users: UserController 
};
// ...
```

The client import may look like this:

```ts
import * as api from 'vovk-client';

await api.users.updateUser({
    // ...
});
```

The generated client library [can be customised](/customization) in order to follow custom logic required by the application.

```ts
 await UserRPC.updateUser({
    // ...
    successMessage: 'Successfully created the user',
    someOtherCustomFlag: true,
});
```

## Behind the scenes

The client library is generated at **node_modules/.vovk-client/** and re-exported from **vovk-client** package. The folder contains 3 files:

- **index.ts** - uncompiled TypeScript file. Used rarely but useful if code is generated to the root of the project. See [vovk-examples](https://github.com/finom/vovk-examples).
- **compiled.js** - compiled JavaScript file. Used by the client.
- **compiled.d.ts** - TypeScript definitions. Used by the client.

TODO add example of generated client library
TODO describe all client options

## Type Override (MOVE TO CLIENT SECTION)

In case if your code makes it impossible to recognise the return type, you can override it manually with no need to convert it to `unknown` first.

```ts
import { UserRPC } from 'vovk-client';
import type { SomeType } from '../types';

// ...

// Override the return type
const updatedUser = await UserController.updateUser<SomeType>(/* ... * /);
```

## Async iterable

```ts
// ...
static async *updateUser(/* ... * /) {
    // ...
    yield* iterable;
}
// ...
```

If iterable is returned, the client library is going to cast the method as a disposable async generator to implement response streaming. It's explained in more details on the [Text Streaming documentation page](/streaming).
*/}