
import { Tabs } from 'nextra/components';
import StreamController from '../downloaded-examples/stream/StreamController.mdx';
import StreamExample from '../downloaded-examples/stream/StreamExample.mdx';
import LiveStreamExample from '../live-examples/LiveStreamExample';

# Text Streaming for LLMs

## Text Streaming Live Example

<div className="doc-live-example">
    <LiveStreamExample />
</div>
<Tabs items={['Controller', 'Component']}>
  <Tabs.Tab><StreamController /></Tabs.Tab>
  <Tabs.Tab><StreamExample /></Tabs.Tab>
</Tabs>

[Source code](https://github.com/finom/vovk-examples)

## Async Iterators

Controller methods can implement generators that use `*` syntax and utilise `yield` keyword instead of regular `return`.

```ts filename="/src/modules/stream/StreamController.ts"
import { get, prefix } from 'vovk';

type Token = { message: string };

@prefix('stream')
export default class StreamController {
  @get('tokens')
  static async *streamTokens() {
    const tokens: Token[] = [
      { message: 'Hello,' },
      { message: ' World' },
      { message: '!' },
    ];

    for (const token of tokens) {
      await new Promise((resolve) => setTimeout(resolve, 300));
      yield token;
    }
  }
}
```

In order to refactor this code and utilise Back-end Service you can move the streaming logic to `StreamService` static class.

```ts filename="/src/modules/stream/StreamService.ts"
type Token = { message: string };

export default class StreamService {
  static async *streamTokens() {
    const tokens: Token[] = [
      { message: 'Hello,' },
      { message: ' World' },
      { message: '!' },
    ];

    for (const token of tokens) {
      await new Promise((resolve) => setTimeout(resolve, 300));
      yield token;
    }
  }
}
```

At the controller use `yield*` syntax to delegate iterable returned from `StreamService.streamTokens`.

```ts filename="/src/modules/stream/StreamController.ts"
import { get, prefix } from 'vovk';
import StreamService from './StreamService';

@prefix('stream')
export default class StreamController {
  @get('tokens')
  static async *streamTokens() {
    yield* StreamService.streamTokens();
  }
}
```

## Handling Stream Responses on the Client

Text response streaming (including usage of `StreamResponse` class) generate client method that returns a disposable async generator. 

```ts
import { StreamController } from 'vovk-client';

{
    using stream = await StreamController.streamTokens();

    for await (const token of stream) {
        console.log(token);
    }
}
```

`using` keyword (that you can freely replace by `let` or `const`) indicates that when code block is reached the end (in case of early `break` or if the code block encountered an error) the stream is going to be closed by invoking `stream.close()` method automatically. `stream.close()` can also be called explicitly if needed.

To make sure that the stream is closed before moving to the next code block you can use `await using` syntax that disposes the stream asynchronous way.

```ts
import { StreamController } from 'vovk-client';

{
    await using stream = await StreamController.streamTokens();
    // ...
}
// on this line stream is already closed
```