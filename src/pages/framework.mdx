import { FileTree, Callout } from 'nextra/components'


# Project Framework

This page explains how you could structure an application introducing a framework that you can optionally apply to a large project that uses Vovk.ts.

The framework combines back-end and front-end code into a single code base. The logical parts of the app are split into folders called "modules" given them corresponding name such as user, post, comment, app settings, auth features etc. Basically, a "module" can belong to 2 categories:

1. An entity (a model) like "user" (or "post", "comment" etc).
1. Anything what doesn't belong to some specific entity: app settings, auth, AI stuff... 

The typical structure of files and folders in a Vovk.ts app would look like that:

<FileTree>
  <FileTree.Folder name="src" defaultOpen>
    <FileTree.Folder name="modules" defaultOpen>
        <FileTree.Folder name="hello" defaultOpen>
            <FileTree.File name="HelloState.ts" />
            <FileTree.File name="HelloService.ts" />
            <FileTree.File name="HelloIsomorphicService.ts" />
            <FileTree.File name="HelloWorker.ts" />
            <FileTree.File name="HelloState.ts" />
        </FileTree.Folder>
        <FileTree.Folder name="app" defaultOpen>
            <FileTree.File name="AppState.ts" />
            <FileTree.File name="AppState.ts" />
        </FileTree.Folder>
        <FileTree.Folder name="auth" defaultOpen>
            <FileTree.File name="AuthState.ts" />
            <FileTree.File name="AuthService.ts" />
            <FileTree.File name="AuthController.ts" />
        </FileTree.Folder>
        <FileTree.Folder name="user" defaultOpen>
            <FileTree.File name="UserState.ts" />
            <FileTree.File name="UserService.ts" />
            <FileTree.File name="UserController.ts" />
            <FileTree.File name="UserIsomorphicService.ts" />
        </FileTree.Folder>
        <FileTree.Folder name="post" defaultOpen>
            <FileTree.File name="PostState.ts" />
            <FileTree.File name="PostService.ts" />
            <FileTree.File name="PostIsomorphicService.ts" />
            <FileTree.File name="PostController.ts" />
        </FileTree.Folder>
        <FileTree.Folder name="comment" defaultOpen>
            <FileTree.File name="CommentState.ts" />
            <FileTree.File name="CommentService.ts" />
            <FileTree.File name="CommentController.ts" />
        </FileTree.Folder>
        
    </FileTree.Folder>
  </FileTree.Folder>
</FileTree>

Every item in a module folder (Service Class, Controller Class, state etc) is optional. Some parts of your app would require to have state only, but no controller. 
In other case you can have a state and a controller, but database request in your controller is too simple to create a separate service class...

The image below illustrates how different components of the application can be related to each other.

<img src="vovk-framework.svg" className="dark:invert" />

## Controller Class

Controller Class is a static class that defines API endpoints. It can use Back-End Service Classes and Isomorphic Service Classes explained below.

```ts
// /src/modules/post/PostController.ts
import { prefix, get } from 'vovk';
import PostService from './PostService';

@prefix('post')
export default class PostController {    
    @get()
    static getPosts() {
        return PostService.getPosts();
    }
}
```

Decorators created with `createDecorator` make possible to validate request, throw errors, redirect, or return something different to the client.

```ts
// /src/modules/post/PostController.ts
import { prefix, get, type VovkRequest } from 'vovk';
import vovkZod from 'vovk-zod';
import { z } from 'zod';
import { authGuard } from '../../decorators';
import PostService from './PostService';

@prefix('post')
export default class PostController {    
    @put(':postId')
    @authGuard()
    @vovkZod(
        z.object({
            title: z.string()
            content: z.string(),
        }).strict(),
        z.object({
            moderationType: z.string(),
        }).strict()
    )
    static updatePost(
        req: VovkRequest<{ title: string; content: string; }, { moderationType: 'nice' | 'strict' }>, 
        { postId }: { postId: string }
    ) {
        const { title, content } = req.json();
        const moderationType = req.nextUrl.searchParams.get('moderationType');
        return PostService.updatePost(postId, title, content, moderationType);
    }
}
```

The example above implements PUT endpoint that looks like that: `/api/post/69?moderationType=nice`.

- `authGuard` is a custom decorator that may be created by you based on your authorisation environment.
- `vovkZod` that's imported from [vovk-zod](https://github.com/finom/vovk-zod) performs Zod validation of body and query both on server-side and client-side.
- `VovkRequest` generic partially re-defines `NextRequest` type and makes `req.json` as well as `req.nextUrl.searchParams.get` return proper types.
- `PostService.updatePost` is invoked with properly-typed arguments after authorisation check, body and query validation.

## Back-end Service Class

Back-end Service Class (or just a Service) is a static class that implements third-party API calls or performs requests do the project database. 
By design Services don't have access to the request object and play the role of a "back-end library".

```ts
// /src/modules/comment/CommentService.ts
export default class CommentService {
    static getUserById(userId: User['id']) {
        return prisma.users.findUniqueOrThrow({ where: { id: userId } });
    }
}
```


## Isomorphic Service Class

Isomorphic Service is similar to a Back-end Service but can be used both by front-end (state, components, hooks, other Isomorphic Services, ...) and back-end (Back-End Services, Controllers, CLI scripts, ...). 
The only difference is that its methods need to be implemented as [pure functions](https://en.wikipedia.org/wiki/Pure_function). It means that it shouldn't perform DB calls nor access application state but can use other Isomorphic Service Classes. 

```ts
// /src/modules/comment/CommentIsomorphicService.ts
import PostIsomorphicService from '../post/PostIsomorphicService';

export default class CommentIsomorphicService {
    // a pure function
    static filterCommentsByPostId(comments: Comment[], posts: Post[], postId: Post['id']) {
        // filterPostById is also a pure function
        const post = PostIsomorphicService.filterPostById(posts, postId);
        if(post.isDeleted) return [];
        return comments.filter((comment) => comment.postId === postId);
    }

    // ...
}
```


## WPC Class

Every Isomorphic Service Class can be turned into a WPC Class (Worker Procedure Call) by applying `@worker()` decorator. 
The decorator defines required `onmessage` listeners if it's used in a Web Worker scope. 
In other cases `@worker()` decorator does nothing and the class can still be used as an Isomorphic Service somewhere else.

```ts
// /src/modules/hello/HelloWorker.ts
import { worker } from 'vovk';

@worker()
export default class HelloWorker {
    static performHeavyCalculations() {
        // ...
    }
}
```

The compiled WPC interface then can be imported from **vovk-client**.

```ts
// /src/app/page.tsx
import { HelloWorker } from 'vovk-client';

// ...
const onClick = useCallback(async () => {
    HelloWorker.employ(new Worker(new URL('../modules/hello/HelloWorker.ts', import.meta.url)));

    const result = await worker.performHeavyCalculations();

    console.log('result', result);
}, []);
```

WPC Clases can use other WPC Classes, Isomorphic Service Classes and Back-End Controllers imported from **vovk-client**. For more info [check the documentation](./worker).

## State

State file contains application state code that is going to be imported by React Components and other state files. It can use Isomorphic Services, WPC interfaces and Controllers imported from **vovk-client**.
State can be implemented with any application state library: Recoil, Redux, Redux Toolkit, MobX, custom context, or anything else since the framework does not cover state management topic.

<Callout type="info" emoji="ℹ️">
  A new state management library is [coming soon](https://github.com/finom/rebloom). Stay tuned!
</Callout>

```ts
// /src/modules/post/PostState.ts
import { PostController, PostWorker } from 'vovk-client';

// ... init app state for posts
```

## Other ideas

The framework isn't limited by the elements described above and you may want to add more files into your module folder.

- More Back-end Service Classes.
- More Isomorphic Service Classes.
- More WPC classes.
- Tests.
- React Components that you want to categorise (`modules/hello/components/MyComponent.tsx`).
- Types (`modules/hello/HelloTypes.ts`).
- Anything else you can imagine.

The framework is a suggestion and you can adjust it to your needs. It's not a strict rule but a way to make your project more structured and maintainable based on the experience of the Vovk.ts creator.