import { Callout } from 'nextra/components'

# VovkRequest

Request object accepted by controller methods is represented by `VovkRequest` type. It extends `NextRequest` object from Next.js by defining body and query types.

```ts
import { put, type VovkRequest } from 'vovk';
export default class UserController {
    @put() 
    static async updateUser(req: VovkRequest<{ foo: 'foo' }, { bar: 'bar'}>) {
        const data = await req.json(); // data type is { foo: 'foo' }
        const bar = req.nextUrl.searchParams.get('bar'); // bar type is 'bar'
        // ...
    }
}
```

## req.vovk

Version 3 of Vovk.ts introduces `req.vovk` object that contains additional methods for request processing.

### req.vovk.query()

Function `req.vovk.query` returns serialized query parameters of the request.

```ts
import { get, type VovkRequest } from 'vovk';
export default class UserController {
    @get() 
    static async getUser(req: VovkRequest<null, { id: string }>) {
        const query = req.vovk.query(); // query type is { id: string }
        // ...
    }
}
```

If you use [vovk-dto](/validation/vovk-dto) it will return an instance of DTO class with `plainToInstance` from [class-transformer](https://www.npmjs.com/package/class-transformer).

```ts
import { get, type VovkRequest } from 'vovk';
import { withDto } from 'vovk-dto';
import { GetUserDto } from './dto';

export default class UserController {
    @get() 
    static async getUser = withDto(null, GetUserDto, async (req) => {
        const query = req.vovk.query(); // query type is GetUserDto
        console.log(query instanceof GetUserDto); // true
        // ...
    });
}
```

#### Array query parameters

<Callout type="warning" emoji="⚠️">
    **Workaround notice**. In order to identify arrays, [RPC methods](/client) use a custom parameter `_vovkarr`.
</Callout>

If you pass an array of strings as a query option of the RPC method, the server-side is going to struggle with identifying the type of the query input. The query string will be the same for a string as a value and for an array of one string. `query: { q: 'foo' }` and `query: { q: ['foo'] }` will be both serialized as `?q=foo`. To avoid this issue, Vovk.ts uses a custom parameter `_vovkarr` that is added to the query string if the value is an array and contains comma-separated values. 

```ts
UserRPC.getUser({ query: { a: ['foo'], b: ['bar'], c: 'baz' } });
```

`query: { a: ['foo'], b: ['bar'], c: 'baz' }` will be serialized as `?a=foo&b=bar&c=baz&_vovkarr=a,b`.

### async req.vovk.body()

Async function `req.vovk.body` returns body of the request. In most of cases it's the same as `req.json()`. 

```ts
import { post, type VovkRequest } from 'vovk';
export default class UserController {
    @post() 
    static async createUser(req: VovkRequest<{ foo: 'foo' }>) {
        const body = await req.vovk.body(); // body type is { foo: 'foo' }
        // ...
    }
}
```


If you use [vovk-dto](/validation/vovk-dto) it will return an instance of DTO class with `plainToInstance` from [class-transformer](https://www.npmjs.com/package/class-transformer).

```ts
import { post, type VovkRequest } from 'vovk';
import { withDto } from 'vovk-dto';
import { CreateUserDto } from './dto';
export default class UserController {
    @post() 
    static async createUser = withDto(CreateUserDto, async (req) => {
        const body = await req.vovk.body(); // body type is CreateUserDto
        console.log(body instanceof CreateUserDto); // true
        // ...
    });
}
```

### async req.vovk.form()

Function `req.vovk.form` returns form data of the request serialized as an object. It's a type-safe alternative to `req.formData()` that reads form data and uses `formData.entries()` and `Object.fromEntries()` to convert it to an object. The generic argument defines the shape of the form data.

```ts
interface Data {
    foo: string;
    bar: string;
    file: File;
}

const formDataObject = await req.vovk.form<Data>();

// the same as
// const body = await req.formData();
// const formDataObject = Object.fromEntries(body.entries()) as Data;
```

### req.vovk.meta()

Function `req.vovk.meta` allows to get and set meta information of the request. The only argument is optional and, if provided, it sets meta information extending the existing meta information and returns the current. If empty, it returns the current meta information. In order to define the type of meta information, you need to pass a generic argument.

```ts
interface RequestMeta {
    foo: string;
    bar: string;
    currentUser: User;
}

// set foo and bar meta information
req.vovk.meta<RequestMeta>({ foo: 'foo', bar: 'bar' });

// set currentUser meta information
req.vovk.meta<RequestMeta>({ currentUser: user });

// get meta information
const meta = req.vovk.meta<RequestMeta>(); // meta type is RequestMeta including foo, bar and currentUser
```

The metadata is usually set in a custom [decorator](/controller/decorator).



