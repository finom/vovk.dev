
# Return Type

## Custom Object

The decorated static methods of controllers can return several kinds of objects. For example, a regular object literal. 

```ts
// ...
static async helloWorld(/* ... */) {
    // ...
    return { hello: 'world' };
}
```

Another example - if the controller method returns Prisma ORM invocation the type is going to be recognised accordingly.

```ts
// ...
static async updateUser(/* ... */) {
    // ...
    const updatedUser = await prisma.user.update({
        where: { id },
        data,
    });

    return updatedUser;
}
// ...
```

At this case the returned value of client method `UserController.updateUser` gets `User` type generated at **@prisma/client**.

## Response Object

HTTP handlers can also return regular `Response` object, including `NextResponse`.


```ts
// ...
static async helloWorld(/* ... */) {
    // ...
    return NextResponse.json({ hello: 'world' }, { status: 200 });
}
// ...
```

When `NextResponse.json` is returned from the controller method, the client library is going to recognise the return type as expected.
This way you can define headers, cookies and other options dynamically. See the [NextResponse documentation](https://nextjs.org/docs/app/api-reference/functions/next-response) for more details.

## Type Override

In case if your code makes it impossible to recognise the return type, you can override it manually with no need to convert it to `unknown` first.

```ts
import { UserController } from 'vovk-client';
import type { SomeType } from '../types';

// ...

// Override the return type
const updatedUser = await UserController.updateUser<SomeType>(/* ... */);
```

## Async iterable

```ts
// ...
static async *updateUser(/* ... */) {
    // ...
    yield* iterable;
}
// ...
```

If iterable is returned, the client library is going to cast the method as a disposable async generator to implement response streaming. It's explained in more details on the [streaming documentation page](/streaming).
