# Customizing the fetcher

You can redefine the default fetching function and its options to tightly integrate Vovk.ts client with your application state or to add extra features. For example, the clie ntized controller methods may look like that:

```ts
import { UserRPC } from 'vovk-client';

// ...
const user = await UserRPC.createUser({ 
    body,
    query,
    // custom options
    successToast: 'Successfully created a new user',
    useAuth: true,
    sentryLogErrors: true,
});
```

The fetcher is defined as a default export that extends `VovkClientFetcher` type and should be listed either as config option:

```ts filename="vovk.config.mjs"
/** @type {import('vovk').VovkConfig} */
const vovkConfig = {
    fetcher: './src/lib/myFetchingFunction',
};

export default vovkConfig;
```

Or as `VOVK_FETCHER` env variable:

```sh
VOVK_FETCHER="./src/lib/myFetchingFunction" vovk dev
```

By default Vovk.ts uses a fetcher defined at `vovk/client/defaultFetcher` and you can check its [source code on Github](https://github.com/finom/vovk/blob/main/packages/vovk/client/defaultFetcher.ts). 

The fetcher accepts two arguments: 
- An object that is provided by the internal Vovk.ts code that includes HTTP method information and utilities:
    - `httpMethod` - the HTTP metod;
    - `getEndpoint` - an utility that builds request endpoiint from `apiRoot`, `query` and `params`;
    - `validate` - a function that validates `body` and `query` of the request;
    - `defaultHandler` - handles the `Response` object returned from `fetch` function;
    - `defaultStreamHandler` - handles the `Response` object returned from `fetch` function in case of [JSON stream](/streaming).
- Request arguments:
    - `params` - the input params such as `id` from `users/:id`;
    - `query` - the request query properties such as `?foo=bar`;
    - `body` - the request body;
    - `apiRoot` - by default it's `/api`; it can be redefined in the [config](/config) by setting `rootEntry` and `origin` properties that are concatenated to build the endpoint;
    - The rest options - your custom options and `RequestInit` (including [custom Next.js options](https://nextjs.org/docs/app/building-your-application/data-fetching/fetching-caching-and-revalidating)) that includes other `fetch` options such as `headers`, `credentials` etc.

Your custom fetcher with a custom option `successMessage` may look like that:

```ts filename="/src/lib/myFetchingFunction.ts"
import type { VovkDefaultFetcherOptions, VovkClientFetcher } from 'vovk';

// Define custom options
interface MyOptions extends VovkDefaultFetcherOptions {
    successMessage: string;
}

const myFetchingFunction: VovkClientFetcher<MyOptions> = async (
  { httpMethod, getEndpoint, validate, defaultHandler, defaultStreamHandler },
  { params, query, body, apiRoot = '/api', successMessage, ...options }
) => {
  // Build the endpoint
  const endpoint = getEndpoint({ apiRoot, params, query });

  // Validate
  if (!options.disableClientValidation) {
    await validate({ body, query });
  }

  // Make fetch request (here you can add authorisation headers)
  const response = await fetch(endpoint, {
    method: httpMethod,
    ...options,
  });

  // Prepare request body
  if (body instanceof FormData) {
    init.body = body as BodyInit;
  } else if (body) {
    init.body = JSON.stringify(body);
  }

  let response: Response;

  try {
    // Make fetch request
    response = await fetch(endpoint, init);
  } catch (e) {
    // Handle network errors
    throw new HttpException(HttpStatus.NULL, (e as Error)?.message ?? DEFAULT_ERROR_MESSAGE);
  }

  // Handle JSON response
  if (response.headers.get('content-type')?.includes('application/json')) {
    return defaultHandler(response);
  }

  // Handle stream response
  if (response.headers.get('x-vovk-stream') === 'true') {
    return defaultStreamHandler(response);
  }

  // Handle custom options
  alert(successMessage);

  return response;
};

export default myFetchingFunction;
```

As you can see the code determines response type by headers. JSON responses are determined by `application/json` content type and stream responses are determined by `x-vovk-stream` header (the content type of stream responses is `"text/plain; charset=utf-8"`).

```ts
if (response.headers.get('content-type')?.includes('application/json')) {
  return yourCustomHandler(response);
}
```

## Type override

In case if the server endpoint and `yourCustomHandler` return different values, you can redefine the inferred return type using the client method generic argument.

```ts
import { MyRPC } from 'vovk-client';

// ...

const result = await MyRPC.myMethod<{ foo: 'bar' }>({
  body,
  successMessage: 'Success!'
})
```

The `result` variable from this example is going to receive `{ foo: 'bar' }` type.

## Turbo mode

In turbo mode, when `next dev` is used with `--turbo` flag, you're going to need to provide full path to the **.ts** file where the fetcher is stored.

```ts filename="vovk.config.mjs"
/** @type {import('vovk').VovkConfig} */
const vovkConfig = {
    fetcher: './src/lib/myFetchingFunction/index.ts',
};

export default vovkConfig;
```

