import { Tabs } from 'nextra/components';
import HelloWorker from '../downloaded-examples/worker/HelloWorker.mdx';
import WorkerExample from '../downloaded-examples/worker/WorkerExample.mdx';
import LiveWorkerExample from '../live-examples/LiveWorkerExample';
import { Callout } from 'nextra/components'

# WPC (Worker Procedure Call)

<Callout type="info" emoji="ℹ️">
  Since Vovk.ts is positioned as a back-end framework, you might think why it has a support for Web Workers. Indeed, a browser feature has nothing to do with the server-side code. However, the mechanism behind Vovk.ts allows to create an interface that accesses any other environment thru RPC-like mechanism if original code is implemented as a static class. Me as an [author](https://github.com/finom) of Vovk.ts thought of a way to move Web Worker capabilies to another library. But I haven't found any good reason to duplicate all the logic with schemas, generated code and other things besides the elegancy concern. So I decided to keep it as part of Vovk.ts.
</Callout> 


The standard Web Workers are awesome but they require to write additional logic by using `onmessage` handler on both sides (main thread and the Woker thread) and exchange data using `postMessage`. Vovk.ts applies the same principle that is used at controllers and builds main-thread client-side library using the auto-generated [schema](/schema). It uses built-in browser API aush as `addEventListener` and `postMessage` and does not utilise `eval` function or `Function` constructor.

Worker Class is created from a [Shared Service Class](/shared-service) by applying `@worker()` class decorator that defines `onmessage` handler in the Web Worker scope.

```ts filename="/src/modules/hello/HelloWorker.ts"
import { worker } from 'vovk';

@worker()
export default class HelloWorker {
    static heavyCalculation(iterations: number) {
        let result: number;
        // ... heavy calculations

        return result;
    }
}
```

In a non-worker scope `@worker()` does nothing. You can import the class safely in other modules, including back-end code where it's going to be behave as a normal collection of common functions. 

To compile the worker interface, you need to pass them to `initVovk` as `workers` object option and export the type of this object as `Workers`.


```ts filename="/src/app/api/[[...vovk]]/route.ts"
import { initVovk } from 'vovk';
import HelloController from '../../modules/hello/HelloController';
import HelloWorker from '../../modules/hello/HelloWorker';
import ByeWorker from '../../modules/bye/ByeWorker';

const controllers = { HelloRPC: HelloController };
const workers = { 
    HelloWPC: HelloWorker, 
    ByeWPC: ByeWorker 
};

export type Controllers = typeof controllers;
export type Workers = typeof workers;

export const { GET, POST, PUT, DELETE } = initVovk({ controllers, workers });
```


Once this is done, **vovk-client** is going to export the WPC library that provides interface to invoke heavy calculations but doesn't initialise the Web Worker itself. To initialise the Web Worker at the main-thread interface it needs to be instantiated normally and passed as an argument of `employ` static method.

```ts
import { HelloWPC } from 'vovk-client';

HelloWPC.employ(new Worker(new URL('./path/to/HelloWorker.ts', import.meta.url)));
```

This syntax is required to invoke the Webpack 5+ loader used by Next.js internally. After it's done the static methods of the mapped class type return `Promise` to delegate heavy calculations to the parallel thread.

```ts
const result = await HelloWPC.heavyCalculation(1e9);
```

Note that `Worker` class does not exist in Next.js SSR environment and in case if the code is exposed to non-client-side environment (for example outside of `useEffect`) it's recommended to check if `Worker` exists at the global scope.

```ts
import { HelloWPC } from 'vovk-client';

if(typeof Worker !== 'undefined') {
    HelloWPC.employ(new Worker(new URL('./path/to/HelloWorker.ts', import.meta.url)));
    // ...
}
```

`employ` method returns the worker interface itself. As potentially nicer solution you can use ternary operator to make the Worker library to be nullish.

```ts
import { HelloWPC } from 'vovk-client';

const MyWorker = typeof Worker === 'undefined' 
    ? null 
    : HelloWPC.employ(new Worker(new URL('./path/to/HelloWorker.ts', import.meta.url)));

await MyWorker?.heavyCalculation(1e9);
```

## Worker termination

A worker can be terminated with built-in `terminate` method.

```ts
HelloWorker.terminate();
```

## Async generators

WPC classes support generators and async generators to implement continious event streaming. 

```ts filename="/src/modules/hello/HelloWorker.ts"
import { worker } from 'vovk';

@worker()
export default class HelloWorker {
    static *generator() {
        for (let i = 0; i < 10; i++) {
            yield i;
        }
    }

    static async *asyncGenerator() {
        for (let i = 0; i < 10; i++) {
            await new Promise((resolve) => setTimeout(resolve, 100));
            yield i;
        }
    }
}
```

Vovk.ts turns them both into async generators when they're imported from **vovk-client**.

```ts
import { HelloWPC } from 'vovk-client';

// ... plug in the Web Worker with "use" method ...

for await (const number of HelloWPC.generator()) {
    console.log(number); // 0 ... 9
}

for await (const number of HelloWPC.asyncGenerator()) {
    console.log(number); // 0 ... 9
}
```

## Making HTTP requests at worker

Since Web Workers are run in a browser (but just in another thread) it's capable to fetch server-side data as expected.

```ts filename="/src/modules/hello/HelloController.ts"
import { get } from 'vovk';

export class HelloController {
    @get.auto()
    static getIterations() {
        return { iterations: 100_000_000 };
    }
}
```

```ts filename="/src/modules/hello/HelloWorker.ts"
import { HelloRPC } from 'vovk-client';

@worker()
export default class HelloWorker {
    static async heavyCalculation() {
        const data = await HelloRPC.getData();
        // ...
    }
}
```

## Using WPC at other Web Worker

Workers can use other workers. The syntax remains the same and you don't need to check for `Worker` variable to exist.

```ts
import { AnotherWPC } from 'vovk-client';

AnotherWPC.employ(new Worker(new URL('./path/to/AnotherWorker.ts', import.meta.url)));

export default class HelloWorker {
    heavyCalculation() {
        const anotherWorkerResult = await AnotherWPC.doSomethingHeavy();
        // ...
    }
}
```

## Creating a fork

To fork the worker and create as many parallel processes as needed you can use `fork` method instead of `employ`.

```ts
import { HelloWorker } from 'vovk-client';

function getFork() {
    return HelloWorker.fork(new Worker(new URL('./path/to/HelloWorker.ts', import.meta.url)));
}

const HelloWorker1 = getFork();
const HelloWorker2 = getFork();
const HelloWorker3 = getFork();

const [result1, result2, result3] = await Promise.all([
    HelloWorker1.heavyCalculation(),
    HelloWorker2.heavyCalculation(),
    HelloWorker3.heavyCalculation(),
]);
```

## Live Worker Example

<div className="doc-live-example">
    <LiveWorkerExample />
</div>
<Tabs items={['WPC Class', 'Component']}>
  <Tabs.Tab><HelloWorker /></Tabs.Tab>
  <Tabs.Tab><WorkerExample /></Tabs.Tab>
</Tabs>

[Source code](https://github.com/finom/vovk-examples)
