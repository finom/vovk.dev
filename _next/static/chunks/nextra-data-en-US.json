{"/blog/vovk-2-0":{"title":"Vovk.ts 2.0 is here!","data":{"breaking-changes#Breaking changes":"The version 1 is heavily tested in production and the community feedback is taken into account. Great news is that no significant bugs are found since then! The main purpose of breaking changes in this release is to make Vovk more consistent and easier to use.\n‚úÖ Renamed some types so that often used types are shorter and easier to type:\nVovkReturnType -> VovkControllerReturnType\nVovkBody -> VovkControllerBody\nVovkQuery -> VovkControllerQuery\nVovkParams -> VovkControllerParams\nVovkYieldType -> VovkControllerYieldType\nVovkClientReturnType -> VovkReturnType\nVovkClientBody -> VovkBody\nVovkClientQuery -> VovkQuery\nVovkClientParams -> VovkParams\nVovkClientYieldType -> VovkYieldType\n‚úÖ Replaced --no-next-dev flag with --next-dev flag in order to make it not run Next.js development server by default. In other words concurrently is now a recommended way to run Vovk and Next.js development servers together. This reduces potential problems with built-in command runner in Vovk.ts but also reduces very relevant confusion for new users.\nWithout Concurrently:\nBefore: vovk dev\nAfter: vovk dev --next-dev - not recommended but can be useful if it works on your machine :)\nWith Concurrently:\nBefore: PORT=3000 concurrently \"vovk dev --no-next-dev\" \"next dev\" --kill-others\nAfter: PORT=3000 concurrently \"vovk dev\" \"next dev\" --kill-others - this is the new recommended way to run Vovk and Next.js development servers together.\n‚úÖ Renamed worker.use to worker.employ to make it less confusing in React components.","minior-changes#Minior changes":"onError option of initVovk now gets request object as the second argument. This is useful if you want to extract some information about request like headers, method, authorisation, etc.\nimport { initVovk } from 'vovk';\nimport ErrorService from '../../modules/ErrorService';\n// ...\nconst { GET, POST, PUT, DELETE } = initVovk({\n    controllers,\n    workers,\n    onError: (error, request) => {\n      ErrorService.logError(error, request);\n    }\n});","chores#Chores":"‚úÖ Improved quality of the documentation and switched from Docusaurus to Nextra"}},"/blog":{"title":"Blog","data":{}},"/controller/client":{"title":"Client Library","data":{"":"initVovk performs required actions to generate client-side library and no additional action from your side is required (but you probably would need to restart TS Server to update types if you use VSCode when a new controller is added).The client library implements same-named methods but changes the method signature so you can pass required input data as options (body, query and params). vovk-client can be used in client components, server components, application state and even be distributed as a standalone package. For an illustration vovk-examples is published as a standalone NPM package to be used on vovk.dev that, by itself, is a static website powered by gh-pages.Everything exported from vovk-client is plain old JavaScript with typings that calls the regular fetch function.\nimport { UserController } from 'vovk-client';\n// ...\nconst updatedUser = await UserController.updateUser({\n    body: { firstName, lastName },\n    query: { role: 'admin' },\n    params: { id: '69' },\n});\n// same as\nfetch('/api/users/69?role=admin', {\n    method: 'PUT',\n    body: JSON.stringify({ firstName, lastName }),\n});\nIt's worthy to mention that client library can be customised in order to follow custom logic required by the application.\n await UserController.updateUser({\n    // ...\n    successMessage: 'Successfully created the user',\n    someOtherCustomFlag: true,\n});"}},"/cli":{"title":"CLI","data":{"vovk-dev#vovk dev":"The command runs Vovk Server expecting to be run together with Next.js dev server. It uses PORT variable to define its own port by adding 6969 to it. For example, if Next.js server runs on port 3000, Vovk Server will run on port 9969.It's recommended to use vovk dev and next dev together with concurrently or similar library. Here is an example of how to run them simultaneously:\nPORT=3000 npx concurrently 'vovk dev' 'next dev' --kill-others\nSince both Vovk Server and Next.js know the port of each other they can communicate in order to build .vovk.json and node_modules/.vovk files.","vovk-dev---next-dev#vovk dev --next-dev":"You can avoid using concurrently by running vovk dev with --next-dev flag. This command runs next dev by itself and assigns the port automatically.\nThe built-in commands runner works fine, but is not tested as good as concurrently. Use it at your own risk.","vovk-generate#vovk generate":"Generates the client based on .vovk.json and creates .js and .d.ts files at node_modules/.vovk that are re-exported by vovk-client. .vovk.json is generated via vovk dev.vovk generate as well as vovk dev accept --clientOut flag that indicates where client needs to be generated.\nnpx vovk generate --clientOut=my-custom-folder\nAll other commands such as next build and next start remain the same since the project is a normal Next.js application.","available-env-variables#Available env variables":"Environment variables allow to customize Vovk.ts behaviour by overriding configuration optionally defined at vovk.config.js. You can find more information about it at vovk.config.js documentation. Here is a quick ref:\nPORT=3000 - defines port for Next.js server that is also utilised by the Vovk Server.\nVOVK_PORT=3690 - a custom Vovk Server port.\nVOVK_CLIENT_OUT=./node_modules/.vovk - where the client needs to be compiled to.\nVOVK_ROUTE=./src/app/api/[[...vovk]]/route.ts - allows to redefine path to the wildcard route.\nVOVK_MODULES_DIR=./src/modules - defines the root directory where the modules are located.\nVOVK_FETCHER=vovk/client/defaultFetcher - allows to customize the fetching function that used internally by the client.\nVOVK_PREFIX=/api - defines the root endpoint used by fetch function at the client.\nVOVK_VALIDATE_ON_CLIENT - defines client-side validation library. If vovk-zod is installed but VOVK_VALIDATE_ON_CLIENT is not redefined it's value going to be set to \"vovk-zod/zodValidateOnClient\"."}},"/controller/service":{"title":"Service Class","data":{"":"In order to make the code cleaner it's recommended to move most of the logic to Back-end Services. Back-End Service is a static class that serves as a library that performs database and third-party API calls outside of Controller Classes.Let's say you have the following Controller Class:\nimport { prefix, put, type VovkRequest } from 'vovk';\nimport type { User } from '../../types';\n@prefix('users')\nexport default class UserController {\n    @put(':id') \n    static async updateUser(req: VovkRequest<Partial<User>>, { id }: { id: string }) {\n        const data = await req.json();\n        const updatedUser = await prisma.user.update({\n            where: { id },\n            data,\n        });\n        return updatedUser;\n    }\n}\nCurrently it looks fine since it doesn't contain a lot of logic. But as your app is getting more complex you're going to get more endpoints with more code. At this case it's recommended to move part of the logic to Back-End Service Class making controllers to be responsible for input extraction, validation and authorisation, but not for DB or API calls.Let's refactor the code above by introducing UserService. For this example it's going to be small but I hope that illustrates the idea clearly.\n// ... import types and libraries ...\nexport default class UserService {\n    static updateUser(id: string, data: Partial<User>) {\n        return prisma.user.update({\n            where: { id },\n            data,\n        });\n    }\n}\nAs you can see, UserService does not use decorators and used as a library that performs required side-effects.\nimport { prefix, put, type VovkRequest } from 'vovk';\nimport UserService from './UserService'\n@prefix('users')\nexport default class UserController {\n    @put(':id') \n    static async updateUser(req: VovkRequest<Partial<User>>, { id }: { id: string }) {\n        const data = await req.json();\n        return UserService.updateUser(id, data);\n    }\n}\nBack-End Service Classes can use other Back-End Services (as well as so-called Isomorphic Service Classes explained in separate article of this documentation).\nimport PostService from '../post/PostService';\nimport CommentService from '../comment/CommentService';\n// ... other imports ...\nexport default class UserService {\n    static async updateUser(id: string, data: Partial<User>) {\n        const latestPost = PostService.findLatestUserPost(id);\n        const latestPostComments = CommentService.findPostComments(latestPost.id);\n        // ...\n    }\n}","hello-world-service-live-example#\"Hello World\" Service Live Example":"Source code"}},"/controller/return":{"title":"Return Type","data":{"custom-object#Custom Object":"The decorated static methods of controllers can return several kinds of objects. For example, a regular object literal.\n// ...\nstatic async helloWorld(/* ... */) {\n    // ...\n    return { hello: 'world' };\n}\nAnother example - if the controller method returns Prisma ORM invocation the type is going to be recognised accordingly.\n// ...\nstatic async updateUser(/* ... */) {\n    // ...\n    const updatedUser = await prisma.user.update({\n        where: { id },\n        data,\n    });\n    return updatedUser;\n}\n// ...\nAt this case the returned value of client method UserController.updateUser gets User type generated at @prisma/client.","response-object#Response Object":"HTTP handlers can also return regular Response object, including NextResponse.\n// ...\nstatic async helloWorld(/* ... */) {\n    // ...\n    return NextResponse.json({ hello: 'world' }, { status: 200 });\n}\n// ...\nWhen NextResponse.json is returned from the controller method, the client library is going to recognise the return type as expected.\nThis way you can define headers, cookies and other options dynamically. See the NextResponse documentation for more details.","type-override#Type Override":"In case if your code makes it impossible to recognise the return type, you can override it manually with no need to convert it to unknown first.\nimport { UserController } from 'vovk-client';\nimport type { SomeType } from '../types';\n// ...\n// Override the return type\nconst updatedUser = await UserController.updateUser<SomeType>(/* ... */);","async-iterable#Async iterable":"// ...\nstatic async *updateUser(/* ... */) {\n    // ...\n    yield* iterable;\n}\n// ...\nIf iterable is returned, the client library is going to cast the method as a disposable async generator to implement response streaming. It's explained in more details on the streaming documentation page."}},"/controller/type":{"title":"Type extraction","data":{"":"vovk module provides a collection of useful types that described in more details at API documentation. It's worthy to mention the most oftenly used types here:\nimport { UserController, StreamController } from 'vovk-client';\nimport type { VovkBody, VovkQuery, VovkParams, VovkReturnType, VovkYieldType } from 'vovk';\n// infer body\ntype Body = VovkBody<typeof UserController.updateUser>;\n// infer query\ntype Query = VovkQuery<typeof UserController.updateUser>;\n// infer params\ntype Params = VovkParams<typeof UserController.updateUser>;\n// infer return type\ntype Return = VovkReturnType<typeof UserController.updateUser>;\n// infer yield type from stream methods\ntype Yield = VovkYieldType<typeof StreamController.streamTokens>;\nFor example, if you want to create a custom function that makes requests to the server, you can borrow types from the client to build the arguments.\nimport { UserController } from 'vovk-client';\nimport type { VovkBody, VovkQuery } from 'vovk';\nexport function updateUser(\n    id: VovkQuery<typeof UserController.updateUser>['id'],\n    body: VovkBody<typeof UserController.updateUser>,\n) {\n    return UserController.updateUser({\n        body,\n        query: { id },\n    });\n}\nThe exported updateUser can be called the following way:\nimport { updateUser } from './wherever-you-put-it';\n// ...\nawait updateUser('69', { firstName: 'John', lastName: 'Doe' });"}},"/blog/vovk-2-1":{"title":"Vovk.ts 2.1 - NextResponse.json type inferrence","data":{"":"Vovk.ts 2.1 is a small but important type update that gives additional flexibility using NextResponse when you need to define headers, cookies and oher options dynamically.\nStarting this version standard NextResponse.json can be used with proper type inferrence without requirement to override the return type of a client method.\nimport { get, HttpStatus } from 'vovk';\nimport { NextResponse } from 'next/server';\nexport default class HelloWorldController {\n    @get()\n    static async helloWorld(/* ... */) {\n        // ...\n        return NextResponse.json({ hello: 'World' }, { \n            status: HttpStatus.OK, \n            headers: { 'x-custom-header': 'value' } \n        });\n    }\n// ...\nClient code:\nimport { HelloWorldController } from 'vovk-client';\n// ...\nconst response = await HelloWorldController.helloWorld(); // response type is inferred as { hello: string }"}},"/customization":{"title":"Customizing the Fetcher and Default Client Options","data":{"":"You can redefine the default fetching function and its options to tightly integrate Vovk.ts client with your application state or to add extra features. For example, the clientized controller methods may look like that:\nimport { UserController } from 'vovk-client';\n// ...\nUserController.createUser({ \n    body,\n    query,\n    // custom options\n    successToast: 'Successfully created a new user',\n    useAuth: true,\n    sentryLogErrors: true,\n});\nThe fetcher is defined as a default export that extends VovkClientFetcher type and should be listed either as config option:\n/** @type {import('vovk').VovkConfig} */\nconst vovkConfig = {\n    fetcher: './src/lib/myFetchingFunction',\n};\nmodule.exports = vovkConfig;\nOr as VOVK_FETCHER env variable:\nVOVK_FETCHER=\"./src/lib/myFetchingFunction\" vovk dev\nBy default Vovk.ts uses fetcher defined at vovk/client/defaultFetcher and you can check its source code on Github.The fetcher accepts two arguments:\nAn object that is provided by the internal Vovk.ts code that includes HTTP method information and utilities:\nhttpMethod - the HTTP metod;\ngetEndpoint - an utility that builds request endpoiint from prefix, query and params;\nvalidate - a function that validates body and query of the request;\ndefaultHandler - handles the Response object returned from fetch function;\ndefaultStreamHandler - handles the Response object returned from fetch function in case of a stream.\nRequest arguments:\nparams - the patams such as id from users/:id;\nquery - the search query properties such as ?foo=bar;\nbody - the request body;\nprefix - what's defined as prefix property at vovk.config.js or passed directly to the client method;\nThe rest options - your custom options and RequestInit (including custom Next.js options) that includes the rest fetch options such as headers, credentials etc.\nYour custom fetcher with a custom option successMessage may look like that:\nimport type { VovkDefaultFetcherOptions, VovkClientFetcher } from 'vovk';\n// in order to keep default features such as disableClientValidation, headers etc,\n// it's recommended to extend custom options from VovkDefaultFetcherOptions\ninterface MyOptions extends VovkDefaultFetcherOptions {\n    successMessage: string;\n}\nconst myFetchingFunction: VovkClientFetcher<MyOptions> = async (\n  { httpMethod, getEndpoint, validate, defaultHandler, defaultStreamHandler },\n  { params, query, body, prefix = '/api', successMessage, ...options }\n) => {\n  // 1. Build the endpoint\n  const endpoint = getEndpoint({ prefix, params, query });\n  // 2. Validate\n  if (!options.disableClientValidation) {\n    await validate({ body, query });\n  }\n  // 3. Make fetch request (here you can add authorisation headers)\n  const response = await fetch(endpoint, {\n    method: httpMethod,\n    body: JSON.stringify(body),\n    ...options,\n  });\n  let returnResponse = response;\n  // 4. Handle response based on response headers\n  if (response.headers.get('content-type')?.includes('application/json')) {\n    returnResponse = await defaultHandler(response);\n  } else if (response.headers.get('content-type')?.includes('text/event-stream')) {\n    returnResponse = await defaultStreamHandler(response);\n  }\n  // 5. Utilise your custom option somehow.\n  alert(successMessage);\n  return returnResponse;\n};\nexport default myFetchingFunction;\nAs you can see the code determines response type by content-type header. You can freely redefine this logic to make the fetcher return something else (for example, if you want to use Axios or other fetching library).\nif (response.headers.get('content-type')?.includes('application/json')) {\n  return yourCustomHandler(response);\n}\nIn case if the server endpoint and yourCustomHandler return different values, you can redefine the inferred return type using the client method generic argument.\nimport { MyController } from 'vovk-client';\n// ...\nconst result = await MyController.myMethod<{ foo: 'bar' }>({\n  body,\n  successMessage: 'Success!'\n})\nThe result variable from this example is going to receive { foo: 'bar' } type.","creating-a-custom-validation-library#Creating a custom validation library":"If you need to create your custom validation library, check decorators documentation."}},"/decorators":{"title":"Controller Decorators Overview","data":{"":"createDecorator is a higher-order function that produces a decorator factory (a function that returns a decorator) for Controller Class methods. It accepts a middleware function with the following parameters:\nrequest, which extends NextRequest as well as VovkRequest.\nnext, a function that should be invoked and its result returned to call subsequent decorators or the route handler.\nAdditional arguments are passed through to the decorator factory.\nThe second argument of createDecorator is an optional init handler. It's called every time when decorator is initialised and it's used to populate .vovk.json with information on client-side validation described at Validation docs.\nimport { createDecorator, get, HttpException, HttpStatus } from 'vovk';\nconst myDecorator = createDecorator((req, next, a: string, b: number) => {\n  console.log(a, b); // Outputs: \"foo\", 1\n  if(isSomething) { \n    // override route method behavior and return { hello: 'world' } from the endpoint\n    return { hello: 'world' };\n  }\n  if(isSomethingElse) {\n    // throw HTTP error if needed\n    throw new HttpException(HttpStatus.BAD_REQUEST, 'Something went wrong');\n  }\n  return next();\n}, (a: string, b: number) => {\n    console.info('Decorator is initialised with', a, b);\n});\nclass MyController {\n  @get.auto()\n  @myDecorator('foo', 1) // Passes 'foo' as 'a', and 1 as 'b'\n  static doSomething() {\n    // ...\n  }\n}"}},"/decorators/authorization":{"title":"Authorization with Decorators","data":{"":"The authGuard decorator below does two things:\nChecks if a user is authorised and returns an Unauthorised status if not.\nAdds currentUser to the request object.\nTo extend req object you can define your custom interface that extends VovkRequest. Let's imagine that Prisma ORM is used at the project.\nimport type { VovkRequest } from 'vovk'\nimport type { User } from '@prisma/client';\nexport interface GuardedRequest<BODY = undefined, QUERY extends Record<string, string> | undefined = undefined>\n  extends VovkRequest<BODY, QUERY> {\n  currentUser: User;\n}\nThen define the authGuard decorator itself.\nimport { HttpException, HttpStatus, createDecorator } from 'vovk';\nimport type { GuardedRequest } from '../types';\nconst authGuard = createDecorator(async (req: GuardedRequest, next) => {\n  // ... define userId and isAuthorised\n  // parse access token for example\n  if (!isAuthorised) {\n    throw new HttpException(HttpStatus.UNAUTHORIZED, 'Unauthorized');\n  }\n  const currentUser = await prisma.user.findUnique({ where: { id: userId } });\n  req.currentUser = currentUser;\n  return next();\n});\nexport default authGuard;\nAnd finally use the decorator and define the request object with your newly created GuardedRequest type.\n// ...\nexport default class UserController {\n  // ...\n  @get('current-user')\n  @authGuard()\n  static async getCurrentUser(req: GuardedRequest</* ... */>) {\n    return req.currentUser;\n  }\n  // ...\n}"}},"/decorators/validation-examples":{"title":"Form Validation Examples","data":{"":"Here you can find examples of form validation. Both examples use the same Zod schema and the same controller.","live-example-for-basic-form-vaidation-using-zod#Live Example for Basic Form vaidation using Zod":"Source code","live-example-of-a-form-validation-using-react-hook-form-and-zod#Live Example of a Form validation using react-hook-form and Zod":"Source code"}},"/config":{"title":"vovk.config.js","data":{"":"The config file allows to change default options in order to customise generated client or its path. The default config looks like that:\n/** @type {import('vovk').VovkConfig} */\nconst vovkConfig = {\n    clientOut: './node_modules/.vovk',\n    route: './src/app/api/[[...vovk]]/route.ts',\n    modulesDir: './src/modules',\n    fetcher: 'vovk/client/defaultFetcher',\n    prefix: '/api',\n    validateOnClient: '',\n};\n                                                                        \nmodule.exports = vovkConfig;\nclientOut - where the client is going to be compiled to. Can be overriden by VOVK_CLIENT_OUT env variable.\nroute - allows to redefine path to the wildcard route (the slug can be any non-empty string, it's name is not utilised by Vovk.ts). Can be overriden by VOVK_ROUTE env variable.\nmodulesDir - defines the root directory where the modules are located. Can be overriden by VOVK_MODULES_DIR env variable. Used to watch for changes in the modules and recompile the client. You can set it to \"./src\" to watch for changes in the whole project.\nfetcher - allows to customize the fetching function that used internally by the client. Can be overriden by VOVK_FETCHER env variable. See the Customization docs for more info.\nprefix - defines the root endpoint used by fetch function at the client. Can be overriden by VOVK_PREFIX env variable.\nvalidateOnClient - defines client-side validation library. If vovk-zod is installed but validateOnClient is not redefined it's value going to get value \"vovk-zod/zodValidateOnClient\". Can be overriden by VOVK_VALIDATE_ON_CLIENT env variable.\nThe config can be also defined as vovk.config.cjs but also as an ES Module named vovk.config.mjs:\n/** @type {import('vovk').VovkConfig} */\nconst vovkConfig = {\n    // ...\n};\nexport default vovkConfig;"}},"/":{"title":"Index","data":{}},"/streaming":{"title":"Text Streaming for LLMs","data":{"async-iterators#Async Iterators":"Controller methods can implement generators that use * syntax and utilise yield keyword instead of regular return.\nimport { get, prefix } from 'vovk';\ntype Token = { message: string };\n@prefix('stream')\nexport default class StreamController {\n  @get('tokens')\n  static async *streamTokens() {\n    const tokens: Token[] = [\n      { message: 'Hello,' },\n      { message: ' World' },\n      { message: '!' },\n    ];\n    for (const token of tokens) {\n      await new Promise((resolve) => setTimeout(resolve, 300));\n      yield token;\n    }\n  }\n}\nIn order to refactor this code and utilise Back-end Service you can move the streaming logic to StreamService static class.\ntype Token = { message: string };\nexport default class StreamService {\n  static async *streamTokens() {\n    const tokens: Token[] = [\n      { message: 'Hello,' },\n      { message: ' World' },\n      { message: '!' },\n    ];\n    for (const token of tokens) {\n      await new Promise((resolve) => setTimeout(resolve, 300));\n      yield token;\n    }\n  }\n}\nAt the controller use yield* syntax to delegate iterable returned from StreamService.streamTokens.\nimport { get, prefix } from 'vovk';\nimport StreamService from './StreamService';\n@prefix('stream')\nexport default class StreamController {\n  @get('tokens')\n  static async *streamTokens() {\n    yield* StreamService.streamTokens();\n  }\n}","handling-stream-responses-on-the-client#Handling Stream Responses on the Client":"Text response streaming (including usage of StreamResponse class) generate client method that returns a disposable async generator.\nimport { StreamController } from 'vovk-client';\n{\n    using stream = await StreamController.streamTokens();\n    for await (const token of stream) {\n        console.log(token);\n    }\n}\nusing keyword (that you can freely replace by let or const) indicates that when code block is reached the end (in case of early break or if the code block encountered an error) the stream is going to be closed by invoking stream.close() method automatically. stream.close() can also be called explicitly if needed.To make sure that the stream is closed before moving to the next code block you can use await using syntax that disposes the stream asynchronous way.\nimport { StreamController } from 'vovk-client';\n{\n    await using stream = await StreamController.streamTokens();\n    // ...\n}\n// on this line stream is already closed","text-streaming-live-example#Text Streaming Live Example":"Source code"}},"/framework":{"title":"Project Framework","data":{"":"This page explains how you could structure an application introducing a framework that you can optionally apply to a large project that uses Next.js.The framework combines back-end and front-end code into a single code base. The logical parts of the app are split into folders called \"modules\" given them corresponding name such as user, post, comment, app settings, auth features etc. Basically, a \"module\" can belong to 2 categories:\nAn entity (a model) like \"user\" (or \"post\", \"comment\" etc).\nAnything what doesn't belong to some specific entity: app settings, auth, AI stuff...\nThe typical structure of files and folders in a Vovk.ts app would look like that:\nEvery item in a module folder (Service Class, Controller Class, state etc) is optional. Some parts of your app would require to have state only, but no controller.\nIn other case you can have a state and a controller, but database request in your controller is too simple to create a separate service class...The image below illustrates how different components of the application can be related to each other.","controller-class#Controller Class":"Controller Class is a static class that defines API endpoints. It can use Back-End Service Classes and Isomorphic Service Classes explained below.\nimport { prefix, get } from 'vovk';\nimport PostService from './PostService';\n@prefix('posts')\nexport default class PostController {    \n    @get()\n    static getPosts() {\n        return PostService.getPosts();\n    }\n}","back-end-service-class#Back-end Service Class":"Back-end Service Class (or just \"Service\") is a static class that implements third-party API calls or performs requests do the project database.\nBy design Services don't have access to the request object and play the role of a \"back-end library\".\nexport default class CommentService {\n    static getUserById(userId: User['id']) {\n        return prisma.users.findUniqueOrThrow({ where: { id: userId } });\n    }\n}","isomorphic-service-class#Isomorphic Service Class":"Isomorphic Service is similar to a Back-end Service but can be used both by front-end (state, components, hooks, other Isomorphic Services, ...) and back-end (Back-End Services, Controllers, CLI scripts, ...).\nThe only difference is that its methods need to be implemented as pure functions. It means that it shouldn't perform DB calls nor access application state but can use other Isomorphic Service Classes.\nimport PostIsomorphicService from '../post/PostIsomorphicService';\nexport default class CommentIsomorphicService {\n    // a pure function\n    static filterCommentsByPostId(comments: Comment[], posts: Post[], postId: Post['id']) {\n        // filterPostById is also a pure function\n        const post = PostIsomorphicService.filterPostById(posts, postId);\n        if(post.isDeleted) return [];\n        return comments.filter((comment) => comment.postId === postId);\n    }\n    // ...\n}","wpc-class#WPC Class":"Every Isomorphic Service Class can be turned into a WPC Class (Worker Procedure Call) by applying @worker() decorator.\nThe decorator defines required onmessage listeners if it's used in a Web Worker scope.\nIn other cases @worker() decorator does nothing and the class can still be used as an Isomorphic Service somewhere else.\nimport { worker } from 'vovk';\n@worker()\nexport default class HelloWorker {\n    static performHeavyCalculations() {\n        // ...\n    }\n}\nWPC Clases can use other WPC Classes, Isomorphic Service Classes and Back-End Controllers imported from vovk-client. For more info check the documentation.","state#State":"State file contains application state code that is going to be imported by React Components and other state files. It can use Isomorphic Services, WPC interfaces and clientized Controllers imported from vovk-client.\nState can be implemented with any application state library: Recoil, Redux, Redux Toolkit, MobX, custom context, or anything else since the framework does not cover state management topic.\nimport { PostController, PostWorker } from 'vovk-client';\n// ... init app state for posts\nA new state management library based on static classes is coming soon.\nIt's already used at several projects but it's not well documented yet.\nUsing unified syntax saves even more brain waves when you switch your attention between different environments.\nStay tuned by giving it a star!","other-ideas#Other ideas":"The framework isn't limited by the elements described above and you may want to add more files into your module folder.\nMore Back-end Services in order to organize the code further.\nMore Isomorphic Services.\nMore WPC classes.\nTests.\nReact Components that you want to categorise (modules/hello/components/MyComponent.tsx).\nTypes (modules/hello/HelloTypes.ts).\nAnything else you can imagine.\nThe framework is a suggestion and you can adjust it to your needs. It's not a strict rule but a way to make your project more structured and maintainable based on the experience of the Vovk.ts creator."}},"/about":{"title":"About","data":{"the-author#The Author":"As an experienced Upwork freelancer, I've competed with developers globally for many years.\nTo remain competitive in this dynamic and highly aggressive market,\nI continuously improve my coding efficiency and quality.\nI am committed to mastering new technologies and frameworks,\nensuring that I always deliver the best possible solutions for my clients.\nWith over 70 projects completed and countless lessons learned, and consistently earning above the market average, I frequently engage in critical reflection and discussions with my teams:\nHow can we deliver solutions more rapidly?\nWhat is the optimal structure for the project code?\nHow can we develop an architecture that remains relevant and extensible for years to come, even if I leave?\nWhich libraries and approaches are currently popular?\nHow can we enhance the readability of my code?\nWhat are the best practices for deploying swiftly while minimizing the risk of deployment issues at critical times?\nMost crucially, how to not fuck up the entire project after many months of effort?\nThis led me to the realization that I need to create a tool that not only enhances the speed of my work but also ensures consistently high quality, that is not depending on if I'm sleepy or if skip my workout today.","the-project#The Project":"Vovk.ts combines several approaches borrowed from other projects with a pinch of creativity.\nThe most powerful framework today? Next.js.\nThe simplest and most robust deployment method for Next.js? Vercel (though they aren't sponsors yet).\nThe most efficient way to invoke server-side code from the client-side? tRPC or something similar? Check.\nThe optimal structure for the app? NestJS, with decorators and Controller-Service-Repository pattern? Double check.\nNeed an edge runtime that delivers backend services geographically closer to users? Included.\nPrefer the reliability of good old REST over custom protocols? Absolutely.\nText streaming capabilities for AI applications? Seamless.\nTypeScript for safer and cleaner code? Always.\nVovk.ts encapsulates all the lessons from my extensive experience into one elegant solution,\nserving as a streamlined add-on to the Next.js API. With less than 1600 lines of code,\nit‚Äôs the perfect tool for developing full-stack applications that prioritize both speed and quality.Enjoy! I'm confident you will.","features#Features":"üëµ REST API: Utilize the good old REST without the need for custom protocols.\nü™Ñ RPC Capabilities: No need to choose between REST and RPC anymore ‚Äî use both.\nüö¢ Simplified Architecture: Run your full-stack Next.js application on a single port, avoiding the complexities of a monorepo.\nüßê Optimized Code Quality: Implement the Service-Controller-Repository pattern for peak code efficiency.\nüöÑ Edge Runtime Support: Access edge computing capabilities straight out of the box.\nüåø Lightweight: Streamlined for efficiency and speed.\nü§è Compact Client Code: Generates minimal code, essentially a neat wrapper over the fetch function.\nüì¶ Effortless Distribution: Easily bundle and distribute your client API library using Webpack, Rollup, or any other bundler.\nü§ù Seamless Integration with Next.js App Router: Works perfectly with standard Next.js APIs like Response, headers, and redirect.\nüß† User-Friendly: Designed for easy learning and adoption.\nüì± Broad Compatibility: Integrates effortlessly with React Native and other JavaScript environments.\nü§ñ Text Streaming: Supports streaming for Large Language Model applications using disposable async generators.\nüìÑ Static API Generation: Leverage generateStaticAPI to deploy your static JSON API.\n‚öôÔ∏è Web Worker Support: Enhance browser performance with multi-threading capabilities.\nüèéÔ∏è High Performance: Delivers rapid execution both client-side and server-side.\nüîß Fully Customizable: Tailor to meet specific project requirements.","glossary#Glossary":"Service-Controller-Repository pattern: A design pattern that separates the business logic (Service), request handling (Controller), and data access (Repository) into distinct layers.\nREST: Representational State Transfer, an architectural style for designing networked applications. A REST API uses standard HTTP methods like GET, POST, PUT, and DELETE to perform CRUD (create, read, update and delete) operations. Learn more about REST here.\nRPC: Remote Procedure Call, an approach that allows a client application to invoke server-side functions. Find out more about RPC on Wikipedia.\nWPC: Worker Procedure Call, an approach that enables a front-end application to call functions running in a Web Worker. First introduced in Vovk.ts. Read more about Web Workers on MDN.\nEdge Computing: A distributed computing paradigm that brings computation and data storage closer to the location where it is needed.\nMore details can be found on Wikipedia.\nStatic Class: A class that cannot be instantiated and is used to group related methods and properties. JavaScript/TypeScript does not have a built-in static keyword for classes, but it is a common pattern in other languages like Java and C#. Instead, TypeScript uses the static keyword to define static methods and properties on a regular class.\nDisposable Object: An object that is used once and then discarded. In TypeScript, a disposable object is created with using or await using (instead of let or const) and is automatically disposed of after the code block has ended by calling a method under Symbol.dispose or Symbol.asyncDispose key.\nFor more information, see TypeScript 5.2 Documentation.\nAsync Generator: A function that returns an AsyncIterable object.\nAsync Iterable: An object that can be used in a for await...of loop. It is similar to an Iterable, but the Symbol.asyncIterator method returns an AsyncIterator object. Learn more about async iterables on MDN.\nIf you have any additional questions or need further clarification, please don't hesitate to create an issue on the vovk.dev GitHub repository.","Ô∏è-support-my-work#‚ô•Ô∏è Support My Work":"Balancing family, a full-time job, restorative sleep, and open-source projects is a demanding endeavor. I am deeply appreciative of everyone who supports my efforts. If you admire my work and wish to contribute, please consider sponsoring me on GitHub.If you want to reach out, my contact information is available on my Github profile."}},"/api-reference":{"title":"API","data":{"":"Full list of available imports for quick reference:\nimport {\n  // core\n  initVovk,\n  createDecorator,\n  // controller method decorators\n  get, \n  post, \n  put, \n  patch, \n  del, \n  head, \n  options, \n  // controller class decorator\n  prefix, \n  // WPC class decorator \n  worker,\n  // core types\n  type VovkClientFetcher,\n  type VovkDefaultFetcherOptions,\n  type VovkConfig,\n  type VovkEnv,\n  type VovkMetadata,\n  type VovkErrorResponse,\n  // types used by controllers\n  type VovkRequest,\n  type VovkControllerBody,\n  type VovkControllerQuery,\n  type VovkControllerParams,\n  type VovkControllerReturnType,\n  type VovkControllerYieldType,\n  // types used by client\n  type VovkBody,\n  type VovkQuery,\n  type VovkParams,\n  type VovkReturnType,\n  type VovkYieldType,\n  type VovkClientOptions,\n  // classes\n  StreamResponse,\n  HttpException,\n  // enums\n  HttpStatus,\n  HttpMethod,\n  // misc\n  generateStaticAPI,\n} from 'vovk';","core#Core":"","initvovk#initVovk":"Creates the standard Next.js App Route handlers used by the main Optional Catch-all Segment. The function accepts the following options:\ncontrollers: Record<string, Function> - the list of Controllers\nworkers?: Record<string, Function> - the list of WPC interfaces\nexposeValidation?: boolean - set to false if you want to hide validation logic from the client-side code.\nonError?: (err: Error, req: NextRequest) => void | Promise<void> - called on Controller exceptions, can be used to log errors by a third-party service. The second argument can be utilised to retrieve reques URL, authorisation info, and other useful information about the failed request.\nimport { initVovk } from 'vovk';\nimport HelloController from '../../../modules/hello/HelloController';\nimport UserController from '../../../modules/user/UserController';\nimport HelloWorker from '../../../modules/hello/HelloWorker';\nimport UserWorker from '../../../modules/user/UserWorker';\nconst controllers = { HelloController, UserController };\nconst workers = { HelloWorker, UserWorker };\nexport type Controllers = typeof controllers;\nexport type Workers = typeof workers;\nexport const { GET, POST, PUT, PATCH, DELETE, HEAD, OPTIONS } = initVovk({\n  controllers,\n  workers,\n  exposeValidation: false,\n  onError(e, req) {\n    console.log('Error', e);\n  }\n});","createdecorator#createDecorator":"Defines a custom decorator to extend default behavoir of API endpoints. Accepts 2 arguments: middleware function and init function. The first one defines what the decorator is going to do, the second one is called once per initialisation and intended to pass extra data to the metadata file (for now it's client validation, if exposed).The middleware accepts at least 2 arguments: VovkRequest, next function that needs to be called and its awaited result needs to be returned after you perform required actions and ...rest - the arguments that are going to be used by the created decorator fabric.\nimport { createDecorator, get, HttpException, HttpStatus } from 'vovk';\nconst myDecorator = createDecorator((req, next, a: string, b: number) => {\n  console.log(a, b); // Outputs: \"foo\", 1\n  if(isSomething) { \n    // override route method behavior and return { hello: 'world' } from the endpoint\n    return { hello: 'world' };\n  }\n  if(isSomethingElse) {\n    // throw HTTP error if needed\n    throw new HttpException(HttpStatus.BAD_REQUEST, 'Something went wrong');\n  }\n  return next();\n}, (a: string, b: number) => {\n    console.info('Decorator is initialised with', a, b);\n});\nclass MyController {\n  static controllerName = 'MyController';\n  @get.auto()\n  @myDecorator('foo', 1) // Passes 'foo' as 'a', and 1 as 'b'\n  static getSomething() {\n    // ...\n  }\n}","controller-decorators#Controller Decorators":"","prefix-decorator#@prefix decorator":"@prefix(p: string) decorator used to prepend a sub-path to the endpoint. It's usage is optional.","get-post-put-patch-del-head-options#@get, @post, @put, @patch, @del, @head, @options":"@HTTP_METHOD(p: string, opts?: { cors?: boolean, headers?: Record<string, string> }) decorator define an HTTP method and an endpoint that's handled by the Controller method.","getauto-postauto-putauto#@get.auto, @post.auto, @put.auto...":"@HTTP_METHOD.auto(opts?: { cors?: boolean, headers?: Record<string, string> }) define HTTP method and generate endpoint string automatically from controller and method name.\nimport { prefix, get, post, put, patch, del, head, options } from 'vovk';\n@prefix('hello')\nexport default class HelloController {\n    @get('world', { cors: true })\n    static getHelloWorld() {\n        return { hello: 'world' };\n    }\n    @post.auto({ headers: { 'x-hello': 'world' }})\n    static postData(/* req: VovkRequest */) {\n        return { success: true };\n    }\n}","worker-decorator#worker decorator":"Defines required onmessage handler for a WPC Class.\nimport { worker } from 'vovk';\n@worker()\nexport default class HelloWorker {\n    static heavyCalculation() {\n        // ...\n    }\n}","enums#Enums":"import { HttpMethod, HttpStatus, HttpException } from 'vovk';","httpmethod-enum#HttpMethod enum":"Can be used with your code to create a custom fetcher.\nexport enum HttpMethod {\n  GET = 'GET',\n  POST = 'POST',\n  PUT = 'PUT',\n  PATCH = 'PATCH',\n  DELETE = 'DELETE',\n  HEAD = 'HEAD',\n  OPTIONS = 'OPTIONS',\n}","httpstatus-enum#HttpStatus enum":"Used to throw and catch errors thrown by the server. Notice NULL member. It can be used to simulate HTTP errors on client validation errors (this approach is used at vovk-zod).\nexport enum HttpStatus {\n  NULL = 0,\n  CONTINUE = 100,\n  SWITCHING_PROTOCOLS = 101,\n  PROCESSING = 102,\n  EARLYHINTS = 103,\n  OK = 200,\n  CREATED = 201,\n  ACCEPTED = 202,\n  NON_AUTHORITATIVE_INFORMATION = 203,\n  NO_CONTENT = 204,\n  RESET_CONTENT = 205,\n  PARTIAL_CONTENT = 206,\n  AMBIGUOUS = 300,\n  MOVED_PERMANENTLY = 301,\n  FOUND = 302,\n  SEE_OTHER = 303,\n  NOT_MODIFIED = 304,\n  TEMPORARY_REDIRECT = 307,\n  PERMANENT_REDIRECT = 308,\n  BAD_REQUEST = 400,\n  UNAUTHORIZED = 401,\n  PAYMENT_REQUIRED = 402,\n  FORBIDDEN = 403,\n  NOT_FOUND = 404,\n  METHOD_NOT_ALLOWED = 405,\n  NOT_ACCEPTABLE = 406,\n  PROXY_AUTHENTICATION_REQUIRED = 407,\n  REQUEST_TIMEOUT = 408,\n  CONFLICT = 409,\n  GONE = 410,\n  LENGTH_REQUIRED = 411,\n  PRECONDITION_FAILED = 412,\n  PAYLOAD_TOO_LARGE = 413,\n  URI_TOO_LONG = 414,\n  UNSUPPORTED_MEDIA_TYPE = 415,\n  REQUESTED_RANGE_NOT_SATISFIABLE = 416,\n  EXPECTATION_FAILED = 417,\n  I_AM_A_TEAPOT = 418,\n  MISDIRECTED = 421,\n  UNPROCESSABLE_ENTITY = 422,\n  FAILED_DEPENDENCY = 424,\n  PRECONDITION_REQUIRED = 428,\n  TOO_MANY_REQUESTS = 429,\n  INTERNAL_SERVER_ERROR = 500,\n  NOT_IMPLEMENTED = 501,\n  BAD_GATEWAY = 502,\n  SERVICE_UNAVAILABLE = 503,\n  GATEWAY_TIMEOUT = 504,\n  HTTP_VERSION_NOT_SUPPORTED = 505,\n}","classes#Classes":"","httpexception-class#HttpException class":"Used to throw HTTP errors on server-side and re-throw, simulate and handle HTTP errors on client-side. The instance provides 2 properties: statusCode and message.Server-side:\n// ...\nexport default class HelloController {\n    @get()\n    static getHello() {\n        if(/* ... */) {\n            throw new HttpException(HttpStatus.BAD_REQUEST, 'Something went wrong'); \n        }\n    }\n}\nClient-side:\nimport { HelloController } from 'vovk-client';\nexport async function getHello() {\n    try {\n        return await HelloController.getHello();\n    } catch (e) {\n        console.log(e instanceof HttpException);\n        const err = e as HttpException;\n        console.log(err.statusCode, err.message);\n    }\n}","streamresponse#StreamResponse":"StreamResponse<T>(init?: ResponseInit) class can be used as an alternative to generators to implement response streaming. Instances of this class provide the following methods:\nsend(data: T) - sends portion of data\nclose() - close the connection\nthrow(error: any) - throws an error on client-side and closes the connection\nimport { prefix, get, StreamResponse, type VovkRequest } from 'vovk';\ntype Token = { message: string };\n@prefix('stream')\nexport default class StreamController {\n  @get('tokens')\n  static async streamTokens() {\n    const resp = new StreamResponse<Token>();\n    void (async () => {\n      const tokens: Token[] = [\n        { message: 'Hello,' },\n        { message: ' World' },\n        { message: '!' },\n      ];\n      for (const token of tokens) {\n        await new Promise((resolve) => setTimeout(resolve, 300));\n        if(somethingWentWrong) {\n          resp.throw(new Error('Somethiing went wrong'));\n        }\n        resp.send(token);\n      }\n      resp.close();\n    });\n    return resp;\n  }\n}\nThe class also provides static property defaultHeaders that contains the standard headers for the keep-alive connections. Since StreamResponse accepts standard ResponseInit as options argument you can override default headers and optionally spread StreamResponse.defaultHeaders.\nconst resp = new StreamResponse<Token>({\n  headers: {\n    ...StreamResponse.defaultHeaders,\n    'x-hello': 'world',\n  }\n});","core-types#Core types":"","vovkclientfetcher-and-vovkdefaultfetcheroptions-types#VovkClientFetcher and VovkDefaultFetcherOptions types":"Used to redefine the default fetcher. See customization docs.","vovkconfig-type#VovkConfig type":"Defines config types.\n// /vovk.config.js\n/** @type {import('vovk').VovkConfig} */\nconst vovkConfig = {\n  // ...\n}\nmodule.exports = vovkConfig;\nFor more info check customization docs.","vovkenv-type#VovkEnv type":"Defines Vovk.ts env variable types.For more info check customization docs.","vovkmetadata-type#VovkMetadata type":"Defines format for .vovk.json","vovkerrorresponse-type#VovkErrorResponse type":"Original shape of an object returned from the server when an error is thrown.","controller-types#Controller Types":"","vovkrequest-type#VovkRequest type":"The type is used to define types for req.json and req.nextUrl.searchParams.get and allow to infer types in other environments.\nimport { get, type VovkRequest } from 'vovk';\nexport class HelloController {\n    @get(':someParam')\n    static doSomething(\n        req: VovkRequest<{ body: true }, { q: string }>, \n        { someParam }: { someParam: string }\n    ) {\n        const body = await req.body(); // { body: true }\n        const q = req.nextUrl.searchParams.get('q'); // string\n        const nope = req.nextUrl.searchParams.get('nope'); // never\n        // ...\n        return { success: true };\n    }\n}","vovkcontrollerbody-type#VovkControllerBody type":"Extracts request body type from a controller method.","vovkcontrollerquery-type#VovkControllerQuery type":"Extracts query (search params) type from a controller method.","vovkcontrollerparams-type#VovkControllerParams type":"Extracts params type from a controller method.","vovkcontrollerreturntype-type#VovkControllerReturnType type":"Extracts return type from a controller method and unwraps the promise.","vovkcontrolleryieldtype-type#VovkControllerYieldType type":"Extracts yield type from a controller method implemented as a generator.\nimport {\n  get,\n  type VovkControllerBody, \n  type VovkControllerQuery, \n  type VovkControllerParams, \n  type VovkControllerReturnType, \n  type VovkControllerYieldType \n} from 'vovk';\nexport class HelloController {\n    @get(':someParam')\n    static doSomething(/* ... */) {\n        // ...\n    }\n    static *generator(/* ... */)\n}\ntype DoSomethingBody = VovkControllerBody<typeof HelloController.doSomething>;\ntype DoSomethingQuery = VovkControllerQuery<typeof HelloController.doSomething>;\ntype DoSomethingParams = VovkControllerParams<typeof HelloController.doSomething>;\ntype DoSomethingReturnType = VovkControllerReturnType<typeof HelloController.doSomething>;\ntype GeneratorYieldtype = VovkControllerYieldType<typeof HelloController.generator>;","types-for-the-client#Types for the Client":"","vovkbody-type#VovkBody type":"Extracts request body type from a clientized controller method.","vovkquery-type#VovkQuery type":"Extracts query (search params) type from a clientized controller method.","vovkparams-type#VovkParams type":"Extracts params type from a clientized controller method.","vovkreturntype-type#VovkReturnType type":"Extracts return type from a clientized controller method and unwraps the promise.","vovkyieldtype-type#VovkYieldType type":"Extracts yield type from a clientized generator controller method.\nimport { HelloController } from 'vovk-client';\ntype DoSomethingBody = VovkBody<typeof HelloController.doSomething>;\ntype DoSomethingQuery = VovkQuery<typeof HelloController.doSomething>;\ntype DoSomethingParams = VovkParams<typeof HelloController.doSomething>;\ntype DoSomethingReturnType = VovkReturnType<typeof HelloController.doSomething>;\ntype GeneratorYieldtype = VovkYieldType<typeof HelloController.generator>;","vovkclientoptions-type#VovkClientOptions type":"Type that used internally and exposed to customize the client. See decorators documentation.","misc#Misc":"","generatestaticapi#generateStaticAPI":"generateStaticAPI(controllers: Record<string, Function>, slug?: string) is used to generate static endpoints with generateStaticParams at build time instead of on-demand at request time. It can be used in a Static Export mode with the output: 'export' Next.js config setting:\n// next.config.js\n/** @type {import('next').NextConfig} */\nconst nextConfig = {\n  output: 'export',\n};\nmodule.exports = nextConfig;\nTo utilise this feature return generateStaticAPI results from generateStaticParams function.\n// ...\nexport type Controllers = typeof controllers;\nexport type Workers = typeof workers;\nexport function generateStaticParams() {\n  return generateStaticAPI(controllers);\n}\nexport const { GET } = initVovk({ controllers, workers });\nIn order to make it work on a static website hosting like Github Pages, you may need to define .json extension in your endpoint definition to make it return proper HTTP headers.\nimport { get, prefix } from 'vovk';\n@prefix('hello')\nexport default class HelloController {\n  @get('greeting.json')\n  static async getHello() {\n    return { greeting: 'Hello world!' };\n  }\n}\nAs result you're going to get an endpoint that looks like that: https://vovk.dev/api/hello/greeting.json.In case if you use custom slug (e.g. /src/app/api/[[...custom]]/route.ts) instead of vovk you can provide it as second argument.\nexport function generateStaticParams() {\n  return generateStaticAPI(controllers, 'custom');\n}"}},"/decorators/validation":{"title":"Request Validation","data":{"":"Vovk.ts offers API that allows to validate request body and query string on back-end and performs zero-cost validation on client-side before request to the server is made.","vovk-zod#vovk-zod":"vovk-zod is the library that implements Zod validation. It performs validation on the Controller side with ZodModel.parse, converts the Zod object to a JSON Schema that's stored at .vovk.json file, and runs validation on client before the HTTP request is made with Ajv.\nimport { z } from 'zod';\n// ... other imports ...\nconst UpdateUserModel = z.object({ name: z.string(), email: z.email() }).strict();\nconst UpdateUserQueryModel = z.object({ id: z.uuid() }).strict();\nexport default class UserController {\n    @put.auto()\n    @vovkZod(UpdateUserModel, UpdateUserQueryModel)\n    static updateUser(\n        req: VovkRequest<z.infer<typeof UpdateUserModel>, z.infer<typeof UpdateUserQueryModel>>\n    ) {\n        const { name, email } = await req.json();\n        const id = req.nextUrl.searchParams.get('id');\n        return UserService.updateUser(id, { name, email });\n    }\n}","creating-a-custom-validation-library#Creating a Custom Validation Library":"You can create a decorator that, first of all, validates request on the server-side and optionally populates controller metadata with validation information that is going to be used by the client.The simplest example of the validation would be equality validation. It does nothing than checking if received query and body are equal to some definite object but has no practical use outside of this documentation.At the example below validateEquality decorator is created with createDecorator that accepts 2 arguments: server validation function and init function that populates clientValidators object to define how validation information should be stored at .vovk.json file.\nimport { isEqual } from 'lodash';\nimport { \n  HttpException, HttpStatus, createDecorator, type VovkRequest, type VovkClientOptions \n} from 'vovk';\ntype BodyValidate = Record<string, unknown> | null;\ntype QueryValidate = Record<string, string> | null;\nconst validateEquality = createDecorator(\n  async (req: VovkRequest<unknown>, next, bodyValidate?: BodyValidate, queryValidate?: QueryValidate) => {\n    if (bodyValidate) {\n      const body = await req.json();\n      // override req.json to make it to be called again by controller code\n      req.json = () => Promise.resolve(body);\n      if (!isEqual(body, bodyValidate)) {\n        throw new HttpException(HttpStatus.BAD_REQUEST, 'Server exception. Invalid body');\n      }\n    }\n    if (queryValidate) {\n      const query = Object.fromEntries(req.nextUrl.searchParams.entries());\n      if (!isEqual(query, queryValidate)) {\n        throw new HttpException(HttpStatus.BAD_REQUEST, 'Server exception. Invalid query');\n      }\n    }\n    return next();\n  },\n  (bodyValidate?: BodyValidate, queryValidate?: QueryValidate) => ({\n    clientValidators: {\n      body: bodyValidate,\n      query: queryValidate,\n    },\n  })\n);\nexport default validateEquality;\nThen create a file that defines client-side validation function as default export.\nimport { type VovkClientOptions, HttpException, HttpStatus } from 'vovk';\nimport { isEqual } from 'lodash';\nconst validateEqualityOnClient: VovkClientOptions['validateOnClient'] = (input, validators) => {\n  if (validators.body) {\n    if (!isEqual(input.body, validators.body)) {\n      throw new HttpException(HttpStatus.NULL, `Client exception. Invalid body`);\n    }\n  }\n  if (validators.query) {\n    if (!isEqual(input.query, validators.query)) {\n      throw new HttpException(HttpStatus.NULL, `Client exception. Invalid query`);\n    }\n  }\n};\nexport default validateEqualityOnClient;\nAt this example validateEquality is used as a controller decorator and validateEqualityOnClient is used internally by the client. Also notice that validateEqualityOnClient throws HttpException with status 0 to simulate regular HTTP exceptions that can be caught by the client-side code.Here is how the newly created decorator is used at the controller.\nimport type { VovkRequest } from 'vovk';\nimport validateEquality from '../decorators/validateEquality';\nexport default class HelloController {\n    @post.auto()\n    @validateEquality({ foo: 42 }, { bar: 'hello' })\n    static validatedRequest(req: VovkRequest<{ foo: 42 }, { bar: 'hello' }>) {\n        // ...\n    }\n}\nIn order to enable client-side validation you need to define validateOnClient option in vovk.config.js file. For more info see customization documentation.\n/** @type {import('vovk').VovkConfig} */\nconst vovkConfig = {\n    validateOnClient: './src/decorators/validateEqualityOnClient',\n}\nmodule.exports = vovkConfig;\nIf your validation library is published on NPM it needs to follow the same approach but use module name instead of local path to the file.\n/** @type {import('vovk').VovkConfig} */\nconst vovkConfig = {\n    validateOnClient: 'my-validation-library/validateEqualityOnClient',\n}\nmodule.exports = vovkConfig;\nResulting client code is going to look like that:\nimport { HelloController } from 'vovk-client';\n// ...\nconst result = await HelloController.validatedRequest({\n    body: { foo: 42 },\n    query: { bar: 'hello' },\n});\nvalidateEqualityOnClient is going to be invoked on every request before data is sent to the server.","disable-client-validation#Disable client validation":"You can set disableClientValidation option mentioned above to true to disable client validation for debugging purposes.\nconst result = await HelloController.validatedRequest({\n    body: { foo: 42 },\n    query: { bar: 'hello' },\n    disableClientValidation: true,\n});\nIf you want to disable it completely and remove it from .vovk.json file (in case if you want to hide server-side validation implementation) you can use exposeValidation option set to false at the Next.js wildcard router level.\n// ...\nexport const { GET, POST, PATCH, PUT } = initVovk({\n    controllers,\n    workers,\n    exposeValidation: false // don't populate metadata file with validation information\n});"}},"/controller":{"title":"Controller Definition","data":{"":"Controller is a static class that handles incoming HTTP requests.\nThe methods of this class, that are decorated with an HTTP decorator (like @get() or @post()), accept 2 arguments: NextRequest (that is not monkey-patched by Vovk.ts itself) and parameters that are defined by the decorator path.\nimport type { NextRequest } from 'next';\nimport { prefix, put } from 'vovk';\n@prefix('users')\nexport default class UserController {\n    // Example request: PUT /api/users/69?role=moderator\n    @put(':id') \n    static async updateUser(req: NextRequest, { id }: { id: string }) {\n        const data = await req.json(); // any\n        const userRole = req.nextUrl.searchParams.get('role'); // string | null\n        // ...\n        return updatedUser;\n    }\n}\nAt the example aboce data is casted as any and userRole is casted as string | null. To fix the body and query types Vovk.ts provides a new type VovkRequest<BODY?, QUERY?> that is extended from NextRequest where the first generic argument represents the type of value returned from req.json but also allows to define values returned from req.nextUrl.searchParams.get. VovkRequest also plays crucial role in type inference when vovk-client is used in order to infer types properly.As its mentioned before, req object is an original NextRequest object that provided by Next.js as is, without changing it, but other libraries (like vovk-zod) as well as your custom code can modify this object when needed (for example to add currentUser property defined by your auth guard decorator).To add the required body and query types just replace NextRequest by VovkRequest. Let's modify the abstract example above.\nimport { prefix, put, type VovkRequest } from 'vovk';\nimport type { User } from '../../types';\n@prefix('users')\nexport default class UserController {\n    // Example request: PUT /api/users/69?role=moderator\n    @put(':id') \n    static async updateUser(\n        req: VovkRequest<Partial<User>, { role: 'user' | 'moderator' | 'admin' }>, \n        { id }: { id: string }\n    ) {\n        const data = await req.json(); // Partial<User>\n        const userRole = req.nextUrl.searchParams.get('role'); // 'user' | 'moderator' | 'admin'\n        // ...\n        return updatedUser;\n    }\n}\nAs you can see we've changed nothing more than the type of req but now data receives type of Partial<User> and userRole is casted as 'user' | 'moderator' | 'admin' and does not extend null anymore.","controller-initialization#Controller Initialization":"Once the controller is defined it needs to be initialized at the wildcard route by adding it to the controllers object.\nimport { initVovk } from 'vovk';\nimport UserController from '../../../modules/user/UserController';\nconst controllers = { UserController };\nconst workers = {}; // See Worker documentation\nexport type Controllers = typeof controllers;\nexport type Workers = typeof workers;\nexport const { GET, POST, PUT, DELETE } = initVovk({ controllers, workers });","auto-generated-endpoints#Auto-generated Endpoints":"All HTTP decorators provide .auto method that generates endpoint name automatically from the method name.\nimport { prefix, put } from 'vovk';\n@prefix('users')\nexport default class UserController {\n    // Example request: PUT /api/users/do-something\n    @put.auto() \n    static async doSomething(/* ... */) {\n        // ...\n    }\n}\nSince the client is generated automatically, if your API is used only internally, you can use auto-generated endpoints to save a little bit of time thinking of new endpoint name.","response-headers#Response Headers":"All HTTP decorators support custom response headers provided as the second argument.\n// ...\nexport default class UserController {\n    @put('do-something', { headers: { 'x-hello': 'world' } }) \n    static async doSomething(/* ... */) { /* ... */ }\n}\nTo enable CORS instead of manually setting up headers you can use cors: true option.\n// ...\nexport default class UserController {\n    @put('do-something', { cors: true }) \n    static async doSomething(/* ... */) { /* ... */ }\n}\nFor auto-generated endpoints cors and headers are defined as the only argument.\n// ...\nexport default class UserController {\n    @put.auto({ cors: true, headers: { 'x-hello': 'world' } }) \n    static async doSomething(/* ... */) { /* ... */ }\n}","dynamic-response-headers#Dynamic Response Headers":"To set up dynamic response headers you can use NextResponse object that is provided by Next.js.\nimport { NextResponse } from 'next/server';\n// ...\nexport default class UserController {\n    @put('do-something') \n    static async doSomething() {\n        return NextResponse.json({ hello: 'world' }, { 'x-hello': 'world' });\n    }\n}"}},"/controller/errors":{"title":"Exceptions and Custom HTTP Statuses","data":{"":"You can gracefully throw HTTP exceptions with the syntax borrowed from NestJS. HttpException class accepts 2 arguments. The first one is an HTTP code that can be retrieved from HttpStatus, the other one is an error text.\nimport { HttpException, HttpStatus } from 'vovk';\n// ...\nstatic async updateUser(/* ... */) {\n    // ...\n    throw new HttpException(HttpStatus.BAD_REQUEST, 'Something went wrong');\n}\nThe errors are re-thrown at the client library with the same interface.\nimport { UserController } from 'vovk-client';\nimport { HttpException } from 'vovk';\n// ...\ntry {\n    const updatedUser = await UserController.updateUser(/* ... */);\n} catch(e) {\n    console.log(e instanceof HttpException); // true\n    const err = e as HttpException;\n    console.log(err.message, err.statusCode);\n}\nRegular errors such as Error are equivalent to HttpException with code 500.\nimport { HttpException, HttpStatus } from 'vovk';\n// ...\nstatic async updateUser(/* ... */) {\n    // ...\n    throw new Error('Something went wrong'); // 500\n}\nYou can also throw custom objects that are going to be re-thrown on the client-side as is.\nthrow { hello: 'World' };","httpstatus-enum#HttpStatus Enum":"There are the values of the HttpStatus enum for quick reference.\nexport enum HttpStatus {\n  NULL = 0,\n  CONTINUE = 100,\n  SWITCHING_PROTOCOLS = 101,\n  PROCESSING = 102,\n  EARLYHINTS = 103,\n  OK = 200,\n  CREATED = 201,\n  ACCEPTED = 202,\n  NON_AUTHORITATIVE_INFORMATION = 203,\n  NO_CONTENT = 204,\n  RESET_CONTENT = 205,\n  PARTIAL_CONTENT = 206,\n  AMBIGUOUS = 300,\n  MOVED_PERMANENTLY = 301,\n  FOUND = 302,\n  SEE_OTHER = 303,\n  NOT_MODIFIED = 304,\n  TEMPORARY_REDIRECT = 307,\n  PERMANENT_REDIRECT = 308,\n  BAD_REQUEST = 400,\n  UNAUTHORIZED = 401,\n  PAYMENT_REQUIRED = 402,\n  FORBIDDEN = 403,\n  NOT_FOUND = 404,\n  METHOD_NOT_ALLOWED = 405,\n  NOT_ACCEPTABLE = 406,\n  PROXY_AUTHENTICATION_REQUIRED = 407,\n  REQUEST_TIMEOUT = 408,\n  CONFLICT = 409,\n  GONE = 410,\n  LENGTH_REQUIRED = 411,\n  PRECONDITION_FAILED = 412,\n  PAYLOAD_TOO_LARGE = 413,\n  URI_TOO_LONG = 414,\n  UNSUPPORTED_MEDIA_TYPE = 415,\n  REQUESTED_RANGE_NOT_SATISFIABLE = 416,\n  EXPECTATION_FAILED = 417,\n  I_AM_A_TEAPOT = 418,\n  MISDIRECTED = 421,\n  UNPROCESSABLE_ENTITY = 422,\n  FAILED_DEPENDENCY = 424,\n  PRECONDITION_REQUIRED = 428,\n  TOO_MANY_REQUESTS = 429,\n  INTERNAL_SERVER_ERROR = 500,\n  NOT_IMPLEMENTED = 501,\n  BAD_GATEWAY = 502,\n  SERVICE_UNAVAILABLE = 503,\n  GATEWAY_TIMEOUT = 504,\n  HTTP_VERSION_NOT_SUPPORTED = 505,\n}"}},"/streaming/openai":{"title":"OpenAI Chat Live Example","data":{"":"At this example the createChatCompletion generator delegates the async iterable returned from openai.chat.completions.create\nand the component utilises using keyword in order to close the stream safely in case of an interruption, iterating the messages using await for syntax.\nSource code"}},"/streaming/stream-response":{"title":"Text Streaming with StreamResponse Class","data":{"":"In some cases it's too hard to use generators to implement response streaming. Vovk.ts introduces StreamResponse class inherited from Response class that uses TransformStream#readable as body and adds required HTTP headers.\nIt's a lower-level API that is used behind the scenes to implement generator logic described at previous section.\nService method at this case is implemented as a regular function that accepts StreamResponse instance as a pointer to send messages manually.There is what the streaming service might look like:\nimport type { StreamResponse } from 'vovk';\nexport type Token = { message: string };\nexport default class StreamService {\n  static async streamTokens(resp: StreamResponse<Token>) {\n    const tokens: Token[] = [\n      { message: 'Hello,' },\n      { message: ' World' },\n      { message: '!' },\n    ];\n    for (const token of tokens) {\n      await new Promise((resolve) => setTimeout(resolve, 300));\n      resp.send(token);\n    }\n    resp.close();\n  }\n}\nAs you can see tokens are sent using StreamResponse#send method and, when the stream is completed, it needs to be closed with StreamResponse#close.The Controller Class returns an instance of StreamResponse and the streaming is performed a floating Promise above the return statement.\nimport { prefix, get, StreamResponse, type VovkRequest } from 'vovk';\nimport StreamService, { type Token } from './StreamService';\n@prefix('stream')\nexport default class StreamController {\n  @get('tokens')\n  static async streamTokens() {\n    const resp = new StreamResponse<Token>();\n    void StreamService.streamTokens(resp);\n    return resp;\n  }\n}\nStreamResponse class also provides throw methods that safely closes the stream and makes the client to re-throw the received error.\nawait resp.throw(new Error('Stream error'));","live-text-streaming-example-with-streamresponse-class#Live Text Streaming Example with StreamResponse Class":"Source code"}},"/getting-started":{"title":"Getting Started","data":{"quick-install#Quick install":"Setup Vovk.ts with create-next-app.\nnpx create-next-app -e https://github.com/finom/vovk-hello-world\nInside the project folder run npm run dev and open http://localhost:3000.","manual-install#Manual install":"","create-nextjs-project-with-app-router#Create Next.js project with App Router":"Follow this instruction to install Next.js. Use TypeScript, App Router and src/ directory.\nnpx create-next-app\nChoices example:","install-vovkts-and-concurrently#Install Vovk.ts and Concurrently":"At the newly created folder run:\nnpm i vovk vovk-client\npnpm i vovk vovk-client\nyarn add vovk vovk-client\nThen install concurrently, the recommended way to run Vovk.ts and Next.js together.\nnpm i concurrently --save-dev\npnpm i concurrently --dev\nyarn add concurrently --dev","enable-decorators#Enable decorators":"In your tsconfig.json set \"experimentalDecorators\" to true.\n{\n    \"compilerOptions\": {\n        \"experimentalDecorators\": true,\n        // ...\n    }\n}","set-up-nextjs-wildcard-route-handler-and-export-types-read-by-the-client-library#Set up Next.js wildcard route handler and export types read by the client library":"Create file /src/app/api/[[...vovk]]/route.ts where [[...vovk]] is a folder name indicating what Next.js documentation calls \"Optional Catch-all Segment\" that can be customized. This is the core entry point for all Vovk.ts routes.\nimport { initVovk } from 'vovk';\nexport const runtime = 'edge';\nconst controllers = {};\nconst workers = {};\n// export types used by the client\nexport type Controllers = typeof controllers;\nexport type Workers = typeof workers;\nexport const { GET, POST, PUT, DELETE } = initVovk({ controllers, workers });\nEnabling Edge Runtime is optional.","create-first-controller-and-add-it-to-the-controller-object#Create first controller and add it to the controller object":"Create HelloController.ts at /src/modules/hello/ with same-named static class.\nimport { get, prefix } from \"vovk\";\n@prefix('hello') // prefix is optional\nexport default class HelloController {\n    @get('greeting')\n    static getHello() {\n        return { greeting: 'Hello world!' };\n    }\n}\nAnd add this class at /src/app/api/[[...vovk]]/route.ts to the controllers object.\nimport HelloController from '../../../modules/hello/HelloController';\n// ...\nconst controllers = { HelloController };\n// ...\nThe code above creates GET endpoint to /api/hello/greeting. You can also use named export for the controller if needed.","run-vovk-dev-and-next-dev-with-concurrently#Run vovk dev and next dev with concurrently":"Create an NPM script in package.json that runs vovk dev and next dev together specifying the port explicitly.\nVovk server also utilises the port by adding 6969 number to it (if Next.js PORT is 3000, Vovk.ts port is 9969).Vovk.ts works by exchanging data between Next.js and Vovk Server, which means knowing the ports on both sides is essential.\n\"scripts\": {\n    \"dev\": \"PORT=3000 concurrently 'vovk dev' 'next dev' --kill-others\"\n}\nOnce you run npx run dev you're going to notice the new file .vovk.json created in the root of your project. This file contains required information to build the client and it needs to be committed.\nIt's going to be updated automatically when your project structure is changed. Open http://localhost:3000.Alternatively, you can use use built-in concurrently-like process runner to run both servers and assign ports automatically.\nnpx vovk dev --next-dev\nBesides .vovk.json the command also generates client .js and .ts files inside node_modules/.vovk that are re-exported by vovk-client module to make no error if vovk-client is not installed. This approach is borrowed from Prisma ORM.","create-a-react-component#Create a React component":"Now the client is generated you can safely import your client library from vovk-client.\n'use client';\nimport { useState } from 'react';\nimport { HelloController } from 'vovk-client';\nimport type { VovkReturnType } from 'vovk';\nexport default function MyComponent() {\n  const [serverResponse, setServerResponse] = useState<VovkReturnType<typeof HelloController.getHello>>();\n  return (\n    <>\n      <button\n        onClick={async () => {\n          const response = await HelloController.getHello();\n          setServerResponse(response);\n        }}\n      >\n        Get Greeting from Server\n      </button>\n      <div>{serverResponse?.greeting}</div>\n    </>\n  );\n}\nNote that if you're using VSCode you're probably going to need to restart TS server each time when you add a new controller or WPC class to your app because by the time being TS Server doesn't update types imported from node_modules automatically when they were changed. This is a well-known problem that bothers Prisma ORM developers for long time. In all other scenarios (when you add a new method, change body type, etc) you don't need to do that since TS server reads Controllers and Workers that you export from /src/app/api/[[...vovk]]/route.ts.Next.js Server Components are also supported but require to define absolute URL (by default all requests are made to /api). Check the Server Component Example for more information.The only argument of methods of the generated library has approximately the following signature:\ninterface Options extends Omit<RequestInit, 'body' | 'method'> {\n  reactNative?: { textStreaming: boolean };\n  prefix?: string;\n  disableClientValidation?: boolean;\n  body: VovkBody<typeof Controller.method>\n  params: VovkParams<typeof Controller.method>\n  query: VovkQuery<typeof Controller.method>\n}\nIn other words it supports custom Next.js options (because Next.js extends RequestInit global type) as well as React Native Fetch API.\nawait HelloController.hello({\n  body: { foo: 'bar' },\n  next: { revalidate: 3600 },\n});","live-example#Live Example":"Source code","build-and-deploy#Build and deploy":"You're going to need to run npx vovk generate to generate the client before the build with the standard npx next build or when node_modules are re-installed.To easily build the project on Vercel you can create \"vercel-build\" npm script at package.json.\n\"scripts\": {\n    \"vercel-build\": \"vovk generate && next build\"\n}"}},"/worker":{"title":"WPC Class (Worker Procedure Call)","data":{"":"The standard Web Workers are awesome but they require to write additional logic by using onmessage handler on both sides (main thread and the Woker thread) and exchange data using postMessage. Vovk.ts applies the same principle that is used at controllers and builds main-thread client-side library using the auto-generated .vovk.json. It uses built-in browser API aush as addEventListener and postMessage and does not utilise eval function or Function constructor.WPC Class is created from an Isomorphic Service Class by applying @worker() class decorator that defines onmessage handler in the Web Worker scope.\nQuick explanation: Isomorphic Service Class is a static class that provides code that is shared between front-end and back-end. It should implement static methods as pure functions that don't have access to neither application state nor server-side capabilities such as access to the database.\nimport { worker } from 'vovk';\n@worker()\nexport default class HelloWorker {\n    static heavyCalculation(iterations: number) {\n        let result: number;\n        // ... heavy calculations\n        return result;\n    }\n}\nIn a non-worker scope @worker() does nothing. You can import the class safely in other modules, including back-end code where it's going to be behave as a normal collection of pure functions.To compile the worker interface, you need to pass them to initVovk as workers object option and export the type of this object as Workers.\nimport { initVovk } from 'vovk';\nimport HelloController from '../../../hello/HelloController';\nimport HelloWorker from '../../../hello/HelloWorker';\nimport ByeWorker from '../../../bye/ByeWorker';\nconst controllers = { HelloController };\nconst workers = { HelloWorker, ByeWorker };\nexport type Controllers = typeof controllers;\nexport type Workers = typeof workers;\nexport const { GET, POST, PUT, DELETE } = initVovk({ controllers, workers });\nOnce this is done, vovk-client is going to export the worker library that provides interface to invoke heavy calculations but doesn't initialise the Web Worker itself. To initialise the Web Worker at the main-thread interface it needs to be instantiated normally and passed as an argument of employ static method.\nimport { HelloWorker } from 'vovk-client';\nHelloWorker.employ(new Worker(new URL('./path/to/HelloWorker.ts', import.meta.url)));\nThis bulky syntax is required to invoke the Webpack 5+ loader used by Next.js internally. After it's done the static methods of the mapped class type return Promise to delegate heavy calculations to the parallel thread.\nconst result = await HelloWorker.heavyCalculation(1e9);\nNote that Worker class does not exist in Next.js SSR environment and in case if the code is exposed to non-client-side environment (for example outside of useEffect) it's recommended to check if Worker exists at the global scope.\nimport { HelloWorker } from 'vovk-client';\nif(typeof Worker !== 'undefined') {\n    HelloWorker.employ(new Worker(new URL('./path/to/HelloWorker.ts', import.meta.url)));\n}\nemploy method returns the worker interface itself so as a nicer solution you can use ternary operator to make the Worker library to be nullish.\nimport { HelloWorker } from 'vovk-client';\nconst MyWorker = typeof Worker === 'undefined' \n    ? null \n    : HelloWorker.employ(new Worker(new URL('./path/to/HelloWorker.ts', import.meta.url)));\nawait MyWorker?.heavyCalculation(1e9);","worker-termination#Worker termination":"A worker can be terminated with built-in terminate method.\nHelloWorker.terminate();","async-generators#Async generators":"WPC classes support generators and async generators to implement continious event streaming.\nimport { worker } from 'vovk';\n@worker()\nexport default class HelloWorker {\n    static *generator() {\n        for (let i = 0; i < 10; i++) {\n            yield i;\n        }\n    }\n    static async *asyncGenerator() {\n        for (let i = 0; i < 10; i++) {\n            await new Promise((resolve) => setTimeout(resolve, 100));\n            yield i;\n        }\n    }\n}\nVovk.ts turns them both into async generators when they're imported from vovk-client.\nimport { HelloWorker } from 'vovk-client';\n// ... plug in the Web Worker with \"use\" method ...\nfor await (const number of HelloWorker.generator()) {\n    console.log(number); // 0 ... 9\n}\nfor await (const number of HelloWorker.asyncGenerator()) {\n    console.log(number); // 0 ... 9\n}","making-http-requests-inside-a-wpc-class#Making HTTP requests inside a WPC Class":"Since Web Workers are run in a browser (but just in another thread) it's capable to fetch server-side data as expected.\nimport { get } from 'vovk';\nexport class HelloController {\n    @get.auto()\n    static getIterations() {\n        return { iterations: 100_000_000 };\n    }\n}\nimport { HelloController } from 'vovk-client';\n@worker()\nexport default class HelloWorker {\n    static async heavyCalculation() {\n        const { iterations } = await HelloController.getIterations();\n        let result: number;\n        // ...\n        return result;\n    }\n}","using-wpc-class-inside-another-wpc-class#Using WPC Class inside another WPC Class":"Workers can use other workers. The syntax remains the same and you don't need to check for Worker variable to exist.\nimport { AnotherWorker } from 'vovk-client';\nAnotherWorker.employ(new Worker(new URL('./path/to/AnotherWorker.ts', import.meta.url)));\nexport default class HelloWorker {\n    heavyCalculation() {\n        const anotherWorkerResult = await AnotherWorker.doSomethingHeavy();\n        // ...\n    }\n}","forking-the-worker#Forking the Worker":"To fork the worker and create as many parallel processes as needed you can use fork method instead of employ.\nimport { HelloWorker } from 'vovk-client';\nfunction getFork() {\n    return HelloWorker.fork(new Worker(new URL('./path/to/HelloWorker.ts', import.meta.url)));\n}\nconst HelloWorker1 = getFork();\nconst HelloWorker2 = getFork();\nconst HelloWorker3 = getFork();\nconst [result1, result2, result3] = await Promise.all([\n    HelloWorker1.heavyCalculation(),\n    HelloWorker2.heavyCalculation(),\n    HelloWorker3.heavyCalculation(),\n]);","live-worker-example#Live Worker Example":"Source code"}}}