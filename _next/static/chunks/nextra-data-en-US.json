{"/blog/vovk-2-0":{"title":"Vovk.ts 2.0 is here!","data":{"vovkts-20-is-here#Vovk.ts 2.0 is here!":"","breaking-changes#Breaking changes":"The version 1 is heavily tested in production and the community feedback is taken into account. Great news is that no significant bugs are found since then! The main purpose of breaking changes in this release is to make Vovk more consistent and easier to use.\n‚úÖ Renamed some types so that often used types are shorter and easier to type:\nVovkReturnType -> VovkControllerReturnType\nVovkBody -> VovkControllerBody\nVovkQuery -> VovkControllerQuery\nVovkParams -> VovkControllerParams\nVovkYieldType -> VovkControllerYieldType\nVovkClientReturnType -> VovkReturnType\nVovkClientBody -> VovkBody\nVovkClientQuery -> VovkQuery\nVovkClientParams -> VovkParams\nVovkClientYieldType -> VovkYieldType\n‚úÖ Replaced --no-next-dev flag with --next-dev flag in order to make it not run Next.js development server by default. In other words concurrently is now a recommended way to run Vovk and Next.js development servers together. This reduces potential problems with built-in command runner in Vovk.ts but also reduces very relevant confusion for new users.\nWithout Concurrently:\nBefore: vovk dev\nAfter: vovk dev --next-dev - not recommended but can be useful in some cases.\nWith Concurrently:\nBefore: PORT=3000 concurrently \"vovk dev --no-next-dev\" \"next dev\" --kill-others\nAfter: PORT=3000 concurrently \"vovk dev\" \"next dev\" --kill-others - this is the new recommended way to run Vovk and Next.js development servers together.\n‚úÖ Renamed worker.use to worker.employ to make it less confusing in React components.","minior-changes#Minior changes":"onError option of initVovk now gets request object as the second argument. This is useful if you want to extract some information about request like headers, method, authorisation, etc.\nimport { initVovk } from 'vovk';\nimport ErrorService from '../../modules/ErrorService';\n// ...\nconst { GET, POST, PUT, DELETE } = initVovk({\n    controllers,\n    workers,\n    onError: (error, request) => {\n      ErrorService.logError(error, request);\n    }\n});"}},"/blog":{"title":"Blog","data":{}},"/controller/client":{"title":"Client Library","data":{"":"initVovk performs required actions to generate client-side library and no additional action from your side is required (but you probably would need to restart TS Server to update types if you use VSCode when a new controller is added).The client library implements the same methods (in our case updateUser) but changes the method interface so you can pass required input data as options (body, query and params). vovk-client can be used in client components, server components, application state and even be distributed as a standalone package. For an illustration vovk-examples is published as a standalone NPM package to be used on vovk.dev that, by itself, is a static website powered by gh-pages.Everything exported from vovk-client is plain old JavaScript with typings that calls the regular fetch function.\nimport { UserController } from 'vovk-client';\n// ...\nconst updatedUser = await UserController.updateUser({\n    body: { firstName, lastName },\n    query: { role: 'admin' },\n    params: { id: '69' },\n});\n// same as\nfetch('/api/users/69?role=admin', {\n    method: 'PUT',\n    body: JSON.stringify({ firstName, lastName }),\n});\nIt's worthy to mention that client library can be customised in order to follow custom logic required by the application.\n await UserController.updateUser({\n    // ...\n    successMessage: 'Successfully created the user',\n    someOtherCustomFlag: true,\n});"}},"/cli":{"title":"CLI","data":{"vovk-dev#vovk dev":"The command runs Vovk Server expecting to be run together with Next.js dev server. It uses PORT variable to define its own port by adding 6969 to it. For example, if Next.js server runs on port 3000, Vovk Server will run on port 9969.It's recommended to use vovk dev and next dev together with concurrently or similar library. Here is an example of how to run them simultaneously:\nPORT=3000 npx concurrently 'vovk dev' 'next dev' --kill-others\nSince both Vovk Server and Next.js know the port of each other they can communicate in order to build .vovk.json and node_modules/.vovk files.","vovk-dev---next-dev#vovk dev --next-dev":"You can avoid using concurrently by running vovk dev with --next-dev flag. This command runs next dev by itself and assigns the port automatically.\nThe built-in commands runner works fine, but is not tested as good as concurrently. Use it at your own risk.","vovk-generate#vovk generate":"Generates the client based on .vovk.json and creates .js and .d.ts files at node_modules/.vovk that are re-exported by vovk-client. .vovk.json is generated via vovk dev.vovk generate as well as vovk dev accept --clientOut flag that indicates where client needs to be generated.\nnpx vovk generate --clientOut=my-custom-folder\nAll other commands such as next build and next start remain the same since the project is a normal Next.js application.","available-env-variables#Available env variables":"Environment variables allow to customize Vovk.ts behaviour by overriding configuration optionally defined at vovk.config.js. You can find more information about it at vovk.config.js documentation. Here is a quick ref:\nPORT=3000 - defines port for Next.js server that is also utilised by the Vovk Server.\nVOVK_PORT=3690 - a custom Vovk Server port.\nVOVK_CLIENT_OUT=./node_modules/.vovk - where the client needs to be compiled to.\nVOVK_ROUTE=./src/app/api/[[...vovk]]/route.ts - allows to redefine path to the wildcard route.\nVOVK_MODULES_DIR=./src/modules - defines the root directory where the modules are located.\nVOVK_FETCHER=vovk/client/defaultFetcher - allows to customize the fetching function that used internally by the client.\nVOVK_PREFIX=/api - defines the root endpoint used by fetch function at the client.\nVOVK_VALIDATE_ON_CLIENT - defines client-side validation library. If vovk-zod is installed but VOVK_VALIDATE_ON_CLIENT is not redefined it's value going to be set to \"vovk-zod/zodValidateOnClient\"."}},"/config":{"title":"vovk.config.js","data":{"":"The config file allows to change default options in order to customise generated client or its path. The default config looks like that:\n/** @type {import('vovk').VovkConfig} */\nconst vovkConfig = {\n    clientOut: './node_modules/.vovk',\n    route: './src/app/api/[[...vovk]]/route.ts',\n    modulesDir: './src/modules',\n    fetcher: 'vovk/client/defaultFetcher',\n    prefix: '/api',\n    validateOnClient: '',\n};\n                                                                        \nmodule.exports = vovkConfig;\nclientOut - where the client is going to be compiled to. Can be overriden by VOVK_CLIENT_OUT env variable.\nroute - allows to redefine path to the wildcard route (the slug can be any non-empty string, it's name is not utilised by Vovk.ts). Can be overriden by VOVK_ROUTE env variable.\nmodulesDir - defines the root directory where the modules are located. Can be overriden by VOVK_MODULES_DIR env variable. Used to watch for changes in the modules and recompile the client. You can set it to \"./src\" to watch for changes in the whole project.\nfetcher - allows to customize the fetching function that used internally by the client. Can be overriden by VOVK_FETCHER env variable. See the next section for more info.\nprefix - defines the root endpoint used by fetch function at the client. Can be overriden by VOVK_PREFIX env variable.\nvalidateOnClient - defines client-side validation library. If vovk-zod is installed but validateOnClient is not redefined it's value going to get value \"vovk-zod/zodValidateOnClient\". Can be overriden by VOVK_VALIDATE_ON_CLIENT env variable.\nThe config can be also defined as vovk.config.cjs but also as an ES Module named vovk.config.mjs:\n/** @type {import('vovk').VovkConfig} */\nconst vovkConfig = {\n    // ...\n};\nexport default vovkConfig;"}},"/controller/errors":{"title":"Errors: HttpException class and HttpStatus enum","data":{"":"You can gracefully throw HTTP exceptions similarly to NestJS. HttpException class accepts 2 arguments. The first one is an HTTP code that can be retrieved from HttpStatus, the other one is an error text.\nimport { HttpException, HttpStatus } from 'vovk';\n// ...\nstatic async updateUser(/* ... */) {\n    // ...\n    throw new HttpException(HttpStatus.BAD_REQUEST, 'Something went wrong');\n}\nThe errors are re-thrown at the client library with the same interface.\nimport { UserController } from 'vovk-client';\nimport { HttpException } from 'vovk';\n// ...\ntry {\n    const updatedUser = await UserController.updateUser(/* ... */);\n} catch(e) {\n    console.log(e instanceof HttpException); // true\n    const err = e as HttpException;\n    console.log(err.message, err.statusCode);\n}\nRegular errors such as Error are equivalent to HttpException with code 500.\nimport { HttpException, HttpStatus } from 'vovk';\n// ...\nstatic async updateUser(/* ... */) {\n    // ...\n    throw new Error('Something went wrong'); // 500\n}\nYou can also throw custom objects that are going to be re-thrown on the client-side as is.\nthrow { hello: 'World' };"}},"/controller/return":{"title":"Return Type","data":{"custom-object#Custom object":"The decorated static methods of controllers can return several kinds of objects. The most common is a regular object initializer. Let's say your controller method returns Prisma ORM invocation.\n// ...\nstatic async updateUser(/* ... */) {\n    // ...\n    const updatedUser = await prisma.user.update({\n        where: { id },\n        data,\n    });\n    return updatedUser;\n}\n// ...\nAt this case the returned value of client method UserController.updateUser is going to be recognised as User generated at @prisma/client.","response-object#Response object":"HTTP handlers can also return regular Response object, for example NextResponse.\n// ...\nstatic async updateUser(/* ... */) {\n    // ...\n    return NextResponse.json(updatedUser, { status: 200 });\n}\n// ...\nAt this case client library wouldn't be able to properly recognise type of returned value but you can override the type manually by using generic argument that overrides the return type without need to convert it to unknown first.\nimport { UserController } from 'vovk-client';\nimport type { User } from '@prisma/client';\n// ...\nconst updatedUser = await UserController.updateUser<User>(/* ... */);","async-iterable#Async iterable":"// ...\nstatic async *updateUser(/* ... */) {\n    // ...\n    yield* iterable;\n}\n// ...\nIf iterable is returned, the client library is going to cast the method as a disposable async generator to implement response streaming. It's explained in more details on the Streaming documentation page."}},"/controller/service":{"title":"Service","data":{"service-class#Service Class":"In order to make the code cleaner it's recommended to move most of the logic to Back-end Services. Back-End Service is a static class that serves as a library that performs database and third-party API calls outside of Controller Classes.Let's say you have the following Controller Class:\n// /src/modules/user/UserController.ts\nimport { prefix, put, type VovkRequest } from 'vovk';\nimport type { User } from '../../types';\n@prefix('users')\nexport default class UserController {\n    @put(':id') \n    static async updateUser(req: VovkRequest<Partial<User>>, { id }: { id: string }) {\n        const data = await req.json();\n        const updatedUser = await prisma.user.update({\n            where: { id },\n            data,\n        });\n        return updatedUser;\n    }\n}\nCurrently it looks fine since it doesn't contain a lot of logic. But as your app is getting more complex you're going to get more handlers with more code. At this case it's recommended to move part of the logic to Back-End Service Class making controllers to be responsible for input extraction, validation and authorisation, but not for DB or API calls.Let's refactor the code above by introducing UserService. For this example it's going to be small but I hope that illustrates the idea clearly.\n// /src/modules/user/UserService.ts\n// ... import types and libraries ...\nexport default class UserService {\n    static updateUser(id: string, data: Partial<User>) {\n        return prisma.user.update({\n            where: { id },\n            data,\n        });\n    }\n}\nAs you can see, UserService does not use decorators and used as a library that performs required side-effects.\n// /src/modules/user/UserController.ts\nimport { prefix, put, type VovkRequest } from 'vovk';\nimport UserService from './UserService'\n@prefix('users')\nexport default class UserController {\n    @put(':id') \n    static async updateUser(req: VovkRequest<Partial<User>>, { id }: { id: string }) {\n        const data = await req.json();\n        return UserService.updateUser(id, data);\n    }\n}\nBack-End Service Classes can use other Back-End Services (as well as so-called Isomorphic Service Classes explained in separate article of this documentation).\n// /src/modules/user/UserService.ts\nimport PostService from '../post/PostService';\nimport CommentService from '../comment/CommentService';\n// ... other imports ...\nexport default class UserService {\n    static async updateUser(id: string, data: Partial<User>) {\n        const latestPost = PostService.findLatestUserPost(id);\n        const latestPostComments = CommentService.findPostComments(latestPost.id);\n        // ...\n    }\n}"}},"/controller/type":{"title":"Type","data":{"type-extraction#Type extraction":"vovk module provides a collection of useful types that described in more details at API documentation. It's worthy to mention the most oftenly used types here:\nimport { UserController, StreamController } from 'vovk-client';\nimport type { VovkBody, VovkQuery, VovkParams, VovkReturnType, VovkYieldType } from 'vovk';\n// infer body\ntype Body = VovkBody<typeof UserController.updateUser>;\n// infer query\ntype Query = VovkQuery<typeof UserController.updateUser>;\n// infer params\ntype Params = VovkParams<typeof UserController.updateUser>;\n// infer return type\ntype Return = VovkReturnType<typeof UserController.updateUser>;\n// infer yield type from stream methods\ntype Yield = VovkYieldType<typeof StreamController.streamTokens>;\nFor example, if you want to create a custom function that makes requests to the server, you can borrow types from the client to build the arguments.\nimport { UserController } from 'vovk-client';\nimport type { VovkBody, VovkQuery } from 'vovk';\nexport function updateUser(\n    id: VovkQuery<typeof UserController.updateUser>['id'],\n    body: VovkBody<typeof UserController.updateUser>,\n) {\n    return UserController.updateUser({\n        body,\n        query: { id },\n    });\n}\nThe exported updateUser can be called the following way:\nimport { updateUser } from './wherever-you-put-it';\n// ...\nawait updateUser('69', { firstName: 'John', lastName: 'Doe' });"}},"/controller/streaming":{"title":"Text Streaming for LLMs","data":{"":"Vovk.ts provides two ways to implement text response streaming requred for applications that utilise the AI completions.","async-iterators#Async iterators":"Controller methods can implement generators that use * syntax and utilise yield keyword instead of regular return.\n// /src/modules/stream/StreamController.ts\nimport { get, prefix } from 'vovk';\ntype Token = { message: string };\n@prefix('stream')\nexport default class StreamController {\n  @get('tokens')\n  static async *streamTokens() {\n    const tokens: Token[] = [\n      { message: 'Hello,' },\n      { message: ' World' },\n      { message: '!' },\n    ];\n    for (const token of tokens) {\n      await new Promise((resolve) => setTimeout(resolve, 300));\n      yield token;\n    }\n  }\n}\nIn order to refactor this code and utilise Back-end Service you can move the streaming logic to StreamService static class.\n// /src/modules/stream/StreamService.ts\ntype Token = { message: string };\nexport default class StreamService {\n  static async *streamTokens() {\n    const tokens: Token[] = [\n      { message: 'Hello,' },\n      { message: ' World' },\n      { message: '!' },\n    ];\n    for (const token of tokens) {\n      await new Promise((resolve) => setTimeout(resolve, 300));\n      yield token;\n    }\n  }\n}\nAt the controller use yield* syntax to delegate iterable returned from StreamService.streamTokens.\nimport { get, prefix } from 'vovk';\nimport StreamService from './StreamService';\n@prefix('stream')\nexport default class StreamController {\n  @get('tokens')\n  static async *streamTokens() {\n    yield* StreamService.streamTokens();\n  }\n}","streamresponse-class#StreamResponse Class":"In some cases it's too hard to use generators to implement response streaming. Vovk.ts introduces StreamResponse class inherited from Response class that uses TransformStream#readable as body and adds required HTTP headers.\nIt's a lower-level API that is used behind the scenes to implement generator logic explained above.\nService method at this case is implemented as a regular function that accepts StreamResponse instance as a pointer to send messages manually.There is what the streaming service might look like:\n// /src/modules/stream/StreamService.ts\nimport type { StreamResponse } from 'vovk';\nexport type Token = { message: string };\nexport default class StreamService {\n  static async streamTokens(resp: StreamResponse<Token>) {\n    const tokens: Token[] = [\n      { message: 'Hello,' },\n      { message: ' World' },\n      { message: '!' },\n    ];\n    for (const token of tokens) {\n      await new Promise((resolve) => setTimeout(resolve, 300));\n      resp.send(token);\n    }\n    resp.close();\n  }\n}\nAs you can see tokens are sent using StreamResponse#send method and, when the stream is completed, it needs to be closed with StreamResponse#close.The Controller Class returns an instance of StreamResponse and the streaming is performed a floating Promise above the return statement.\nimport { prefix, get, StreamResponse, type VovkRequest } from 'vovk';\nimport StreamService, { type Token } from './StreamService';\n@prefix('stream')\nexport default class StreamController {\n  @get('tokens')\n  static async streamTokens() {\n    const resp = new StreamResponse<Token>();\n    void StreamService.streamTokens(resp);\n    return resp;\n  }\n}\nStreamResponse class also provides throw methods that safely closes the stream and makes the client to re-throw the received error.\nawait resp.throw(new Error('Stream error'));","handling-stream-responses-on-the-client#Handling Stream Responses on the Client":"Both ways of response streaming generate client method that returns a disposable async generator.\nimport { StreamController } from 'vovk-client';\n{\n    using stream = await StreamController.streamTokens();\n    for await (const token of stream) {\n        console.log(token);\n    }\n}\nusing keyword (that you can freely replace by let or const) indicates that when code block is reached the end (in case of early break or if the code block encountered an error) the stream is going to be closed by invoking stream.close() method automatically. stream.close() can also be called explicitly if needed.To make sure that the stream is closed before moving to the next code block you can use await using syntax that disposes the stream asynchronous way.\nimport { StreamController } from 'vovk-client';\n{\n    await using stream = await StreamController.streamTokens();\n    // ...\n}\n// on this line stream is already closed"}},"/customization":{"title":"Customizing the Fetcher and Default Client Options","data":{"":"You can redefine the default fetching function and its options to tightly integrate Vovk.ts client with your application state or to add extra features. For example, the clientized controller methods may look like that:\nimport { UserController } from 'vovk-client';\n// ...\nUserController.createUser({ \n    body,\n    query,\n    // custom options\n    successToast: 'Successfully created a new user',\n    useAuth: true,\n    sentryLogErrors: true,\n});\nThe fetcher is defined as a default export that extends VovkClientFetcher type and should be listed either as config option:\n/** @type {import('vovk').VovkConfig} */\nconst vovkConfig = {\n    fetcher: './src/lib/myFetchingFunction',\n};\nmodule.exports = vovkConfig;\nOr as VOVK_FETCHER env variable:\nVOVK_FETCHER=\"./src/lib/myFetchingFunction\" vovk dev\nBy default Vovk.ts uses fetcher defined at vovk/client/defaultFetcher and you can check its source code on Github.The fetcher accepts two arguments:\nAn object that is provided by the internal Vovk.ts code that includes HTTP method information and utilities:\nhttpMethod - the HTTP metod;\ngetEndpoint - an utility that builds request endpoiint from prefix, query and params;\nvalidate - a function that validates body and query of the request;\ndefaultHandler - handles the Response object returned from fetch function;\ndefaultStreamHandler - handles the Response object returned from fetch function in case of a stream.\nRequest arguments:\nparams - the patams such as id from users/:id;\nquery - the search query properties such as ?foo=bar;\nbody - the request body;\nprefix - what's defined as prefix property at vovk.config.js or passed directly to the client method;\nThe rest options - your custom options and RequestInit (including custom Next.js options) that includes the rest fetch options such as headers, credentials etc.\nYour custom fetcher with a custom option successMessage may look like that:\nimport type { VovkDefaultFetcherOptions, VovkClientFetcher } from 'vovk';\n// in order to keep default features such as disableClientValidation, headers etc,\n// it's recommended to extend custom options from VovkDefaultFetcherOptions\ninterface MyOptions extends VovkDefaultFetcherOptions {\n    successMessage: string;\n}\nconst myCustomFetcher: VovkClientFetcher<MyOptions> = async (\n  { httpMethod, getEndpoint, validate, defaultHandler, defaultStreamHandler },\n  { params, query, body, prefix = '/api', successMessage, ...options }\n) => {\n  // 1. Build the endpoint\n  const endpoint = getEndpoint({ prefix, params, query });\n  // 2. Validate\n  if (!options.disableClientValidation) {\n    await validate({ body, query });\n  }\n  // 3. Make fetch request (here you can add authorisation headers)\n  const response = await fetch(endpoint, {\n    method: httpMethod,\n    body: JSON.stringify(body),\n    ...options,\n  });\n  let returnResponse = response;\n  // 4. Handle response based on response headers\n  if (response.headers.get('content-type')?.includes('application/json')) {\n    returnResponse = await defaultHandler(response);\n  }\n  if (response.headers.get('content-type')?.includes('text/event-stream')) {\n    returnResponse = await defaultStreamHandler(response);\n  }\n  // 5. Utilise your custom option somehow.\n  alert(successMessage);\n  return returnResponse;\n};\nexport default myCustomFetcher;\nAs you can see the code determines response type by content-type header. You can freely redefine this logic to make the fetcher return something else.\nif (response.headers.get('content-type')?.includes('application/json')) {\n  return yourCustomHandler(response);\n}\nIn case if the server endpoint and yourCustomHandler return different values, you can redefine the inferred return type using the client method generic argument.\nimport { MyController } from 'vovk-client';\n// ...\nconst result = MyController.myMethod<{ foo: 'bar' }>({\n  body,\n  successMessage: 'Success!'\n})\nThe result variable from this example is going to receive { foo: 'bar' } type.","creating-a-custom-validation-library#Creating a custom validation library":"If you need to create your custom validation library, check decorators documentation."}},"/decorators/authorization":{"title":"Authorization with Decorators","data":{"":"There is an example code that defines authGuard decorator that does two things:\nChecks if a user is authorised and returns an Unauthorised status if not.\nAdds currentUser to the request object.\nTo extend req object you can define your custom interface that extends VovkRequest. Let's imagine that Prisma ORM is used at the project.\n// /src/types.ts\nimport type { VovkRequest } from 'vovk'\nimport type { User } from '@prisma/client';\nexport interface GuardedRequest<BODY = undefined, QUERY extends Record<string, string> | undefined = undefined>\n  extends VovkRequest<BODY, QUERY> {\n  currentUser: User;\n}\nThen define the authGuard decorator itself.\n// /src/decorators/authGuard.ts\nimport { HttpException, HttpStatus, createDecorator } from 'vovk';\nimport type { GuardedRequest } from '../types';\nconst authGuard = createDecorator(async (req: GuardedRequest, next) => {\n  // ... define userId and isAuthorised\n  // parse access token for example\n  if (!isAuthorised) {\n    throw new HttpException(HttpStatus.UNAUTHORIZED, 'Unauthorized');\n  }\n  const currentUser = await prisma.user.findUnique({ where: { id: userId } });\n  req.currentUser = currentUser;\n  return next();\n});\nexport default authGuard;\nAnd finally use the decorator and define request object with your newly created GuardedRequest type.\n// ...\nexport default class UserController {\n  // ...\n  @get('current-user')\n  @authGuard()\n  static async getCurrentUser(req: GuardedRequest</* ... */>) {\n    return req.currentUser;\n  }\n  // ...\n}"}},"/decorators":{"title":"Controller Decorators Overview","data":{"":"createDecorator is a higher-order function that produces a decorator factory (a function that returns a decorator) for Controller Classes. It accepts a middleware function with the following parameters:\nrequest, which extends NextRequest as well as VovkRequest.\nnext, a function that should be invoked and its result returned to call subsequent decorators or the route handler.\nAdditional arguments are passed through to the decorator factory.\nThe second argument of createDecorator is an optional init handler. It's called every time when decorator is initialised and it's used to populate .vovk.json with information on client-side validation described at Validation docs.\nimport { createDecorator, get, HttpException, HttpStatus } from 'vovk';\nconst myDecorator = createDecorator((req, next, a: string, b: number) => {\n  console.log(a, b); // Outputs: \"foo\", 1\n  if(isSomething) { \n    // override route method behavior and return { hello: 'world' } from the endpoint\n    return { hello: 'world' };\n  }\n  if(isSomethingElse) {\n    // throw HTTP error if needed\n    throw new HttpException(HttpStatus.BAD_REQUEST, 'Something went wrong');\n  }\n  return next();\n}, (a: string, b: number) => {\n    console.info('Decorator is initialised with', a, b);\n});\nclass MyController {\n  @get.auto()\n  @myDecorator('foo', 1) // Passes 'foo' as 'a', and 1 as 'b'\n  static doSomething() {\n    // ...\n  }\n}"}},"/sponsor":{"title":"‚ô•Ô∏è Sponsor","data":{"":"Constantly balancing between my family, full-time job, quality sleep, and open-source projects is not easy. I am grateful to everyone who supports me in my endeavors. If you like my work and want to support me, you can do it by sponsoring me on GithubIf you want to contact me, my email can be found on my Github profile."}},"/framework":{"title":"Project Framework","data":{"":"This page explains how you could structure an application introducing a framework that you can optionally apply to a large project that uses Vovk.ts.The framework combines back-end and front-end code into a single code base. The logical parts of the app are split into folders called \"modules\" given them corresponding name such as user, post, comment, app settings, auth features etc. Basically, a \"module\" can belong to 2 categories:\nAn entity (a model) like \"user\" (or \"post\", \"comment\" etc).\nAnything what doesn't belong to some specific entity: app settings, auth, AI stuff...\nThe typical structure of files and folders in a Vovk.ts app would look like that:\nEvery item in a module folder (Service Class, Controller Class, state etc) is optional. Some parts of your app would require to have state only, but no controller.\nIn other case you can have a state and a controller, but database request in your controller is too simple to create a separate service class...The image below illustrates how different components of the application can be related to each other.","controller-class#Controller Class":"Controller Class is a static class that defines API endpoints. It can use Back-End Service Classes and Isomorphic Service Classes explained below.\n// /src/modules/post/PostController.ts\nimport { prefix, get } from 'vovk';\nimport PostService from './PostService';\n@prefix('post')\nexport default class PostController {    \n    @get()\n    static getPosts() {\n        return PostService.getPosts();\n    }\n}\nDecorators created with createDecorator make possible to validate request, throw errors, redirect, or return something different to the client.\n// /src/modules/post/PostController.ts\nimport { prefix, get, type VovkRequest } from 'vovk';\nimport vovkZod from 'vovk-zod';\nimport { z } from 'zod';\nimport { authGuard } from '../../decorators';\nimport PostService from './PostService';\n@prefix('post')\nexport default class PostController {    \n    @put(':postId')\n    @authGuard()\n    @vovkZod(\n        z.object({\n            title: z.string()\n            content: z.string(),\n        }).strict(),\n        z.object({\n            moderationType: z.string(),\n        }).strict()\n    )\n    static updatePost(\n        req: VovkRequest<{ title: string; content: string; }, { moderationType: 'nice' | 'strict' }>, \n        { postId }: { postId: string }\n    ) {\n        const { title, content } = req.json();\n        const moderationType = req.nextUrl.searchParams.get('moderationType');\n        return PostService.updatePost(postId, title, content, moderationType);\n    }\n}\nThe example above implements PUT endpoint that looks like that: /api/post/69?moderationType=nice.\nauthGuard is a custom decorator that may be created by you based on your authorisation environment.\nvovkZod that's imported from vovk-zod performs Zod validation of body and query both on server-side and client-side.\nVovkRequest generic partially re-defines NextRequest type and makes req.json as well as req.nextUrl.searchParams.get return proper types.\nPostService.updatePost is invoked with properly-typed arguments after authorisation check, body and query validation.","back-end-service-class#Back-end Service Class":"Back-end Service Class (or just a Service) is a static class that implements third-party API calls or performs requests do the project database.\nBy design Services don't have access to the request object and play the role of a \"back-end library\".\n// /src/modules/comment/CommentService.ts\nexport default class CommentService {\n    static getUserById(userId: User['id']) {\n        return prisma.users.findUniqueOrThrow({ where: { id: userId } });\n    }\n}","isomorphic-service-class#Isomorphic Service Class":"Isomorphic Service is similar to a Back-end Service but can be used both by front-end (state, components, hooks, other Isomorphic Services, ...) and back-end (Back-End Services, Controllers, CLI scripts, ...).\nThe only difference is that its methods need to be implemented as pure functions. It means that it shouldn't perform DB calls nor access application state but can use other Isomorphic Service Classes.\n// /src/modules/comment/CommentIsomorphicService.ts\nimport PostIsomorphicService from '../post/PostIsomorphicService';\nexport default class CommentIsomorphicService {\n    // a pure function\n    static filterCommentsByPostId(comments: Comment[], posts: Post[], postId: Post['id']) {\n        // filterPostById is also a pure function\n        const post = PostIsomorphicService.filterPostById(posts, postId);\n        if(post.isDeleted) return [];\n        return comments.filter((comment) => comment.postId === postId);\n    }\n    // ...\n}","wpc-class#WPC Class":"Every Isomorphic Service Class can be turned into a WPC Class (Worker Procedure Call) by applying @worker() decorator.\nThe decorator defines required onmessage listeners if it's used in a Web Worker scope.\nIn other cases @worker() decorator does nothing and the class can still be used as an Isomorphic Service somewhere else.\n// /src/modules/hello/HelloWorker.ts\nimport { worker } from 'vovk';\n@worker()\nexport default class HelloWorker {\n    static performHeavyCalculations() {\n        // ...\n    }\n}\nThe compiled WPC interface then can be imported from vovk-client.\n// /src/app/page.tsx\nimport { HelloWorker } from 'vovk-client';\n// ...\nconst onClick = useCallback(async () => {\n    HelloWorker.employ(new Worker(new URL('../modules/hello/HelloWorker.ts', import.meta.url)));\n    const result = await worker.performHeavyCalculations();\n    console.log('result', result);\n}, []);\nWPC Clases can use other WPC Classes, Isomorphic Service Classes and Back-End Controllers imported from vovk-client. For more info check the documentation.","state#State":"State file contains application state code that is going to be imported by React Components and other state files. It can use Isomorphic Services, WPC interfaces and Controllers imported from vovk-client.\nState can be implemented with any application state library: Recoil, Redux, Redux Toolkit, MobX, custom context, or anything else since the framework does not cover state management topic.\nA new state management library is coming soon. Stay tuned!\n// /src/modules/post/PostState.ts\nimport { PostController, PostWorker } from 'vovk-client';\n// ... init app state for posts","other-ideas#Other ideas":"The framework isn't limited by the elements described above and you may want to add more files into your module folder.\nMore Back-end Service Classes.\nMore Isomorphic Service Classes.\nMore WPC classes.\nTests.\nReact Components that you want to categorise (modules/hello/components/MyComponent.tsx).\nTypes (modules/hello/HelloTypes.ts).\nAnything else you can imagine.\nThe framework is a suggestion and you can adjust it to your needs. It's not a strict rule but a way to make your project more structured and maintainable based on the experience of the Vovk.ts creator."}},"/about":{"title":"About","data":{"the-author#The Author":"Being an Upwork freelancer for many years, competing with developers from all\nover the world, I have to increase my effeciency and quality of my code to stay\ncompetitive by learning new technologies and frameworks constantly, and having to always be\nable to deliver the best possible solution for my clients to stay on this highly agressive market.\nHaving over 70 projects completed and thousands of mistakes made, being quite highly paid developer on this market, every time I have to ask myself or bring these questions to teams I work with:\nHow to deliver solutions as fast as possible?\nWhat is the best way to structure the project code?\nHow to build an extensible architecture that's going to be relevant for years?\nWhat libraries are popular today?\nHow can I make my code more readable?\nHow to deploy faster and decrease chances of deployment problems at the most unexpected moment?\nMost importantly, how to not fuck up the entire project after many months of work?\nSure, it sounds challanging but believe me or not I'm having a lot of fun! Being at this rapidly changing environment is like a videogame for me.That's why I came into conclusion that I need to build something that would serve me as a great tool to keep doing my work faster but also keep its quality as high as possible, not depending on if I'm sleepy or I've skipped my workout day.","the-project#The Project":"Vovk.ts combines several approaches borrowed from other libraries and framework with a pinch of creativity.\nWhat's the main and the most powerful framework today? Next.js.\nWhat's the easiest and robust way to deploy Next.js? Vercel (they're not sponsors yet).\nWhat's the most effecient way to invoke server-side code? tRPC or similar? Here you go.\nWhat's the best structure for the app? NestJS providing Controller-Service-Repository pattern? Give me two!\nEdge runtime that allows to deliver back-end geographically closer to users? Yes!\nGood old REST instead of some custom protocols? Sure!\nText streaming for AI apps? No problem.\nTypeScript? Always!\nThe project covers all the requirements I've ever had in my practice into one elegant solution, being a tiny add-on over Next.js API.\nHaving less than 1600 lines of code, it's a perfect tool for building full-stack applications with the highest code quality and the fastest results.Enjoy! You definitely will!","features#Features":"üëµ Good old REST API with no custom protocols.\nüö¢ Run full-stack Next.js application on one port avoiding monorepo hell.\nüßê Service-Controller-Repository pattern for the highest code quality.\nüöÑ Edge runtime is available out of the box.\nüåø Zero dependencies and light weight.\nü§è Generated client code is compact, it's just a wrapper over fetch function.\nüì¶ Bundle and distribute production-ready client API library with Webpack, Rollup or another bundler.\nü§ù Use standard Next.js API such as Response, headers or redirect, nothing is changed.\nüß† Easy to learn.\nüì± Easily integrated with React Native.\nü§ñ Streaming for LLM apps with disposable async generators.\nüìÑ Static API generation with generateStaticAPI\n‚öôÔ∏è Web Worker interface for multi-threading in browser.\nüèéÔ∏è Fast on client and on server.\nüîß Customizable.\nü•∞ TypeScript!"}},"/api-reference":{"title":"API","data":{"":"Full list of available imports for quick reference:\nimport {\n  // core\n  initVovk,\n  createDecorator,\n  // controller method decorators\n  get, \n  post, \n  put, \n  patch, \n  del, \n  head, \n  options, \n  // controller class decorator\n  prefix, \n  // worker service class decorator \n  worker,\n  // core types\n  type VovkClientFetcher,\n  type VovkDefaultFetcherOptions,\n  type VovkConfig,\n  type VovkEnv,\n  type VovkMetadata,\n  type VovkErrorResponse,\n  // types used by controllers\n  type VovkRequest,\n  type VovkControllerBody,\n  type VovkControllerQuery,\n  type VovkControllerParams,\n  type VovkControllerReturnType,\n  type VovkControllerYieldType,\n  // types used by client\n  type VovkBody,\n  type VovkQuery,\n  type VovkParams,\n  type VovkReturnType,\n  type VovkYieldType,\n  type VovkClientOptions,\n  // classes\n  StreamResponse,\n  HttpException,\n  // enums\n  HttpStatus,\n  HttpMethod,\n  // misc\n  generateStaticAPI,\n} from 'vovk';","core#Core":"","initvovk#initVovk":"Creates the standard Next.js App Route handlers used by the main Optional Catch-all Segment. The function accepts the following options:\ncontrollers: Record<string, Function> - the list of Controllers\nworkers?: Record<string, Function> - the list of WPC interfaces\nexposeValidation?: boolean - set to false if you want to hide validation logic from the client-side code.\nonError?: (err: Error, req: NextRequest) => void | Promise<void> - called on Controller exceptions, can be used to log errors by a third-party service. The second argument can be utilised to retrieve reques URL, authorisation info, and other useful information about the failed request.\n// /src/app/api/[[...vovk]]/route.ts\nimport { initVovk } from 'vovk';\nimport HelloController from '../../../modules/hello/HelloController';\nimport UserController from '../../../modules/user/UserController';\nimport HelloWorker from '../../../modules/hello/HelloWorker';\nimport UserWorker from '../../../modules/user/UserWorker';\nconst controllers = { HelloController, UserController };\nconst workers = { HelloWorker, UserWorker };\nexport type Controllers = typeof controllers;\nexport type Workers = typeof workers;\nexport const { GET, POST, PUT, PATCH, DELETE, HEAD, OPTIONS } = initVovk({\n  controllers,\n  workers,\n  exposeValidation: false,\n  onError(e, req) {\n    console.log('Error', e);\n  }\n});","createdecorator#createDecorator":"Defines a custom decorator to extend default behavoir of API endpoints. Accepts 2 arguments: middleware function and init function. The first one defines what the decorator is going to do, the second one is called once per initialisation and intended to pass extra data to the metadata file (for now it's client validation, if exposed).The middleware accepts at least 2 arguments: VovkRequest, next function that needs to be called and its awaited result needs to be returned after you perform required actions and ...rest - the arguments that are going to be used by the created decorator fabric.\nimport { createDecorator, get, HttpException, HttpStatus } from 'vovk';\nconst myDecorator = createDecorator((req, next, a: string, b: number) => {\n  console.log(a, b); // Outputs: \"foo\", 1\n  if(isSomething) { \n    // override route method behavior and return { hello: 'world' } from the endpoint\n    return { hello: 'world' };\n  }\n  if(isSomethingElse) {\n    // throw HTTP error if needed\n    throw new HttpException(HttpStatus.BAD_REQUEST, 'Something went wrong');\n  }\n  return next();\n}, (a: string, b: number) => {\n    console.info('Decorator is initialised with', a, b);\n});\nclass MyController {\n  static controllerName = 'MyController';\n  @get.auto()\n  @myDecorator('foo', 1) // Passes 'foo' as 'a', and 1 as 'b'\n  static getSomething() {\n    // ...\n  }\n}","controller-decorators#Controller Decorators":"","prefix-decorator#@prefix decorator":"@prefix(p: string) decorator used to prepend a sub-path to the endpoint. It's usage is optional.","get-post-put-patch-del-head-options#@get, @post, @put, @patch, @del, @head, @options":"@HTTP_METHOD(p: string, opts?: { cors?: boolean, headers?: Record<string, string> }) decorator define an HTTP method and an endpoint that's handled by the Controller method.","getauto-postauto-putauto#@get.auto, @post.auto, @put.auto...":"@HTTP_METHOD.auto(opts?: { cors?: boolean, headers?: Record<string, string> }) define HTTP method and generate endpoint string automatically from controller and method name.\nimport { prefix, get, post, put, patch, del, head, options } from 'vovk';\n@prefix('hello')\nexport default class HelloController {\n    @get('world', { cors: true })\n    static getHelloWorld() {\n        return { hello: 'world' };\n    }\n    @post.auto({ headers: { 'x-hello': 'world' }})\n    static postData(/* req: VovkRequest */) {\n        return { success: true };\n    }\n}","worker-decorator#worker decorator":"Defines required onmessage handler for a WPC Class.\n// /src/modules/hello/HelloWorker.ts\nimport { worker } from 'vovk';\n@worker()\nexport default class HelloWorker {\n    static heavyCalculation() {\n        // ...\n    }\n}","enums#Enums":"import { HttpMethod, HttpStatus, HttpException } from 'vovk';","httpmethod-enum#HttpMethod enum":"Can be used with your code to create a custom fetcher.\nexport enum HttpMethod {\n  GET = 'GET',\n  POST = 'POST',\n  PUT = 'PUT',\n  PATCH = 'PATCH',\n  DELETE = 'DELETE',\n  HEAD = 'HEAD',\n  OPTIONS = 'OPTIONS',\n}","httpstatus-enum#HttpStatus enum":"Used to throw and catch errors thrown by the server. Notice NULL member. It can be used to simulate HTTP errors on client validation errors (this approach is used at vovk-zod).\nexport enum HttpStatus {\n  NULL = 0,\n  CONTINUE = 100,\n  SWITCHING_PROTOCOLS = 101,\n  PROCESSING = 102,\n  EARLYHINTS = 103,\n  OK = 200,\n  CREATED = 201,\n  ACCEPTED = 202,\n  NON_AUTHORITATIVE_INFORMATION = 203,\n  NO_CONTENT = 204,\n  RESET_CONTENT = 205,\n  PARTIAL_CONTENT = 206,\n  AMBIGUOUS = 300,\n  MOVED_PERMANENTLY = 301,\n  FOUND = 302,\n  SEE_OTHER = 303,\n  NOT_MODIFIED = 304,\n  TEMPORARY_REDIRECT = 307,\n  PERMANENT_REDIRECT = 308,\n  BAD_REQUEST = 400,\n  UNAUTHORIZED = 401,\n  PAYMENT_REQUIRED = 402,\n  FORBIDDEN = 403,\n  NOT_FOUND = 404,\n  METHOD_NOT_ALLOWED = 405,\n  NOT_ACCEPTABLE = 406,\n  PROXY_AUTHENTICATION_REQUIRED = 407,\n  REQUEST_TIMEOUT = 408,\n  CONFLICT = 409,\n  GONE = 410,\n  LENGTH_REQUIRED = 411,\n  PRECONDITION_FAILED = 412,\n  PAYLOAD_TOO_LARGE = 413,\n  URI_TOO_LONG = 414,\n  UNSUPPORTED_MEDIA_TYPE = 415,\n  REQUESTED_RANGE_NOT_SATISFIABLE = 416,\n  EXPECTATION_FAILED = 417,\n  I_AM_A_TEAPOT = 418,\n  MISDIRECTED = 421,\n  UNPROCESSABLE_ENTITY = 422,\n  FAILED_DEPENDENCY = 424,\n  PRECONDITION_REQUIRED = 428,\n  TOO_MANY_REQUESTS = 429,\n  INTERNAL_SERVER_ERROR = 500,\n  NOT_IMPLEMENTED = 501,\n  BAD_GATEWAY = 502,\n  SERVICE_UNAVAILABLE = 503,\n  GATEWAY_TIMEOUT = 504,\n  HTTP_VERSION_NOT_SUPPORTED = 505,\n}","classes#Classes":"","httpexception-class#HttpException class":"Used to throw HTTP errors on server-side and re-throw, simulate and handle HTTP errors on client-side. The instance provides 2 properties: statusCode and message.Server-side:\n// /src/modules/hello/HelloController.tsx\n// ...\nexport default class HelloController {\n    @get()\n    static getHello() {\n        if(/* ... */) {\n            throw new HttpException(HttpStatus.BAD_REQUEST, 'Something went wrong'); \n        }\n    }\n}\nClient-side:\n// /src/modules/hello/HelloState.ts\nimport { HelloController } from 'vovk-client';\nexport async function getHello() {\n    try {\n        return await HelloController.getHello();\n    } catch (e) {\n        console.log(e instanceof HttpException);\n        const err = e as HttpException;\n        console.log(err.statusCode, err.message);\n    }\n}","streamresponse#StreamResponse":"StreamResponse<T>(init?: ResponseInit) class can be used as an alternative to generators to implement response streaming. Instances of this class provide the following methods:\nsend(data: T) - sends portion of data\nclose() - close the connection\nthrow(error: any) - throws an error on client-side and closes the connection\nimport { prefix, get, StreamResponse, type VovkRequest } from 'vovk';\ntype Token = { message: string };\n@prefix('stream')\nexport default class StreamController {\n  @get('tokens')\n  static async streamTokens() {\n    const resp = new StreamResponse<Token>();\n    void (async () => {\n      const tokens: Token[] = [\n        { message: 'Hello,' },\n        { message: ' World' },\n        { message: '!' },\n      ];\n      for (const token of tokens) {\n        await new Promise((resolve) => setTimeout(resolve, 300));\n        if(somethingWentWrong) {\n          resp.throw(new Error('Somethiing went wrong'));\n        }\n        resp.send(token);\n      }\n      resp.close();\n    });\n    return resp;\n  }\n}\nThe class also provides static property defaultHeaders that contains the standard headers for the keep-alive connections. Since StreamResponse accepts standard ResponseInit as options argument you can override default headers and optionally spread StreamResponse.defaultHeaders.\nconst resp = new StreamResponse<Token>({\n  headers: {\n    ...StreamResponse.defaultHeaders,\n    'x-hello': 'world',\n  }\n});","core-types#Core types":"","vovkclientfetcher-and-vovkdefaultfetcheroptions-types#VovkClientFetcher and VovkDefaultFetcherOptions types":"Used to redefine the default fetcher. See customization docs.","vovkconfig-type#VovkConfig type":"Defines config types.\n// /vovk.config.js\n/** @type {import('vovk').VovkConfig} */\nconst vovkConfig = {\n  // ...\n}\nmodule.exports = vovkConfig;\nFor more info check customization docs.","vovkenv-type#VovkEnv type":"Defines Vovk.ts env variable types.For more info check customization docs.","vovkmetadata-type#VovkMetadata type":"Defines format for .vovk.json","vovkerrorresponse-type#VovkErrorResponse type":"Original shape of an object returned from the server when an error is thrown.","controller-types#Controller Types":"","vovkrequest-type#VovkRequest type":"The type is used to define types for req.json and req.nextUrl.searchParams.get and allow to infer types in other environments.\n// /src/modules/hello/HelloController.ts \nimport { get, type VovkRequest } from 'vovk';\nexport class HelloController {\n    @get(':someParam')\n    static doSomething(\n        req: VovkRequest<{ body: true }, { q: string }>, \n        { someParam }: { someParam: string }\n    ) {\n        const body = await req.body(); // { body: true }\n        const q = req.nextUrl.searchParams.get('q'); // string\n        const nope = req.nextUrl.searchParams.get('nope'); // never\n        // ...\n        return { success: true };\n    }\n}","vovkcontrollerbody-type#VovkControllerBody type":"Extracts request body type from a controller method.","vovkcontrollerquery-type#VovkControllerQuery type":"Extracts query (search params) type from a controller method.","vovkcontrollerparams-type#VovkControllerParams type":"Extracts params type from a controller method.","vovkcontrollerreturntype-type#VovkControllerReturnType type":"Extracts return type from a controller method and unwraps the promise.","vovkcontrolleryieldtype-type#VovkControllerYieldType type":"Extracts yield type from a controller method implemented as a generator.\n// /src/modules/hello/HelloState.ts\nimport {\n  get,\n  type VovkControllerBody, \n  type VovkControllerQuery, \n  type VovkControllerParams, \n  type VovkControllerReturnType, \n  type VovkControllerYieldType \n} from 'vovk';\nexport class HelloController {\n    @get(':someParam')\n    static doSomething(/* ... */) {\n        // ...\n    }\n    static *generator(/* ... */)\n}\ntype DoSomethingBody = VovkControllerBody<typeof HelloController.doSomething>;\ntype DoSomethingQuery = VovkControllerQuery<typeof HelloController.doSomething>;\ntype DoSomethingParams = VovkControllerParams<typeof HelloController.doSomething>;\ntype DoSomethingReturnType = VovkControllerReturnType<typeof HelloController.doSomething>;\ntype GeneratorYieldtype = VovkControllerYieldType<typeof HelloController.generator>;","types-for-the-client#Types for the Client":"","vovkbody-type#VovkBody type":"Extracts request body type from a clientized controller method.","vovkquery-type#VovkQuery type":"Extracts query (search params) type from a clientized controller method.","vovkparams-type#VovkParams type":"Extracts params type from a clientized controller method.","vovkreturntype-type#VovkReturnType type":"Extracts return type from a clientized controller method and unwraps the promise.","vovkyieldtype-type#VovkYieldType type":"Extracts yield type from a clientized generator controller method.\nimport { HelloController } from 'vovk-client';\ntype DoSomethingBody = VovkBody<typeof HelloController.doSomething>;\ntype DoSomethingQuery = VovkQuery<typeof HelloController.doSomething>;\ntype DoSomethingParams = VovkParams<typeof HelloController.doSomething>;\ntype DoSomethingReturnType = VovkReturnType<typeof HelloController.doSomething>;\ntype GeneratorYieldtype = VovkYieldType<typeof HelloController.generator>;","vovkclientoptions-type#VovkClientOptions type":"Type that used internally and exposed to customize the client. See decorators documentation.","misc#Misc":"","generatestaticapi#generateStaticAPI":"generateStaticAPI(controllers: Record<string, Function>, slug?: string) is used to generate static endpoints with generateStaticParams at build time instead of on-demand at request time. It can be used in a Static Export mode with the output: 'export' Next.js config setting:\n// next.config.js\n/** @type {import('next').NextConfig} */\nconst nextConfig = {\n  output: 'export',\n};\nmodule.exports = nextConfig;\nTo utilise this feature return generateStaticAPI results from generateStaticParams function.\n// /src/app/api/[[...vovk]]/route.ts\n// ...\nexport type Controllers = typeof controllers;\nexport type Workers = typeof workers;\nexport function generateStaticParams() {\n  return generateStaticAPI(controllers);\n}\nexport const { GET } = initVovk({ controllers, workers });\nIn order to make it work on a static website hosting like Github Pages, you may need to define .json extension in your endpoint definition to make it return proper HTTP headers.\nimport { get, prefix } from 'vovk';\n@prefix('hello')\nexport default class HelloController {\n  @get('greeting.json')\n  static async getHello() {\n    return { greeting: 'Hello world!' };\n  }\n}\nAs result you're going to get an endpoint that looks like that: https://vovk.dev/api/hello/greeting.json.In case if you use custom slug (e.g. /src/app/api/[[...custom]]/route.ts) instead of vovk you can provide it as second argument.\nexport function generateStaticParams() {\n  return generateStaticAPI(controllers, 'custom');\n}"}},"/controller":{"title":"Controller definition","data":{"":"Controller is a static class that handles incoming HTTP requests. The methods of this class, that are decorated with an HTTP decorator (like @get() or @post()), accept 2 arguments: NextRequest that is not modified in any way by Vovk.ts itself and parameters that are defined by the decorator path.\nimport type { NextRequest } from 'next';\nimport { prefix, put } from 'vovk';\n@prefix('users')\nexport default class UserController {\n    // Example request: PUT /api/users/69?role=moderator\n    @put(':id') \n    static async updateUser(req: NextRequest, { id }: { id: string }) {\n        const data = await req.json(); // any\n        const userRole = req.nextUrl.searchParams.get('role'); // string | null\n        // ...\n        return updatedUser;\n    }\n}\nAt the example aboce data is casted as any and userRole is casted as string | null. To fix the body and query types Vovk.ts provides a new type VovkRequest<BODY?, QUERY?> that is extended from NextRequest where the first generic argument represents the type of value returned from req.json but also allows to define values returned from req.nextUrl.searchParams.get. VovkRequest also plays crucial role in type inference when vovk-client is used in order to infer types properly.As its mentioned before, req object is an original NextRequest object that provided by Next.js as is without changing it, but other libraries (like vovk-zod) as well as your custom code can modify this object when needed (for example to add currentUser property defined by your auth guard decorator).To add the required body and query types just replace NextRequest by VovkRequest. Let's modify the abstract example above.\n// /src/modules/user/UserController.ts\nimport { prefix, put, type VovkRequest } from 'vovk';\nimport type { User } from '../../types';\n@prefix('users')\nexport default class UserController {\n    // Example request: PUT /api/users/69?role=moderator\n    @put(':id') \n    static async updateUser(\n        req: VovkRequest<Partial<User>, { role: 'user' | 'moderator' | 'admin' }>, \n        { id }: { id: string }\n    ) {\n        const data = await req.json(); // Partial<User>\n        const userRole = req.nextUrl.searchParams.get('role'); // 'user' | 'moderator' | 'admin'\n        // ...\n        return updatedUser;\n    }\n}\nAs you can see we've changed nothing more than the type of req but now data receives type of Partial<User> and userRole is casted as 'user' | 'moderator' | 'admin' and does not extend null anymore.","controller-initialization#Controller initialization":"Once the controller is defined it needs to be initialized at the wildcard route by adding it to the controllers object.\n// /src/app/api/[[...vovk]]/route.ts\nimport { initVovk } from 'vovk';\nimport UserController from '../../../modules/user/UserController';\nconst controllers = { UserController };\nconst workers = {}; // See Worker documentation\nexport type Controllers = typeof controllers;\nexport type Workers = typeof workers;\nexport const { GET, POST, PUT, DELETE } = initVovk({ controllers, workers });","auto-generated-endpoints#Auto-generated endpoints":"All HTTP decorators provide .auto method that generates endpoint name automatically from the method name.\n// /src/modules/user/UserController.ts\nimport { prefix, put } from 'vovk';\n@prefix('users')\nexport default class UserController {\n    // Example request: PUT /api/users/do-something\n    @put.auto() \n    static async doSomething(/* ... */) {\n        // ...\n    }\n}","response-headers#Response headers":"All HTTP decorators support custom response headers provided as the second argument.\n// ...\nexport default class UserController {\n    @put('do-something', { headers: { 'x-hello': 'world' } }) \n    static async doSomething(/* ... */) { /* ... */ }\n}\nTo enable CORS instead of manually setting up headers you can use cors: true option.\n// ...\nexport default class UserController {\n    @put('do-something', { cors: true }) \n    static async doSomething(/* ... */) { /* ... */ }\n}\nFor auto-generated endpoints cors and headers are defined as the only argument.\n// ...\nexport default class UserController {\n    @put.auto({ cors: true, headers: { 'x-hello': 'world' } }) \n    static async doSomething(/* ... */) { /* ... */ }\n}"}},"/decorators/validation":{"title":"Request Validation","data":{"":"Vovk.ts offers API that allows to validate request body and query string on back-end and performs zero-cost validation on client-side before request to the server is even made.","vovk-zod#vovk-zod":"vovk-zod is the library that implements Zod validation. It performs validation on the Controller side with ZodModel.parse, converts the Zod object to a JSON Schema that's stored at .vovk.json file, and runs validation on client before the HTTP request is made with Ajv.\n// /src/modules/user/UserController.ts\nimport { z } from 'zod';\n// ... other imports ...\nconst UpdateUserModel = z.object({ name: z.string(), email: z.email() }).strict();\nconst UpdateUserQueryModel = z.object({ id: z.uuid() }).strict();\nexport default class UserController {\n    @put.auto()\n    @vovkZod(UpdateUserModel, UpdateUserQueryModel)\n    static updateUser(\n        req: VovkRequest<z.infer<typeof UpdateUserModel>, z.infer<typeof UpdateUserQueryModel>>\n    ) {\n        const { name, email } = await req.json();\n        const id = req.nextUrl.searchParams.get('id');\n        return UserService.updateUser(id, { name, email });\n    }\n}","creating-a-custom-validation-library#Creating a Custom Validation Library":"You can create a decorator that, first of all, validates request on the server-side and optionally populates controller metadata with validation information that is going to be used by the client.The simplest example of the validation would be equality validation. It does nothing than checking if received query and body are equal to some definite object but has no practical use outside of this documentation.At the example below validateEquality decorator is created with createDecorator that accepts 2 arguments: server validation function and init function that populates clientValidators object to define how validation information should be stored at .vovk.json file.\n// /src/decorators/validateEquality.ts\nimport { isEqual } from 'lodash';\nimport { \n  HttpException, HttpStatus, createDecorator, type VovkRequest, type VovkClientOptions \n} from 'vovk';\ntype BodyValidate = Record<string, unknown> | null;\ntype QueryValidate = Record<string, string> | null;\nconst validateEquality = createDecorator(\n  async (req: VovkRequest<unknown>, next, bodyValidate?: BodyValidate, queryValidate?: QueryValidate) => {\n    if (bodyValidate) {\n      const body = await req.json();\n      // override req.json to make it to be called again by controller code\n      req.json = () => Promise.resolve(body);\n      if (!isEqual(body, bodyValidate)) {\n        throw new HttpException(HttpStatus.BAD_REQUEST, 'Server exception. Invalid body');\n      }\n    }\n    if (queryValidate) {\n      const query = Object.fromEntries(req.nextUrl.searchParams.entries());\n      if (!isEqual(query, queryValidate)) {\n        throw new HttpException(HttpStatus.BAD_REQUEST, 'Server exception. Invalid query');\n      }\n    }\n    return next();\n  },\n  (bodyValidate?: BodyValidate, queryValidate?: QueryValidate) => ({\n    clientValidators: {\n      body: bodyValidate,\n      query: queryValidate,\n    },\n  })\n);\nexport default validateEquality;\nThen create a file that defines client-side validation function as default export.\n// /src/decorators/validateEqualityOnClient.ts\nimport { type VovkClientOptions, HttpException, HttpStatus } from 'vovk';\nimport { isEqual } from 'lodash';\n// /src/decorators/validateEqualityOnClient.ts\nconst validateEqualityOnClient: VovkClientOptions['validateOnClient'] = (input, validators) => {\n  if (validators.body) {\n    if (!isEqual(input.body, validators.body)) {\n      throw new HttpException(HttpStatus.NULL, `Client exception. Invalid body`);\n    }\n  }\n  if (validators.query) {\n    if (!isEqual(input.query, validators.query)) {\n      throw new HttpException(HttpStatus.NULL, `Client exception. Invalid query`);\n    }\n  }\n};\nexport default validateEqualityOnClient;\nAt this example validateEquality is used as a controller decorator and validateEqualityOnClient is used internally by the client. Also notice that validateEqualityOnClient throws HttpException with status 0 to simulate regular HTTP exceptions that can be caught by the client-side code.Here is how the newly created decorator is used at the controller.\n// /src/modules/hello/HelloController.ts\nimport type { VovkRequest } from 'vovk';\nimport validateEquality from '../decorators/validateEquality';\nexport default class HelloController {\n    @post.auto()\n    @validateEquality({ foo: 42 }, { bar: 'hello' })\n    static validatedRequest(req: VovkRequest<{ foo: 42 }, { bar: 'hello' }>) {\n        // ...\n    }\n}\nIn order to enable client-side validation you need to define validateOnClient option in vovk.config.js file. For more info see customization documentation.\n/** @type {import('vovk').VovkConfig} */\nconst vovkConfig = {\n    validateOnClient: './src/decorators/validateEqualityOnClient',\n}\nmodule.exports = vovkConfig;\nIf your validation library is published on NPM it needs to follow the same approach but use module name instead of local path to the file.\n/** @type {import('vovk').VovkConfig} */\nconst vovkConfig = {\n    validateOnClient: 'my-validation-library/validateEqualityOnClient',\n}\nmodule.exports = vovkConfig;\nResulting client code is going to look like that:\nimport { HelloController } from 'vovk-client';\n// ...\nconst result = await HelloController.validatedRequest({\n    body: { foo: 42 },\n    query: { bar: 'hello' },\n});\nvalidateEqualityOnClient is going to be invoked on every request before data is sent to the server.","disable-client-validation#Disable client validation":"You can set disableClientValidation option mentioned above to true to disable client validation for debugging purposes.\nconst result = await HelloController.validatedRequest({\n    body: { foo: 42 },\n    query: { bar: 'hello' },\n    disableClientValidation: true,\n});\nIf you want to disable it completely and remove it from .vovk.json file (in case if you want to hide server-side validation implementation) you can use exposeValidation option set to false at the Next.js wildcard router level.\n// /src/api/[[...vovk]]/route.ts\n// ...\nexport const { GET, POST, PATCH, PUT } = initVovk({\n    controllers,\n    workers,\n    exposeValidation: false // don't populate metadata file with validation information\n});"}},"/":{"title":"Index","data":{}},"/getting-started":{"title":"Getting Started","data":{"quick-install#Quick install":"Setup Vovk.ts with create-next-app.\nnpx create-next-app -e https://github.com/finom/vovk-hello-world\nInside the project folder run npm run dev and open http://localhost:3000.","manual-install#Manual install":"","create-nextjs-project-with-app-router#Create Next.js project with App Router":"Follow this instruction to install Next.js. Use TypeScript, App Router and src/ directory.\nnpx create-next-app\nChoices example:","install-vovkts-and-concurrently#Install Vovk.ts and Concurrently":"At the newly created folder run:\nnpm i vovk vovk-client\npnpm i vovk vovk-client\nyarn add vovk vovk-client\nThen install concurrently, the recommended way to run Vovk.ts and Next.js together.\nnpm i concurrently --save-dev\npnpm i concurrently --dev\nyarn add concurrently --dev","enable-decorators#Enable decorators":"In your tsconfig.json set \"experimentalDecorators\" to true.\n{\n    \"compilerOptions\": {\n        \"experimentalDecorators\": true,\n        // ...\n    }\n}","set-up-nextjs-wildcard-route-handler-and-export-types-read-by-the-client-library#Set up Next.js wildcard route handler and export types read by the client library":"Create file /src/app/api/[[...vovk]]/route.ts where [[...vovk]] is a folder name insicating what Next.js documentation calls \"Optional Catch-all Segment\" that can be customized. This is the core entry point for all Vovk.ts routes.\n// /src/app/api/[[...vovk]]/route.ts\nimport { initVovk } from 'vovk';\nexport const runtime = 'edge';\nconst controllers = {};\nconst workers = {};\n// export types used by the client\nexport type Controllers = typeof controllers;\nexport type Workers = typeof workers;\nexport const { GET, POST, PUT, DELETE } = initVovk({ controllers, workers });\nEnabling Edge Runtime is optional.","create-first-controller-and-add-it-to-the-controller-object#Create first controller and add it to the controller object":"Create HelloController.ts at /src/modules/hello/ with same-named static class.\n// /src/modules/hello/HelloController.ts\nimport { get, prefix } from \"vovk\";\n@prefix('hello') // prefix is optional\nexport default class HelloController {\n    @get('greeting')\n    static getHello() {\n        return { greeting: 'Hello world!' };\n    }\n}\nAnd add this class at /src/app/api/[[...vovk]]/route.ts to the controllers object.\n// /src/app/api/[[...vovk]]/route.ts\nimport HelloController from '../../../modules/hello/HelloController';\n// ...\nconst controllers = { HelloController };\n// ...\nThe code above creates GET endpoint to /api/hello/greeting. You can also use named export for the controller if needed.","run-vovk-dev-and-next-dev-with-concurrently#Run vovk dev and next dev with concurrently":"Create an NPM script in package.json that runs vovk dev and next dev together specifying the port explicitly.\nVovk server also utilises the port by adding 6969 number to it (if Next.js PORT is 3000, Vovk.ts port is 9969).Vovk.ts works by exchanging data between Next.js and Vovk Server, which means knowing the ports on both sides is essential.\n\"scripts\": {\n    \"dev\": \"PORT=3000 concurrently 'vovk dev' 'next dev' --kill-others\"\n}\nOnce you run npx run dev you're going to notice the new file .vovk.json created in the root of your project. This file contains required information to build the client and it needs to be committed.\nIt's going to be updated automatically when your project structure is changed. Open http://localhost:3000.Alternatively, you can use use built-in concurrently-like process runner to run both servers and assign ports automatically.\nnpx vovk dev --next-dev\nBesides .vovk.json the command also generates client .js and .ts files inside node_modules/.vovk that are re-exported by vovk-client module to make no error if vovk-client is not installed. This approach is borrowed from Prisma ORM.","create-a-react-component#Create a React component":"Now the client is generated you can safely import your client library from vovk-client.\n'use client';\nimport { useState } from 'react';\nimport { HelloController } from 'vovk-client';\nimport type { VovkReturnType } from 'vovk';\nexport default function MyComponent() {\n  const [serverResponse, setServerResponse] = useState<VovkReturnType<typeof HelloController.getHello>>();\n  return (\n    <>\n      <button\n        onClick={async () => {\n          const response = await HelloController.getHello();\n          setServerResponse(response);\n        }}\n      >\n        Get Greeting from Server\n      </button>\n      <div>{serverResponse?.greeting}</div>\n    </>\n  );\n}\nNote that if you're using VSCode you're probably going to need to restart TS server each time when you add a new controller or worker service to your app because by the time being TS Server doesn't update types imported from node_modules automatically when they were changed. This is a well-known problem that bothers Prisma ORM developers for long time. In all other scenarios (when you add a new method, change body type, etc) you don't need to do that since TS server reads Controllers and Workers that you export from /src/app/api/[[...vovk]]/route.ts.Next.js Server Components are also supported but require to define absolute URL (by default all requests are made to /api). Check the Server Component Example for more information.Methods of the generated library approximately have the following signature:\ninterface Options extends Omit<RequestInit, 'body' | 'method'> {\n  reactNative?: { textStreaming: boolean };\n  prefix?: string;\n  disableClientValidation?: boolean;\n  body: VovkBody<typeof Controller.method>\n  params: VovkParams<typeof Controller.method>\n  query: VovkQuery<typeof Controller.method>\n}\nIn other words it supports custom Next.js options (Because Next.js extends RequestInit global type) as well as React Native Fetch API.\nawait HelloController.hello({\n  body: { foo: 'bar' },\n  next: { revalidate: 3600 },\n});","build-and-deploy#Build and deploy":"You're going to need to run npx vovk generate to generate the client before the build with the standard npx next build or when node_modules are re-installed.To easily build the project on Vercel you can create \"vercel-build\" npm script at package.json.\n\"scripts\": {\n    \"vercel-build\": \"vovk generate && next build\"\n}","examples#Examples":"You can check more examples here."}},"/worker":{"title":"WPC Class (Worker Procedure Call)","data":{"":"The standard Web Workers are awesome but they require to write additional logic by using onmessage handler on both sides (main thread and the Woker thread) and exchange data using postMessage. Vovk.ts applies the same principle that is used at controllers and builds main-thread client-side library using the auto-generated .vovk.json. It uses built-in browser API aush as addEventListener and postMessage and does not utilise eval function or Function constructor.WPC Class is created from an Isomorphic Service Class by applying @worker() class decorator that defines onmessage handler in the Web Worker scope.\nQuick explanation: Isomorphic Service Class is a static class that provides code that is shared between front-end and back-end. It should implement static methods as pure functions that don't have access to neither application state nor server-side capabilities such as access to the database.\n// /src/modules/hello/HelloWorker.ts\nimport { worker } from 'vovk';\n@worker()\nexport default class HelloWorker {\n    static heavyCalculation(iterations: number) {\n        let result: number;\n        // ... heavy calculations\n        return result;\n    }\n}\nIn a non-worker scope @worker() does nothing. You can import the class safely in other modules, including back-end code where it's going to be behave as a normal collection of pure functions.To compile the worker interface, you need to pass them to initVovk as workers object option and export the type of this object as Workers.\n// /src/app/api/[[...vovk]]/route.ts\nimport { initVovk } from 'vovk';\nimport HelloController from '../../../hello/HelloController';\nimport HelloWorker from '../../../hello/HelloWorker';\nimport ByeWorker from '../../../bye/ByeWorker';\nconst controllers = { HelloController };\nconst workers = { HelloWorker, ByeWorker };\nexport type Controllers = typeof controllers;\nexport type Workers = typeof workers;\nexport const { GET, POST, PUT, DELETE } = initVovk({ controllers, workers });\nOnce this is done, vovk-client is going to export the worker library that provides interface to invoke heavy calculations but doesn't initialise the Web Worker itself. To initialise the Web Worker at the main-thread interface it needs to be initialised and passed as an argument of employ static method.\nimport { HelloWorker } from 'vovk-client';\nHelloWorker.employ(new Worker(new URL('./path/to/HelloWorker.ts', import.meta.url)));\nThis bulky syntax is required to invoke the Webpack 5+ loader used by Next.js internally. After it's done the static methods of the mapped class type return Promise to delegate heavy calculations to the parallel thread.\nconst result = await HelloWorker.heavyCalculation(1e9);\nNote that Worker class does not exist in Next.js SSR environment and in case if the code is exposed to non-client-side environment (for example outside of useEffect) it's recommended to check Worker for existence.\nimport { HelloWorker } from 'vovk-client';\nif(typeof Worker !== 'undefined') {\n    HelloWorker.employ(new Worker(new URL('./path/to/HelloWorker.ts', import.meta.url)));\n}\nemploy method returns the worker interface itself so as a nicer solution you can use ternary operator to make the Worker library to be nullish.\nimport { HelloWorker } from 'vovk-client';\nconst MyWorker = typeof Worker === 'undefined' \n    ? null \n    : HelloWorker.employ(new Worker(new URL('./path/to/HelloWorker.ts', import.meta.url)));\nawait MyWorker?.heavyCalculation(1e9);","worker-termination#Worker termination":"A worker can be terminated with built-in terminate method.\nHelloWorker.terminate();","async-generators#Async generators":"WPC classes support generators and async generators to implement continious event streaming.\n// /src/modules/hello/HelloWorker.ts\nimport { worker } from 'vovk';\n@worker()\nexport default class HelloWorker {\n    static *generator() {\n        for (let i = 0; i < 10; i++) {\n            yield i;\n        }\n    }\n    static async *asyncGenerator() {\n        for (let i = 0; i < 10; i++) {\n            await new Promise((resolve) => setTimeout(resolve, 100));\n            yield i;\n        }\n    }\n}\nVovk.ts turns them both into async generators when they're imported from vovk-client.\nimport { HelloWorker } from 'vovk-client';\n// ... plug in the Web Worker with \"use\" method ...\nfor await (const number of HelloWorker.generator()) {\n    console.log(number); // 0 ... 9\n}\nfor await (const number of HelloWorker.asyncGenerator()) {\n    console.log(number); // 0 ... 9\n}","making-http-requests-inside-a-wpc-class#Making HTTP requests inside a WPC Class":"Since Web Workers are run in a browser (but just in another thread) it's capable to fetch server-side data as expected.\n// /src/modules/hello/HelloController.ts\nimport { get } from 'vovk';\nexport class HelloController {\n    @get.auto()\n    static getIterations() {\n        return { iterations: 100_000_000 };\n    }\n}\n// /src/modules/hello/HelloWorker.ts\nimport { HelloController } from 'vovk-client';\n@worker()\nexport default class HelloWorker {\n    static async heavyCalculation() {\n        const { iterations } = await HelloController.getIterations();\n        let result: number;\n        // ...\n        return result;\n    }\n}","using-wpc-class-inside-another-wpc-class#Using WPC Class inside another WPC Class":"Workers can use other workers. The syntax remains the same and you don't need to check for Worker variable to exist.\nimport { AnotherWorker } from 'vovk-client';\nexport default class HelloWorker {\n    heavyCalculation() {\n        const anotherWorkerResult = await AnotherWorker.doSomethingHeavy();\n        // ...\n    }\n}","forking-the-worker#Forking the Worker":"To fork the worker and create as many parallel processes as needed you can use fork method instead of employ.\nimport { HelloWorker } from 'vovk-client';\nfunction getFork() {\n    return HelloWorker.fork(new Worker(new URL('./path/to/HelloWorker.ts', import.meta.url)));\n}\nconst HelloWorker1 = getFork();\nconst HelloWorker2 = getFork();\nconst HelloWorker3 = getFork();\nconst [result1, result2, result3] = await Promise.all([\n    HelloWorker1.heavyCalculation(),\n    HelloWorker2.heavyCalculation(),\n    HelloWorker3.heavyCalculation(),\n]);"}}}